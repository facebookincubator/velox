<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>How to add a lambda function? &#8212; Velox  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/nature.css?v=601dbdee" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Expression Evaluation" href="expression-evaluation.html" />
    <link rel="prev" title="View and Writer Types" href="view-and-writer-types.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="expression-evaluation.html" title="Expression Evaluation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="view-and-writer-types.html" title="View and Writer Types"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Velox  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../develop.html" accesskey="U">Developer Guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">How to add a lambda function?</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="how-to-add-a-lambda-function">
<h1>How to add a lambda function?<a class="headerlink" href="#how-to-add-a-lambda-function" title="Link to this heading">¶</a></h1>
<p>This article assumes familiarity with <a class="reference external" href="https://prestodb.io/blog/2020/03/02/presto-lambda">Presto’s lambda functions</a>.</p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Velox supports lambda functions which are used to implement computations over
arrays and maps. Lambda functions are higher order functions that take
arguments which are functions themselves. For example, the <a class="reference internal" href="../functions/presto/array.html#filter" title="filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a>
function takes an array or a map and a predicate and returns a subset of the
array or map elements which pass the predicate. The <a class="reference internal" href="../functions/presto/array.html#transform" title="transform"><code class="xref py py-func docutils literal notranslate"><span class="pre">transform()</span></code></a> function
takes an array and a function, applies that function to each element of the
array and returns an array of results.</p>
<p>Here is an example of using filter and transform functions in Presto SQL:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="n">filter</span><span class="p">(</span><span class="nb">array</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span>

<span class="o">&gt;</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="k">transform</span><span class="p">(</span><span class="nb">array</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span>
</pre></div>
</div>
<p>“x -&gt; x % 2 = 0” is a lambda expression. It consists of a signature and a body
separated by an “arrow”. Notice that in Presto SQL the signature of a lambda
consists only of argument names. Argument types are inferred from the context,
e.g. from the type of the array argument of “filter”.</p>
<p>Lambdas may use captures to access any column in the scope of the enclosing
function. Let’s say we have a dataset with an array column “a” and an integer
column “b”:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>a: array(integer)</p></th>
<th class="head"><p>b: integer</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>[1, 2, 3, 4]</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-odd"><td><p>[3, 1, 5, 6, 7]</p></td>
<td><p>4</p></td>
</tr>
</tbody>
</table>
<p>We can filter the array “a” to keep only elements that are greater than or equal
to “b”:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="n">filter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>

<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">]</span>
</pre></div>
</div>
<p>Here, “b” in the lambda expression is the capture. Lambda expressions can use
zero or more captures.</p>
<p>Further, it is possible to apply different lambda expressions to different rows
in the dataset. For example, we can filter the array “a” to keep even elements
if “b” is even and odd elements if “b” is odd.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="n">filter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>

<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
<p>Note: At the time of writing Presto didn’t support this syntax.</p>
</section>
<section id="function-vector">
<h2>Function Vector<a class="headerlink" href="#function-vector" title="Link to this heading">¶</a></h2>
<p>In Velox, lambda functions must be implemented as vector functions. These
receive their lambda inputs as vectors of type FUNCTION. For example,
the “filter” function receives two vectors: a vector of type ARRAY and another
vector of type FUNCTION.</p>
<p>Function type is a nested type whose children contain lambda argument types
followed by lambda return type. The exact type of the lambda argument of
the “filter” function above is FUNCTION(INTEGER(), BOOLEAN()).</p>
<p>Function vectors are implemented using the FunctionVector class. These vectors
store callable objects that represent executable lambda expressions in a
compact form. In most cases lambda expression is the same for all rows, but it
is possible for different rows to be associated with different lambdas as we
have seen above. FunctionVector stores a list of different lambdas along with a
set of rows each lambda applies to. Each lambda is represented as an object of
type Callable which allows for evaluating the lambda on a set of rows.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Callable</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">hasCapture</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">apply</span><span class="p">(</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">SelectivityVector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span>
<span class="w">      </span><span class="n">BufferPtr</span><span class="w"> </span><span class="n">wrapCapture</span><span class="p">,</span>
<span class="w">      </span><span class="n">exec</span><span class="o">::</span><span class="n">EvalCtx</span><span class="o">&amp;</span><span class="w"> </span><span class="n">context</span><span class="p">,</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VectorPtr</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">,</span>
<span class="w">      </span><span class="n">VectorPtr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The “apply” method of Callable is similar to the “apply” method of
VectorFunction as it takes a set of rows to evaluate on and a list of vectors
representing the input data. For example, the “filter” function uses
Callable::apply to evaluate the lambda on the elements of the input array. In
this case, “rows” represents the rows of the elements vector and “args”
contains a single elements vector. The “result” is a boolean vector which
has “true” value for the elements which pass the predicate and “false” value
for the elements which do not.</p>
<a class="reference internal image-reference" href="../_images/lambda-apply.png"><img alt="../_images/lambda-apply.png" src="../_images/lambda-apply.png" style="width: 600px;" /></a>
<p>In addition to “rows” and “args”, Callable::apply() method takes an
optional “wrapCapture” buffer parameter. This parameter must be specified if
the lambda expression uses a capture, e.g. if Callable::hasCapture() returns
true. The “wrapCapture” buffer is used to align the top-level capture rows with
the nested rows of the array elements or map keys or values.</p>
<p>Consider the “filter(a, x -&gt; x &gt;= b)” example. The “x &gt;= b” expression requires
two inputs: “x” and “b”. Here, “x” is an element of the array with a total of 9
rows, while “b” is a top-level column with just 2 rows. To align “x” and “b” we
need to repeat “b” as many times as there are elements in the corresponding
array.</p>
<a class="reference internal image-reference" href="../_images/lambda-apply-with-capture.png"><img alt="../_images/lambda-apply-with-capture.png" src="../_images/lambda-apply-with-capture.png" style="width: 500px;" /></a>
<p>If there are multiple captures, all of them need to be aligned in the same way,
e.g. their values need to be repeated as many times as there are elements in
the corresponding array or map. The “wrapCapture” parameter in Callable::apply
() is used to specify an indices buffer that can be used to wrap captures in
dictionary vectors to achieve this alignment. The Callable object already
contains the vectors for captures and these do not need to be included in
the “args” parameter of the “apply()” method.</p>
<p>Unlike other vectors, FunctionVector doesn’t allow access to Callable objects
for individual rows. Instead, it provides an iterator which returns unique
instances of the Callable object along with a set of rows they apply to.</p>
<p>For example, “filter” function can iterate over distinct Callables like so:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">asUnchecked</span><span class="o">&lt;</span><span class="n">FunctionVector</span><span class="o">&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">iterator</span><span class="p">(</span><span class="n">rows</span><span class="p">);</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="n">next</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span><span class="w"> </span><span class="n">entry</span><span class="p">.</span><span class="n">callable</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">Callable</span><span class="w"> </span><span class="p">...</span>
<span class="w">    </span><span class="p">...</span><span class="w"> </span><span class="n">entry</span><span class="p">.</span><span class="n">rows</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="k">this</span><span class="w"> </span><span class="n">Callable</span><span class="w"> </span><span class="n">applies</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In most cases there will be only one instance of Callable, but function
implementations need to allow for multiple.</p>
<p>FunctionVector::iterator() method takes SelectivityVector parameter which
restricts the returned iterator to a subset of the specified rows. These
usually are the rows the lambda function is evaluated on, e.g. the “rows”
parameter to VectorFunction::apply() method.</p>
</section>
<section id="end-to-end-flow">
<h2>End-to-End Flow<a class="headerlink" href="#end-to-end-flow" title="Link to this heading">¶</a></h2>
<p>A lambda function call in an expression tree is represented by a CallTypedExpr
node with a LambdaTypedExpr child. The “filter(a, x -&gt; x % 2 = 0)” would be
represented like this:</p>
<a class="reference internal image-reference" href="../_images/lambda-end-to-end.png"><img alt="../_images/lambda-end-to-end.png" src="../_images/lambda-end-to-end.png" style="width: 800px;" /></a>
<p>Note that LambdaTypedExpr node doesn’t have any children. The expression that
represents the body of the lambda is contained inside the LambdaTypedExpr
node.</p>
<p>This expression tree is compiled into a tree of executable expressions.
LambdaTypedExpr is compiled into a special form LambdaExpr which includes a
compiled body (an instance of executable expression, e.g.
std::shared_ptr&lt;Expr&gt;) and a list of FieldReference instances for captures. A
result of evaluating LambdaExpr is a FunctionVector.
LambdaExpr::evalSpecialForm() creates instances of Callable and stores them in
a FunctionVector.</p>
</section>
<section id="lambda-function-signature">
<h2>Lambda Function Signature<a class="headerlink" href="#lambda-function-signature" title="Link to this heading">¶</a></h2>
<p>To specify a signature of a lambda function use “function(argType1, argType2,..,
returnType)” syntax for the type of the lambda argument. Here is an example of
the signature of the “filter” function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// array(T), function(T, boolean) -&gt; array(T)</span>
<span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">exec</span><span class="o">::</span><span class="n">FunctionSignatureBuilder</span><span class="p">()</span>
<span class="w">            </span><span class="p">.</span><span class="n">typeVariable</span><span class="p">(</span><span class="s">&quot;T&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="p">.</span><span class="n">returnType</span><span class="p">(</span><span class="s">&quot;array(T)&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="p">.</span><span class="n">argumentType</span><span class="p">(</span><span class="s">&quot;array(T)&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="p">.</span><span class="n">argumentType</span><span class="p">(</span><span class="s">&quot;function(T,boolean)&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="p">.</span><span class="n">build</span><span class="p">()};</span>
</pre></div>
</div>
</section>
<section id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="Link to this heading">¶</a></h2>
<p>Testing framework doesn’t support Presto SQL lambda expressions, e.g. one cannot
evaluate “filter(a, x - &gt;x &gt;= b)” expression directly. Instead, use the
registerLambda helper method of the FunctionBaseTest class to register lambda
expression and give it a name, then use that name to specify the lambda
parameter. Here is an example that evaluates “filter(a, x -&gt;x &gt;= b)” expression
in a test:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">rowType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ROW</span><span class="p">({</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="n">ARRAY</span><span class="p">(</span><span class="n">BIGINT</span><span class="p">()),</span><span class="w"> </span><span class="n">BIGINT</span><span class="p">()});</span>

<span class="n">registerLambda</span><span class="p">(</span><span class="s">&quot;lambda&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ROW</span><span class="p">({</span><span class="s">&quot;x&quot;</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="n">BIGINT</span><span class="p">()}),</span><span class="w"> </span><span class="n">rowType</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x &gt;= b&quot;</span><span class="p">));</span>

<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">evaluate</span><span class="o">&lt;</span><span class="n">BaseVector</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;filter(a, function(&#39;lambda&#39;))&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
<p>The first argument to registerLambda is the name for the lambda. This name can
later be used to refer to the lambda in a function call.</p>
<p>The second argument is the signature of the lambda, e.g. the list of lambda
parameters along with their names and types.</p>
<p>The third argument is the type of the input data to the overall expression. This
is used to resolve the types of captures.</p>
<p>The last argument is the lambda body as SQL expression.</p>
<p>To specify lambda expression as an argument of a lambda function use function
(‘&lt;lambda-name&gt;’) syntax.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">How to add a lambda function?</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#function-vector">Function Vector</a></li>
<li><a class="reference internal" href="#end-to-end-flow">End-to-End Flow</a></li>
<li><a class="reference internal" href="#lambda-function-signature">Lambda Function Signature</a></li>
<li><a class="reference internal" href="#testing">Testing</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="view-and-writer-types.html"
                          title="previous chapter">View and Writer Types</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="expression-evaluation.html"
                          title="next chapter">Expression Evaluation</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/develop/lambda-functions.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="expression-evaluation.html" title="Expression Evaluation"
             >next</a> |</li>
        <li class="right" >
          <a href="view-and-writer-types.html" title="View and Writer Types"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Velox  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../develop.html" >Developer Guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">How to add a lambda function?</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright TBD.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>