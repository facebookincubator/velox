<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Plan Nodes and Operators &#8212; Velox  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../_static/nature.css?v=0f882399" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="What’s in the Task?" href="task.html" />
    <link rel="prev" title="Anti joins" href="anti-join.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="task.html" title="What’s in the Task?"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="anti-join.html" title="Anti joins"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Velox  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../develop.html" accesskey="U">Developer Guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Plan Nodes and Operators</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="plan-nodes-and-operators">
<h1>Plan Nodes and Operators<a class="headerlink" href="#plan-nodes-and-operators" title="Link to this heading">¶</a></h1>
<p>Velox query plan is a tree of PlanNode’s. Each PlanNode has zero or more child
PlanNode’s. To execute a query plan, Velox converts it into a set of pipelines.
Each pipeline is made of a linear sequence of operators that corresponds to a
linear sub-tree of the plan. The plan tree is broken down into a set of linear
sub-trees by disconnecting all but one child node from each node that has two
or more children.</p>
<a class="reference internal image-reference" href="../_images/local-planner.png"><img alt="../_images/local-planner.png" class="align-center" src="../_images/local-planner.png" style="width: 400px;" />
</a>
<p>The conversion of plan nodes to operators is mostly one-to-one. Some exceptions are:</p>
<ul class="simple">
<li><p>Filter node followed by Project node is converted into a single operator FilterProject</p></li>
<li><p>Nodes with two or more child nodes are converted to multiple operators, e.g. HashJoin node is converted to a pair of operators: HashProbe and HashBuild.</p></li>
</ul>
<p>Operators corresponding to leaf nodes are called source operators. Only a subset
of plan nodes can be located at the leaves of the plan tree. These are:</p>
<ul class="simple">
<li><p>TableScanNode</p></li>
<li><p>ValuesNode</p></li>
<li><p>ExchangeNode</p></li>
<li><p>MergeExchangeNode</p></li>
<li><p>ArrowStreamNode</p></li>
</ul>
<p>Here is a list of supported plan nodes and corresponding operators.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Plan Node</p></th>
<th class="head"><p>Operator(s)</p></th>
<th class="head"><p>Leaf Node / Source Operator</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>TableScanNode</p></td>
<td><p>TableScan</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>ArrowStreamNode</p></td>
<td><p>ArrowStream</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>FilterNode</p></td>
<td><p>FilterProject</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ProjectNode</p></td>
<td><p>FilterProject</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>AggregationNode</p></td>
<td><p>HashAggregation or StreamingAggregation</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>GroupIdNode</p></td>
<td><p>GroupId</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>MarkDistinctNode</p></td>
<td><p>MarkDistinct</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>HashJoinNode</p></td>
<td><p>HashProbe and HashBuild</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>MergeJoinNode</p></td>
<td><p>MergeJoin</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>NestedLoopJoinNode</p></td>
<td><p>NestedLoopJoinProbe and NestedLoopJoinBuild</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>OrderByNode</p></td>
<td><p>OrderBy</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>TopNNode</p></td>
<td><p>TopN</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>LimitNode</p></td>
<td><p>Limit</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>UnnestNode</p></td>
<td><p>Unnest</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>TableWriteNode</p></td>
<td><p>TableWrite</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>TableWriteMergeNode</p></td>
<td><p>TableWriteMerge</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>PartitionedOutputNode</p></td>
<td><p>PartitionedOutput</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>ExchangeNode</p></td>
<td><p>Exchange</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>ExpandNode</p></td>
<td><p>Expand</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>MergeExchangeNode</p></td>
<td><p>MergeExchange</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>ValuesNode</p></td>
<td><p>Values</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>LocalMergeNode</p></td>
<td><p>LocalMerge</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>LocalPartitionNode</p></td>
<td><p>LocalPartition and LocalExchange</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>EnforceSingleRowNode</p></td>
<td><p>EnforceSingleRow</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>EnforceDistinctNode</p></td>
<td><p>EnforceDistinct or StreamingEnforceDistinct</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>AssignUniqueIdNode</p></td>
<td><p>AssignUniqueId</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>WindowNode</p></td>
<td><p>Window</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>RowNumberNode</p></td>
<td><p>RowNumber</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>TopNRowNumberNode</p></td>
<td><p>TopNRowNumber</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>MixedUnionNode</p></td>
<td><p>MixedUnion</p></td>
<td></td>
</tr>
</tbody>
</table>
<section id="plan-nodes">
<h2>Plan Nodes<a class="headerlink" href="#plan-nodes" title="Link to this heading">¶</a></h2>
<section id="tablescannode">
<span id="id1"></span><h3>TableScanNode<a class="headerlink" href="#tablescannode" title="Link to this heading">¶</a></h3>
<p>The table scan operation reads data from a <a class="reference internal" href="connectors.html"><span class="doc">connector</span></a>. For example, when used
with HiveConnector, table scan reads data from ORC or Parquet files.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>outputType</p></td>
<td><p>A list of output columns. This is a subset of columns available in the underlying table. The order of columns may not match the schema of the table.</p></td>
</tr>
<tr class="row-odd"><td><p>tableHandle</p></td>
<td><p>Connector-specific description of the table. May include a pushed down filter.</p></td>
</tr>
<tr class="row-even"><td><p>assignments</p></td>
<td><p>Connector-specific mapping from the table schema to output columns.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="arrowstreamnode">
<span id="arrowstream-operator"></span><h3>ArrowStreamNode<a class="headerlink" href="#arrowstreamnode" title="Link to this heading">¶</a></h3>
<p>The Arrow stream operation reads data from an Arrow array stream. The ArrowArrayStream structure is defined in Arrow abi,
and provides the required callbacks to interact with a streaming source of Arrow arrays.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>arrowStream</p></td>
<td><p>The constructed Arrow array stream. This is a streaming source of data chunks, each with the same schema.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="filternode">
<h3>FilterNode<a class="headerlink" href="#filternode" title="Link to this heading">¶</a></h3>
<p>The filter operation eliminates one or more records from the input data based
on a boolean filter expression.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>filter</p></td>
<td><p>Boolean filter expression.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="projectnode">
<h3>ProjectNode<a class="headerlink" href="#projectnode" title="Link to this heading">¶</a></h3>
<p>The project operation produces one or more additional expressions based on the
inputs of the dataset. The project operation may also drop one or more of the
input columns.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>names</p></td>
<td><p>Column names for the output expressions.</p></td>
</tr>
<tr class="row-odd"><td><p>expressions</p></td>
<td><p>Expressions for the output columns.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="aggregationnode">
<span id="id2"></span><h3>AggregationNode<a class="headerlink" href="#aggregationnode" title="Link to this heading">¶</a></h3>
<p>The aggregate operation groups input data on a set of grouping keys, calculating
each measure for each combination of the grouping keys. Optionally, inputs for
individual measures are sorted and de-duplicated.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>step</p></td>
<td><p>Aggregation step: partial, final, intermediate, single.</p></td>
</tr>
<tr class="row-odd"><td><p>groupingKeys</p></td>
<td><p>Zero or more grouping keys.</p></td>
</tr>
<tr class="row-even"><td><p>preGroupedKeys</p></td>
<td><p>A subset of the grouping keys on which the input is known to be pre-grouped, i.e. all rows with a given combination of values of the pre-grouped keys appear together one after another. The input is not assumed to be sorted on the pre-grouped keys. If input is pre-grouped on all grouping keys the execution will use the StreamingAggregation operator.</p></td>
</tr>
<tr class="row-odd"><td><p>aggregateNames</p></td>
<td><p>Names for the output columns for the measures.</p></td>
</tr>
<tr class="row-even"><td><p>aggregates</p></td>
<td><p>One or more measures to compute. Each measure specifies an expression, e.g. count(1), sum(a), avg(b), optional boolean input column that’s used to mask out rows for this particular measure, optional list of input columns to sort by before computing the measure, an optional flag to indicate that inputs must be deduplicated before computing the measure. Expressions must be in the form of aggregate function calls over input columns directly, e.g. sum(c) is ok, but sum(c + d) is not.</p></td>
</tr>
<tr class="row-odd"><td><p>ignoreNullKeys</p></td>
<td><p>A boolean flag indicating whether the aggregation should drop rows with nulls in any of the grouping keys. Used to avoid unnecessary processing for an aggregation followed by an inner join on the grouping keys.</p></td>
</tr>
<tr class="row-even"><td><p>globalGroupingSets</p></td>
<td><p>If the AggregationNode is over a GroupIdNode, then some groups could be global groups which have only GroupId grouping key values. These represent global aggregate values.</p></td>
</tr>
<tr class="row-odd"><td><p>groupId</p></td>
<td><p>GroupId is the grouping key in the AggregationNode for the groupId column generated by an underlying GroupIdNode. It must be of BIGINT type.</p></td>
</tr>
</tbody>
</table>
<p>Properties of individual measures.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>call</p></td>
<td><p>An expression for computing the measure, e.g. count(1), sum(a), avg(b). Expressions must be in the form of aggregate function calls over input columns directly, e.g. sum(c) is ok, but sum(c + d) is not.</p></td>
</tr>
<tr class="row-odd"><td><p>rawInputTypes</p></td>
<td><p>A list of raw input types for the aggregation function. There are used to correctly identify aggregation function, e.g. to decide between min(x) and min(x, n) in case of intermediate aggregation. These can be different from the input types specified in ‘call’ when aggregation step is intermediate or final.</p></td>
</tr>
<tr class="row-even"><td><p>mask</p></td>
<td><p>An optional boolean input column that’s used to mask out rows for this particular measure. Multiple measures may specify same input column as a mask.</p></td>
</tr>
<tr class="row-odd"><td><p>sortingKeys</p></td>
<td><p>An optional list of input columns to sort by before computing the measure. If specified, sortingOrders must be used to specify the sort order for each sorting key.</p></td>
</tr>
<tr class="row-even"><td><p>sortingOrders</p></td>
<td><p>A list of sorting orders for each sorting key.</p></td>
</tr>
<tr class="row-odd"><td><p>distinct</p></td>
<td><p>A boolean flag indicating that inputs must be de-duplicated before computing the measure.</p></td>
</tr>
</tbody>
</table>
<p>Note that if measures specify sorting keys, HashAggregation operator accumulates
all input rows in memory before sorting these and adding to accumulators. This
requires a lot more memory as compared to when inputs do not need to be sorted.</p>
<p>Similarly, if measures request inputs to be de-duplicated, HashAggregation
operator accumulates all distinct input rows in memory before adding these to
accumulators. This requires more memory as compared to when inputs do not need
to be de-duplicated.</p>
<p>Furthermore, many aggregate functions produce same results on sorted and
unsorted inputs, e.g. <a class="reference internal" href="../functions/presto/aggregate.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="../functions/presto/aggregate.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="../functions/presto/aggregate.html#count" title="count"><code class="xref py py-func docutils literal notranslate"><span class="pre">count()</span></code></a>, <a class="reference internal" href="../functions/presto/aggregate.html#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a>.
The query planner should avoid generating plans that request sorted inputs
for such aggregate functions. Some examples of aggregate functions that are
sensitive to the order of inputs include <a class="reference internal" href="../functions/presto/aggregate.html#array_agg" title="array_agg"><code class="xref py py-func docutils literal notranslate"><span class="pre">array_agg()</span></code></a> and <a class="reference internal" href="../functions/presto/aggregate.html#min_by" title="min_by"><code class="xref py py-func docutils literal notranslate"><span class="pre">min_by()</span></code></a>
(in the presence of ties).</p>
<p>Similarly, some aggregate functions produce same results on unique inputs as well
as inputs with duplicates, e.g. <a class="reference internal" href="../functions/presto/aggregate.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="../functions/presto/aggregate.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>. The query planner
should avoid generating plans that request de-duplicating inputs for such
aggregate functions.</p>
<p>Finally, note that computing measures over sorted input is only possible if
aggregation step is ‘single’. Such computations cannot be split into partial + final.</p>
<p>To illustrate the need for globalGroupingSets and groupIdColumn, we examine the following SQL</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">orderkey</span><span class="p">,</span><span class="w"> </span><span class="k">sum</span><span class="p">(</span><span class="n">total_quantity</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="k">CUBE</span><span class="w"> </span><span class="p">(</span><span class="n">orderkey</span><span class="p">);</span>
</pre></div>
</div>
<p>This is equivalent to the following SQL with GROUPING SETS</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">orderkey</span><span class="p">,</span><span class="w"> </span><span class="k">sum</span><span class="p">(</span><span class="n">total_quantity</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="k">GROUPING</span><span class="w"> </span><span class="k">SETS</span><span class="w"> </span><span class="p">((</span><span class="n">orderkey</span><span class="p">),</span><span class="w"> </span><span class="p">());</span>
</pre></div>
</div>
<p>The SQL gives sub-totals of total_quantity for each orderkey along with the global sum (from the empty grouping set).</p>
<p>The optimizer plans the above query as an Aggregation over a GroupId node.</p>
<p>Lets say the orders table has 5 rows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">orderkey</span>   <span class="n">total_quantity</span>
   <span class="mi">1</span>            <span class="mi">5</span>
   <span class="mi">2</span>            <span class="mi">6</span>
   <span class="mi">2</span>            <span class="mi">7</span>
   <span class="mi">3</span>            <span class="mi">8</span>
   <span class="mi">4</span>            <span class="mi">9</span>
</pre></div>
</div>
<p>After GroupId for the grouping sets ((orderkey), ()) the table has the following 10 rows</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">orderkey</span>   <span class="n">total_quantity</span>    <span class="n">group_id</span>
   <span class="mi">1</span>            <span class="mi">5</span>                <span class="mi">0</span>
   <span class="mi">2</span>            <span class="mi">6</span>                <span class="mi">0</span>
   <span class="mi">2</span>            <span class="mi">7</span>                <span class="mi">0</span>
   <span class="mi">3</span>            <span class="mi">8</span>                <span class="mi">0</span>
   <span class="mi">4</span>            <span class="mi">9</span>                <span class="mi">0</span>
   <span class="n">null</span>         <span class="mi">5</span>                <span class="mi">1</span>
   <span class="n">null</span>         <span class="mi">6</span>                <span class="mi">1</span>
   <span class="n">null</span>         <span class="mi">7</span>                <span class="mi">1</span>
   <span class="n">null</span>         <span class="mi">8</span>                <span class="mi">1</span>
   <span class="n">null</span>         <span class="mi">9</span>                <span class="mi">1</span>
</pre></div>
</div>
<p>A subsequent aggregation with grouping keys (orderkey, group_id) gives the sub-totals for the query</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">orderkey</span>   <span class="n">total_quantity</span>     <span class="n">group_id</span>
  <span class="mi">1</span>           <span class="mi">5</span>                  <span class="mi">0</span>
  <span class="mi">2</span>           <span class="mi">13</span>                 <span class="mi">0</span>
  <span class="mi">3</span>           <span class="mi">8</span>                  <span class="mi">0</span>
  <span class="mi">4</span>           <span class="mi">9</span>                  <span class="mi">0</span>
  <span class="n">null</span>        <span class="mi">35</span>                 <span class="mi">1</span>
</pre></div>
</div>
<p>If there were no input rows for this GROUP BY CUBE, then the expected result is a single row with the default value for the
global aggregation. For the above query that would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">orderkey</span>   <span class="n">total_quantity</span>      <span class="n">group_id</span>
  <span class="n">null</span>           <span class="n">null</span>             <span class="mi">1</span>
</pre></div>
</div>
<p>To generate this special row the AggregationNode needs the groupId for the global grouping set (1 in this case) and it
returns a single row for it with the aggregates default value.</p>
<p>Note: Presto allows multiple global grouping sets in a single SQL query.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">orderkey</span><span class="p">,</span><span class="w"> </span><span class="k">sum</span><span class="p">(</span><span class="n">total_quantity</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="k">GROUPING</span><span class="w"> </span><span class="k">SETS</span><span class="w"> </span><span class="p">((),</span><span class="w"> </span><span class="p">());</span>
</pre></div>
</div>
<p>Hence, globalGroupingSets is a vector of groupIds.</p>
</section>
<section id="expandnode">
<span id="id3"></span><h3>ExpandNode<a class="headerlink" href="#expandnode" title="Link to this heading">¶</a></h3>
<p>For each input row, generates N rows with M columns according to specified ‘projections’.
‘projections’ is an N x M matrix of expressions: a vector of N rows each having M columns.
Each expression is either a column reference or a constant. Both null and non-null constants are allowed.
‘names’ is a list of M new column names. The semantic of this operator matches Spark. Using project and unnest can be
employed to implement the expand functionality. However, the performance is suboptimal when creating an array
constructor within the Project operation.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>projections</p></td>
<td><p>A vector of N rows each having M columns. Each expression is either a column reference or a constant.</p></td>
</tr>
<tr class="row-odd"><td><p>names</p></td>
<td><p>A list of new column names.</p></td>
</tr>
</tbody>
</table>
<p>ExpandNode is typically used to compute GROUPING SETS, CUBE, ROLLUP and COUNT DISTINCT.</p>
<p>To illustrate how ExpandNode works lets examine the following SQL query:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">l_orderkey</span><span class="p">,</span><span class="w"> </span><span class="n">l_partkey</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">l_suppkey</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">lineitem</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="k">ROLLUP</span><span class="p">(</span><span class="n">l_orderkey</span><span class="p">,</span><span class="w"> </span><span class="n">l_partkey</span><span class="p">);</span>
</pre></div>
</div>
<p>In the planning phase, Spark generates an Expand operator with the following projection list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">l_suppkey</span><span class="p">,</span> <span class="n">l_orderkey</span><span class="p">,</span> <span class="n">l_partkey</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="p">[</span><span class="n">l_suppkey</span><span class="p">,</span> <span class="n">l_orderkey</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span>      <span class="mi">1</span><span class="p">],</span>
<span class="p">[</span><span class="n">l_suppkey</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span>       <span class="n">null</span><span class="p">,</span>      <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>Note: The last column serves as a special group ID, indicating the grouping set to which each row belongs. In Spark, this ID is calculated using a bitmask. If a certain column is selected, the bit value is assigned as 0; otherwise, it is assigned as 1. Therefore, the binary representation of the first row is (000), resulting in 0. The binary representation of the second row is (001), resulting in 1. The binary representation of the third row is (011), resulting in 3.</p>
<p>For example, if the input rows are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">l_suppkey</span> <span class="n">l_orderkey</span> <span class="n">l_partkey</span>
<span class="mi">93</span>        <span class="mi">1</span>          <span class="mi">673</span>
<span class="mi">75</span>        <span class="mi">2</span>          <span class="mi">674</span>
<span class="mi">38</span>        <span class="mi">3</span>          <span class="mi">22</span>
</pre></div>
</div>
<p>After the computation by the ExpandNode, each row will generate 3 rows of data. So there will be a total of 9 rows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">l_suppkey</span> <span class="n">l_orderkey</span> <span class="n">l_partkey</span> <span class="n">grouping_id_0</span>
<span class="mi">93</span>        <span class="mi">1</span>          <span class="mi">673</span>       <span class="mi">0</span>
<span class="mi">93</span>        <span class="mi">1</span>          <span class="n">null</span>      <span class="mi">1</span>
<span class="mi">93</span>        <span class="n">null</span>       <span class="n">null</span>      <span class="mi">3</span>
<span class="mi">75</span>        <span class="mi">2</span>          <span class="mi">674</span>       <span class="mi">0</span>
<span class="mi">75</span>        <span class="mi">2</span>          <span class="n">null</span>      <span class="mi">1</span>
<span class="mi">75</span>        <span class="n">null</span>       <span class="n">null</span>      <span class="mi">3</span>
<span class="mi">38</span>        <span class="mi">3</span>          <span class="mi">22</span>        <span class="mi">0</span>
<span class="mi">38</span>        <span class="mi">3</span>          <span class="n">null</span>      <span class="mi">1</span>
<span class="mi">38</span>        <span class="n">null</span>       <span class="n">null</span>      <span class="mi">3</span>
</pre></div>
</div>
<p>Aggregation operator that follows, groups these 9 rows by (l_orderkey, l_partkey, grouping_id_0) and computes count(l_suppkey):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">l_orderkey</span> <span class="n">l_partkey</span> <span class="n">count</span><span class="p">(</span><span class="n">l_suppkey</span><span class="p">)</span>
<span class="mi">1</span>          <span class="mi">673</span>       <span class="mi">1</span>
<span class="n">null</span>       <span class="n">null</span>      <span class="mi">3</span>
<span class="mi">1</span>          <span class="n">null</span>      <span class="mi">1</span>
<span class="mi">2</span>          <span class="n">null</span>      <span class="mi">1</span>
<span class="mi">2</span>          <span class="mi">674</span>       <span class="mi">1</span>
<span class="mi">3</span>          <span class="n">null</span>      <span class="mi">1</span>
<span class="mi">3</span>          <span class="mi">22</span>        <span class="mi">1</span>
</pre></div>
</div>
<p>Another example would be COUNT DISTINCT query.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">l_suppkey</span><span class="p">),</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">l_partkey</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">lineitem</span><span class="p">;</span>
</pre></div>
</div>
<p>In the planning phase, Spark generates an Expand operator with the following projection list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">l_suppkey</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span>      <span class="mi">1</span><span class="p">],</span>
<span class="p">[</span><span class="n">null</span><span class="p">,</span>      <span class="n">l_partkey</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>For example, if the input rows are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">l_suppkey</span> <span class="n">l_partkey</span>
<span class="mi">93</span>        <span class="mi">673</span>
<span class="mi">75</span>        <span class="mi">674</span>
<span class="mi">38</span>        <span class="mi">22</span>
</pre></div>
</div>
<p>After the computation by the ExpandNode, each row will generate 2 rows of data. So there will be a total of 6 rows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">l_suppkey</span> <span class="n">l_partkey</span> <span class="n">grouping_id_0</span>
<span class="mi">93</span>        <span class="n">null</span>      <span class="mi">1</span>
<span class="n">null</span>      <span class="mi">673</span>       <span class="mi">2</span>
<span class="mi">75</span>        <span class="n">null</span>      <span class="mi">1</span>
<span class="n">null</span>      <span class="mi">674</span>       <span class="mi">2</span>
<span class="mi">38</span>        <span class="n">null</span>      <span class="mi">1</span>
<span class="n">null</span>      <span class="mi">22</span>        <span class="mi">2</span>
</pre></div>
</div>
<p>Aggregation operator that follows, groups these rows by (l_suppkey, l_partkey, grouping_id_0) and produces:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">l_suppkey</span> <span class="n">l_partkey</span> <span class="n">grouping_id_0</span>
<span class="mi">93</span>        <span class="n">null</span>      <span class="mi">1</span>
<span class="mi">75</span>        <span class="n">null</span>      <span class="mi">1</span>
<span class="mi">38</span>        <span class="n">null</span>      <span class="mi">1</span>
<span class="n">null</span>      <span class="mi">673</span>       <span class="mi">2</span>
<span class="n">null</span>      <span class="mi">674</span>       <span class="mi">2</span>
<span class="n">null</span>      <span class="mi">22</span>        <span class="mi">2</span>
</pre></div>
</div>
<p>Another Aggregation operator that follows, computes global count(l_suppkey) and count(l_partkey) producing final result:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">COUNT</span><span class="p">(</span><span class="n">DISTINCT</span> <span class="n">l_suppkey</span><span class="p">)</span> <span class="n">COUNT</span><span class="p">(</span><span class="n">DISTINCT</span> <span class="n">l_partkey</span><span class="p">)</span>
<span class="mi">3</span>                         <span class="mi">3</span>
</pre></div>
</div>
</section>
<section id="groupidnode">
<span id="id4"></span><h3>GroupIdNode<a class="headerlink" href="#groupidnode" title="Link to this heading">¶</a></h3>
<p>Duplicates the input for each of the specified grouping key sets. Used to
implement aggregations over grouping sets.</p>
<p>The output consists of grouping keys, followed by aggregation inputs,
followed by the group ID column. The type of group ID column is BIGINT.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>groupingSets</p></td>
<td><p>List of grouping key sets. Keys within each set must be unique, but keys can repeat across the sets. Grouping keys are specified with their output names.</p></td>
</tr>
<tr class="row-odd"><td><p>groupingKeyInfos</p></td>
<td><p>The names and order of the grouping key columns in the output.</p></td>
</tr>
<tr class="row-even"><td><p>aggregationInputs</p></td>
<td><p>Input columns to duplicate.</p></td>
</tr>
<tr class="row-odd"><td><p>groupIdName</p></td>
<td><p>The name for the group-id column that identifies the grouping set. Zero-based integer corresponding to the position of the grouping set in the ‘groupingSets’ list.</p></td>
</tr>
</tbody>
</table>
<p>GroupIdNode is typically used to compute GROUPING SETS, CUBE and ROLLUP.</p>
<p>While usually GroupingSets do not repeat with the same grouping key column, there are some use-cases where
they might. To illustrate why GroupingSets might do so lets examine the following SQL query:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">orderkey</span><span class="p">),</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">orderkey</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">orders</span><span class="p">;</span>
</pre></div>
</div>
<p>In this query the user wants to compute global aggregates using the same column, though with
and without the DISTINCT clause. With a particular optimization strategy
<a class="reference external" href="https://www.qubole.com/blog/presto-optimizes-aggregations-over-distinct-values">optimize.mixed-distinct-aggregations</a>, Presto uses GroupIdNode to compute these.</p>
<p>First, the optimizer creates a GroupIdNode to duplicate every row assigning one copy
to group 0 and another to group 1. This is achieved using the GroupIdNode with 2 grouping sets
each using orderkey as a grouping key. In order to disambiguate the
groups the orderkey column is aliased as a grouping key for one of the
grouping sets.</p>
<p>Lets say the orders table has 5 rows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">orderkey</span>
   <span class="mi">1</span>
   <span class="mi">2</span>
   <span class="mi">2</span>
   <span class="mi">3</span>
   <span class="mi">4</span>
</pre></div>
</div>
<p>The GroupIdNode would transform this into:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">orderkey</span>   <span class="n">orderkey1</span>   <span class="n">group_id</span>
<span class="mi">1</span>             <span class="n">null</span>        <span class="mi">0</span>
<span class="mi">2</span>             <span class="n">null</span>        <span class="mi">0</span>
<span class="mi">2</span>             <span class="n">null</span>        <span class="mi">0</span>
<span class="mi">3</span>             <span class="n">null</span>        <span class="mi">0</span>
<span class="mi">4</span>             <span class="n">null</span>        <span class="mi">0</span>
<span class="n">null</span>           <span class="mi">1</span>          <span class="mi">1</span>
<span class="n">null</span>           <span class="mi">2</span>          <span class="mi">1</span>
<span class="n">null</span>           <span class="mi">2</span>          <span class="mi">1</span>
<span class="n">null</span>           <span class="mi">3</span>          <span class="mi">1</span>
<span class="n">null</span>           <span class="mi">4</span>          <span class="mi">1</span>
</pre></div>
</div>
<p>Then Presto plans an aggregation using (orderkey, group_id) and count(orderkey1).</p>
<p>This results in the following 5 rows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">orderkey</span>     <span class="n">group_id</span>     <span class="n">count</span><span class="p">(</span><span class="n">orderkey1</span><span class="p">)</span> <span class="k">as</span> <span class="n">c</span>
<span class="mi">1</span>                <span class="mi">0</span>         <span class="n">null</span>
<span class="mi">2</span>                <span class="mi">0</span>         <span class="n">null</span>
<span class="mi">3</span>                <span class="mi">0</span>         <span class="n">null</span>
<span class="mi">4</span>                <span class="mi">0</span>         <span class="n">null</span>
<span class="n">null</span>             <span class="mi">1</span>          <span class="mi">5</span>
</pre></div>
</div>
<p>Then Presto plans a second aggregation with no keys and count(orderkey), arbitrary(c).
Since both aggregations ignore nulls this correctly computes the number of
distinct orderkeys and the count of all orderkeys.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">count</span><span class="p">(</span><span class="n">orderkey</span><span class="p">)</span>     <span class="n">arbitrary</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
 <span class="mi">4</span>                     <span class="mi">5</span>
</pre></div>
</div>
</section>
<section id="hashjoinnode-and-mergejoinnode">
<h3>HashJoinNode and MergeJoinNode<a class="headerlink" href="#hashjoinnode-and-mergejoinnode" title="Link to this heading">¶</a></h3>
<p>The join operation combines two separate inputs into a single output, based on a
join expression. A common subtype of joins is an equality join where the join
expression is constrained to a list of equality (or equality + null equality)
conditions between the two inputs of the join.</p>
<p>HashJoinNode represents an implementation that starts by loading all rows from
the right side of the join into a hash table, then streams left side of the
join probing the hash table for matching rows and emitting results.</p>
<p>MergeJoinNode represents an implementation that assumes that both inputs are
sorted on the join keys and streams both join sides looking for matching rows
and emitting results.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>joinType</p></td>
<td><p>Join type: inner, left, right, full, left semi filter, left semi project, right semi filter, right semi project, anti. You can read about different join types in this <a class="reference external" href="https://dataschool.com/how-to-teach-people-sql/sql-join-types-explained-visually/">blog post</a>.</p></td>
</tr>
<tr class="row-odd"><td><p>nullAware</p></td>
<td><p>Applies to anti and semi project joins only. Indicates whether the join semantic is IN (nullAware = true) or EXISTS (nullAware = false).</p></td>
</tr>
<tr class="row-even"><td><p>useHashTableCache</p></td>
<td><p>Optional. Used only by Presto-on-Spark. When true, enables caching of the hash table built for broadcast joins so that subsequent tasks can reuse it.</p></td>
</tr>
<tr class="row-odd"><td><p>leftKeys</p></td>
<td><p>Columns from the left hand side input that are part of the equality condition. At least one must be specified.</p></td>
</tr>
<tr class="row-even"><td><p>rightKeys</p></td>
<td><p>Columns from the right hand side input that are part of the equality condition. At least one must be specified. The number and order of the rightKeys must match the number and order of the leftKeys.</p></td>
</tr>
<tr class="row-odd"><td><p>filter</p></td>
<td><p>Optional non-equality filter expression that may reference columns from both inputs.</p></td>
</tr>
<tr class="row-even"><td><p>outputType</p></td>
<td><p>A list of output columns. This is a subset of columns available in the left and right inputs of the join. The columns may appear in different order than in the input.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="nestedloopjoinnode">
<h3>NestedLoopJoinNode<a class="headerlink" href="#nestedloopjoinnode" title="Link to this heading">¶</a></h3>
<p>NestedLoopJoinNode represents an implementation that iterates through each row from
the left side of the join and, for each row, iterates through all rows from the right
side of the join, comparing them based on the join condition to find matching rows
and emitting results. Nested loop join supports non-equality joins, and emit output
rows in the same order as the probe input (for inner and left outer joins) for each
thread of execution.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>joinType</p></td>
<td><p>Join type: inner, left, right, full.</p></td>
</tr>
<tr class="row-odd"><td><p>joinCondition</p></td>
<td><p>Expression used as the join condition, may reference columns from both inputs.</p></td>
</tr>
<tr class="row-even"><td><p>outputType</p></td>
<td><p>A list of output columns. This is a subset of columns available in the left and right inputs of the join. The columns may appear in different order than in the input.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="orderbynode">
<h3>OrderByNode<a class="headerlink" href="#orderbynode" title="Link to this heading">¶</a></h3>
<p>The sort or order by operation reorders a dataset based on one or more
identified sort fields as well as a sorting order.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>sortingKeys</p></td>
<td><p>List of one of more input columns to sort by. Sorting keys must be unique.</p></td>
</tr>
<tr class="row-odd"><td><p>sortingOrders</p></td>
<td><p>Sorting order for each of the soring keys. The supported orders are: ascending nulls first, ascending nulls last, descending nulls first, descending nulls last.</p></td>
</tr>
<tr class="row-even"><td><p>isPartial</p></td>
<td><p>Boolean indicating whether the sort operation processes only a portion of the dataset.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="topnnode">
<h3>TopNNode<a class="headerlink" href="#topnnode" title="Link to this heading">¶</a></h3>
<p>The top-n operation reorders a dataset based on one or more identified sort
fields as well as a sorting order. Rather than sort the entire dataset, the
top-n will only maintain the total number of records required to ensure a
limited output. A top-n is a combination of a logical sort and logical limit
operations.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>sortingKeys</p></td>
<td><p>List of one of more input columns to sort by. Must not be empty and must not contain duplicates.</p></td>
</tr>
<tr class="row-odd"><td><p>sortingOrders</p></td>
<td><p>Sorting order for each of the soring keys. See OrderBy for the list of supported orders.</p></td>
</tr>
<tr class="row-even"><td><p>count</p></td>
<td><p>Maximum number of rows to return.</p></td>
</tr>
<tr class="row-odd"><td><p>isPartial</p></td>
<td><p>Boolean indicating whether the operation processes only a portion of the dataset.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="limitnode">
<h3>LimitNode<a class="headerlink" href="#limitnode" title="Link to this heading">¶</a></h3>
<p>The limit operation skips a specified number of input rows and then keeps up to a
specified number of rows and drops the rest.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>offset</p></td>
<td><p>Number of rows of input to skip.</p></td>
</tr>
<tr class="row-odd"><td><p>count</p></td>
<td><p>Maximum number of rows to return.</p></td>
</tr>
<tr class="row-even"><td><p>isPartial</p></td>
<td><p>Boolean indicating whether the operation processes only a portion of the dataset.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="unnestnode">
<h3>UnnestNode<a class="headerlink" href="#unnestnode" title="Link to this heading">¶</a></h3>
<p>The unnest operation expands arrays and maps into separate columns. Arrays are
expanded into a single column, and maps are expanded into two columns
(key, value). Can be used to expand multiple columns. In this case produces as
many rows as the highest cardinality array or map (the other columns are padded
with nulls). Optionally, it can include an ordinality column to indicate the row
number starting from 1, and an emptyUnnestValue column to indicate whether an
output row has empty unnest value or not. If the ordinality column is specified
along with the emptyUnnestValue column, the ordinality for the output row with
empty unnest values is set to zero. If the emptyUnnestValue column is not specified,
output rows with empty unnest values are not produced.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>replicateVariables</p></td>
<td><p>Input columns that are returned unmodified.</p></td>
</tr>
<tr class="row-odd"><td><p>unnestVariables</p></td>
<td><p>Input columns of type array or map to expand.</p></td>
</tr>
<tr class="row-even"><td><p>unnestNames</p></td>
<td><p>Names to use for expanded columns. One name per array column. Two names per map column.</p></td>
</tr>
<tr class="row-odd"><td><p>ordinalityName</p></td>
<td><p>Optional name for the ordinality column.</p></td>
</tr>
<tr class="row-even"><td><p>emptyUnnestValueName</p></td>
<td><p>Optional name for the emptyUnnestValue column.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="tablewritenode">
<span id="id5"></span><h3>TableWriteNode<a class="headerlink" href="#tablewritenode" title="Link to this heading">¶</a></h3>
<p>The table write operation consumes one output and writes it to storage via a
<a class="reference internal" href="connectors.html"><span class="doc">connector</span></a>. An example would be writing ORC or Parquet files. The table write
operation return a list of columns containing the metadata of the written
data: the number of rows written to storage, the writer context information,
the written file paths on storage and the collected column stats.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>columns</p></td>
<td><p>A list of input columns to write to storage. This may be a subset of the input columns in different order.</p></td>
</tr>
<tr class="row-odd"><td><p>columnNames</p></td>
<td><p>Column names to use when writing to storage. These can be different from the input column names.</p></td>
</tr>
<tr class="row-even"><td><p>aggregationNode</p></td>
<td><p>Optional Aggregation plan node used to collect column stats for the data written to storage.</p></td>
</tr>
<tr class="row-odd"><td><p>insertTableHandle</p></td>
<td><p>Connector-specific description of the destination table.</p></td>
</tr>
<tr class="row-even"><td><p>outputType</p></td>
<td><p>A list of output columns containing the metadata of the data written storage.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="tablewritemergenode">
<h3>TableWriteMergeNode<a class="headerlink" href="#tablewritemergenode" title="Link to this heading">¶</a></h3>
<p>The table write merge operation aggregates the metadata outputs from multiple
table write operations and returns the aggregated result.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>outputType</p></td>
<td><p>A list of output columns containing the metadata of the written data aggregated from multiple table write operations.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="partitionedoutputnode">
<h3>PartitionedOutputNode<a class="headerlink" href="#partitionedoutputnode" title="Link to this heading">¶</a></h3>
<p>The partitioned output operation redistributes data based on zero or more
distribution fields.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>kind</p></td>
<td><p>Specifies output buffer types: kPartitioned, kBroadcast and kArbitrary. For kPartitioned type, rows are partitioned and each sent to corresponding destination partition. For kBroadcast type, rows are not partitioned and sent to all the destination partitions. For kArbitrary type, rows are not partitioned and each sent to any one of the destination partitions.</p></td>
</tr>
<tr class="row-odd"><td><p>keys</p></td>
<td><p>Zero or more input fields to use for calculating a partition for each row.</p></td>
</tr>
<tr class="row-even"><td><p>numPartitions</p></td>
<td><p>Number of partitions to split the data into.</p></td>
</tr>
<tr class="row-odd"><td><p>replicateNullsAndAny</p></td>
<td><p>Boolean flag indicating whether rows with nulls in the keys should be sent to all partitions and, in case there are no such rows, whether a single arbitrarily chosen row should be sent to all partitions. Used to provide global-scope information necessary to implement anti join semantics on a single node.</p></td>
</tr>
<tr class="row-even"><td><p>partitionFunctionFactory</p></td>
<td><p>Factory to make partition functions to use when calculating partitions for input rows.</p></td>
</tr>
<tr class="row-odd"><td><p>outputType</p></td>
<td><p>A list of output columns. This is a subset of input columns possibly in a different order.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="valuesnode">
<h3>ValuesNode<a class="headerlink" href="#valuesnode" title="Link to this heading">¶</a></h3>
<p>The values operation returns specified data.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>values</p></td>
<td><p>Set of rows to return.</p></td>
</tr>
<tr class="row-odd"><td><p>parallelizable</p></td>
<td><p>If the same input should be produced by each thread (one per driver).</p></td>
</tr>
<tr class="row-even"><td><p>repeatTimes</p></td>
<td><p>How many times each vector should be produced as input.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="exchangenode">
<h3>ExchangeNode<a class="headerlink" href="#exchangenode" title="Link to this heading">¶</a></h3>
<p>A receiving operation that merges multiple streams in an arbitrary order. Input
streams are coming from remote exchange or shuffle.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>type</p></td>
<td><p>A list of columns in the input streams.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="mergeexchangenode">
<h3>MergeExchangeNode<a class="headerlink" href="#mergeexchangenode" title="Link to this heading">¶</a></h3>
<p>A receiving operation that merges multiple ordered streams to maintain
orderedness. Input streams are coming from remote exchange or shuffle.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>type</p></td>
<td><p>A list of columns in the input streams.</p></td>
</tr>
<tr class="row-odd"><td><p>sortingKeys</p></td>
<td><p>List of one of more input columns to sort by.</p></td>
</tr>
<tr class="row-even"><td><p>sortingOrders</p></td>
<td><p>Sorting order for each of the soring keys. See OrderBy for the list of supported orders.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="localmergenode">
<h3>LocalMergeNode<a class="headerlink" href="#localmergenode" title="Link to this heading">¶</a></h3>
<p>An operation that merges multiple ordered streams to maintain orderedness. Input
streams are coming from local exchange.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>sortingKeys</p></td>
<td><p>List of one of more input columns to sort by.</p></td>
</tr>
<tr class="row-odd"><td><p>sortingOrders</p></td>
<td><p>Sorting order for each of the soring keys. See OrderBy for the list of supported orders.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="localpartitionnode">
<h3>LocalPartitionNode<a class="headerlink" href="#localpartitionnode" title="Link to this heading">¶</a></h3>
<p>A local exchange operation that partitions input data into multiple streams or
combines data from multiple streams into a single stream.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Type</p></td>
<td><p>Type of the exchange: gather or repartition.</p></td>
</tr>
<tr class="row-odd"><td><p>partitionFunctionFactory</p></td>
<td><p>Factory to make partition functions to use when calculating partitions for input rows.</p></td>
</tr>
<tr class="row-even"><td><p>outputType</p></td>
<td><p>A list of output columns. This is a subset of input columns possibly in a different order.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="enforcesinglerownode">
<h3>EnforceSingleRowNode<a class="headerlink" href="#enforcesinglerownode" title="Link to this heading">¶</a></h3>
<p>The enforce single row operation checks that input contains at most one row and
returns that row unmodified. If input is empty, returns a single row with all
values set to null. If input contains more than one row raises an exception.</p>
<p>Used for queries with non-correlated sub-queries.</p>
</section>
<section id="enforcedistinctnode">
<h3>EnforceDistinctNode<a class="headerlink" href="#enforcedistinctnode" title="Link to this heading">¶</a></h3>
<p>The EnforceDistinct operator ensures that input rows have unique values for
specified key columns. It passes through all input rows unchanged, but throws
an exception with a custom error message if any duplicate key values are
detected. This is useful for validating uniqueness constraints at runtime,
such as ensuring a correlated scalar subquery returns at most one row per group.</p>
<p>When preGroupedKeys equals distinctKeys (i.e., input is clustered on the
distinct keys), the streaming implementation is used which requires only O(1)
memory. Otherwise, the hash-based implementation is used which requires O(n)
memory to track all unique key combinations seen so far.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>distinctKeys</p></td>
<td><p>List of columns that must have unique values.</p></td>
</tr>
<tr class="row-odd"><td><p>preGroupedKeys</p></td>
<td><p>Optional subset of distinctKeys that input is already clustered on. When
equal to distinctKeys, uses streaming enforcement with O(1) memory.</p></td>
</tr>
<tr class="row-even"><td><p>errorMessage</p></td>
<td><p>Error message to include in the exception when duplicates are found.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="assignuniqueidnode">
<h3>AssignUniqueIdNode<a class="headerlink" href="#assignuniqueidnode" title="Link to this heading">¶</a></h3>
<p>The assign unique id operation adds one column at the end of the input columns
with unique value per row. This unique value marks each output row to be unique
among all output rows of this operator.</p>
<p>The 64-bit unique id is built in following way:
- first 24 bits - task unique id
- next 40 bits - operator counter value</p>
<p>The task unique id is added to ensure the generated id is unique across all
the nodes executing the same query stage in a distributed query execution.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>idName</p></td>
<td><p>Column name for the generated unique id column.</p></td>
</tr>
<tr class="row-odd"><td><p>taskUniqueId</p></td>
<td><p>A 24-bit integer to uniquely identify the task id across all the nodes.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="windownode">
<span id="id6"></span><h3>WindowNode<a class="headerlink" href="#windownode" title="Link to this heading">¶</a></h3>
<p>The Window operator is used to evaluate window functions. The operator adds columns
for the window functions output at the end of the input columns.</p>
<p>The window operator groups the input data into partitions based on the values
of the partition columns. If no partition columns are specified, then all the input
rows are considered to be in the same partition.
Within each partition rows are ordered by the values of the sorting columns.
The window function is computed for each row at a time in this order.
If no sorting columns are specified then the order of the results is unspecified.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>partitionKeys</p></td>
<td><p>Partition by columns for the window functions.</p></td>
</tr>
<tr class="row-odd"><td><p>sortingKeys</p></td>
<td><p>Order by columns for the window functions.</p></td>
</tr>
<tr class="row-even"><td><p>sortingOrders</p></td>
<td><p>Sorting order for each sorting key above. The supported sort orders are asc nulls first, asc nulls last, desc nulls first and desc nulls last.</p></td>
</tr>
<tr class="row-odd"><td><p>windowColumnNames</p></td>
<td><p>Output column names for each window function invocation in windowFunctions list below.</p></td>
</tr>
<tr class="row-even"><td><p>windowFunctions</p></td>
<td><p>Window function calls with the frame clause. e.g row_number(), first_value(name) between range 10 preceding and current row. The default frame is between range unbounded preceding and current row.</p></td>
</tr>
<tr class="row-odd"><td><p>inputsSorted</p></td>
<td><p>If true, the Window operator assumes that the inputs are clustered on partition keys and sorted on sorting keys in sorting orders. In this case, the operator splits the window partition and begins processing it as soon as it receives the data. If false, the Window operator accumulates all inputs first, then sorts the data, splits the window partition based on the defined criteria, and then processes each window partition sequentially.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="rownumbernode">
<h3>RowNumberNode<a class="headerlink" href="#rownumbernode" title="Link to this heading">¶</a></h3>
<p>An optimized version of a WindowNode with a single row_number function, an
optional limit, and no sorting.</p>
<p>Partitions the input using specified partitioning keys and assigns row numbers
within each partition starting from 1. The operator runs in streaming mode. For
each batch of input it computes and returns the results before accepting the
next batch of input.</p>
<p>This operator accumulates state: a hash table mapping partition keys to total
number of rows seen in this partition so far. Returning the row numbers as
a column in the output is optional. This operator supports spilling.</p>
<p>This operator is equivalent to a WindowNode followed by
FilterNode(row_number &lt;= limit), but it uses less memory and CPU and makes
results available before seeing all input.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>partitionKeys</p></td>
<td><p>Partition by columns.</p></td>
</tr>
<tr class="row-odd"><td><p>rowNumberColumnName</p></td>
<td><p>Optional output column name for the row numbers. If specified, the generated row numbers are returned as an output column appearing after all input columns.</p></td>
</tr>
<tr class="row-even"><td><p>limit</p></td>
<td><p>Optional per-partition limit. If specified, the number of rows produced by this node will not exceed this value for any given partition. Extra rows will be dropped.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="topnrownumbernode">
<h3>TopNRowNumberNode<a class="headerlink" href="#topnrownumbernode" title="Link to this heading">¶</a></h3>
<p>An optimized version of a WindowNode with a single row_number, rank or dense_rank function and a
limit over sorted partitions.</p>
<p>Partitions the input using specified partitioning keys and maintains up to
a ‘limit’ number of top rows for each partition. After receiving all input,
assigns row numbers within each partition starting from 1.</p>
<p>This operator accumulates state: a hash table mapping partition keys to a list
of top ‘limit’ rows within that partition.  Returning the row number or rank as
a column in the output is optional. This operator supports spilling as well.</p>
<p>This operator is logically equivalent to a WindowNode followed by
FilterNode(rank/row_number &lt;= limit), but it uses less memory and CPU.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>partitionKeys</p></td>
<td><p>Partition by columns for the window functions. May be empty.</p></td>
</tr>
<tr class="row-odd"><td><p>sortingKeys</p></td>
<td><p>Order by columns for the window functions. Must not be empty and must not overlap with ‘partitionKeys’.</p></td>
</tr>
<tr class="row-even"><td><p>sortingOrders</p></td>
<td><p>Sorting order for each sorting key above. The supported sort orders are asc nulls first, asc nulls last, desc nulls first and desc nulls last.</p></td>
</tr>
<tr class="row-odd"><td><p>rowNumberColumnName</p></td>
<td><p>Optional output column name for the row numbers. If specified, the generated row numbers are returned as an output column appearing after all input columns.</p></td>
</tr>
<tr class="row-even"><td><p>limit</p></td>
<td><p>Per-partition limit. If specified, the number of rows produced by this node will not exceed this value for any given partition. Extra rows will be dropped.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="markdistinctnode">
<h3>MarkDistinctNode<a class="headerlink" href="#markdistinctnode" title="Link to this heading">¶</a></h3>
<p>The MarkDistinct operator is used to produce aggregate mask columns for aggregations over distinct values, e.g. agg(DISTINCT a).
Mask is a boolean column set to true for a subset of input rows that collectively represent a set of unique values of ‘distinctKeys’.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>markerName</p></td>
<td><p>Name of the output mask column.</p></td>
</tr>
<tr class="row-odd"><td><p>distinctKeys</p></td>
<td><p>Names of grouping keys.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="mixedunionnode">
<h3>MixedUnionNode<a class="headerlink" href="#mixedunionnode" title="Link to this heading">¶</a></h3>
<p>The mixed union operation combines data from multiple input sources concurrently,
producing a single output stream that interleaves rows from all sources. It does
not enforce a sort order but does attempt to mix input sources according to
specified ratios; after exhaustion it continues with remaining sources.</p>
<p>All sources must produce the same output schema.</p>
<p>MixedUnion runs single-threaded. Each source runs on its own pipeline and feeds
data into the MixedUnion operator via a merge source queue.</p>
<p>This operator performs a UNION ALL. It does not deduplicate rows.</p>
<table class="docutils align-left">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>sources</p></td>
<td><p>Two or more input plan nodes. All sources must have the same output type.</p></td>
</tr>
<tr class="row-odd"><td><p>batchSizesPerSource</p></td>
<td><p>Optional list of per-source batch sizes that controls how many rows are
taken from each source when mixing. If not specified or set to zero for a
source, a default batch size is used.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h2>
<section id="join">
<h3>Join<a class="headerlink" href="#join" title="Link to this heading">¶</a></h3>
<p>A query plan with a join includes a HashJoinNode. Such a plan is translated into
two pipelines: build and probe. Build pipeline is processing input from the
build side of the join and uses HashBuild operator to build a hash table. Probe
pipeline is processing input from the probe side of the join, probes the hash
table and produces rows that match join criteria. Build pipeline provides the
hash table to the probe pipeline via a special mechanism called JoinBridge.
JoinBridge is like a future, where HashBuild operator completes the future with
a HashTable as a result and HashProbe operator receives the HashTable when
future completes.</p>
<p>Each pipeline can run with different levels of parallelism. In the example
below, the probe pipeline runs on 2 threads, while the build pipeline runs on 3
threads. When the build pipeline runs multi-threaded, each pipeline processes a
portion of the build-side input. The last pipeline to finish processing is
responsible for combining the hash tables from the other pipelines and
publishing the final table to the JoinBridge. When the probe pipeline for the
right outer join runs multi-threaded, the last pipeline to finish processing is
responsible for emitting rows from the build side that didn’t match the join
condition.</p>
<a class="reference internal image-reference" href="../_images/join.png"><img alt="../_images/join.png" class="align-center" src="../_images/join.png" style="width: 400px;" />
</a>
</section>
<section id="local-exchange">
<h3>Local Exchange<a class="headerlink" href="#local-exchange" title="Link to this heading">¶</a></h3>
<p>A local exchange operation has multiple uses. It is used to change the
parallelism of the data processing from multi-threaded to single-threaded or
vice versa. For example, local exchange can be used in a sort operation where
partial sort runs multi-threaded and then results are merged on a single
thread. Local exchange operation is also used to combine results of multiple
pipelines. For example to combine multiple inputs of the UNION or UNION ALL.</p>
<p>Here are some examples.</p>
<p>N-to-1 local exchange that could be used for combining partially sorted results
for final merge sort.</p>
<a class="reference internal image-reference" href="../_images/local-exchange-N-to-1.png"><img alt="../_images/local-exchange-N-to-1.png" class="align-center" src="../_images/local-exchange-N-to-1.png" style="width: 400px;" />
</a>
<p>1-to-N local exchange to increase parallelism after an operation that must run
single-threaded.</p>
<a class="reference internal image-reference" href="../_images/local-exchange-1-to-N.png"><img alt="../_images/local-exchange-1-to-N.png" class="align-center" src="../_images/local-exchange-1-to-N.png" style="width: 400px;" />
</a>
<p>Local exchange used to combine data from multiple pipelines, e.g. for UNION
ALL.</p>
<a class="reference internal image-reference" href="../_images/local-exchange.png"><img alt="../_images/local-exchange.png" class="align-center" src="../_images/local-exchange.png" style="width: 400px;" />
</a>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Plan Nodes and Operators</a><ul>
<li><a class="reference internal" href="#plan-nodes">Plan Nodes</a><ul>
<li><a class="reference internal" href="#tablescannode">TableScanNode</a></li>
<li><a class="reference internal" href="#arrowstreamnode">ArrowStreamNode</a></li>
<li><a class="reference internal" href="#filternode">FilterNode</a></li>
<li><a class="reference internal" href="#projectnode">ProjectNode</a></li>
<li><a class="reference internal" href="#aggregationnode">AggregationNode</a></li>
<li><a class="reference internal" href="#expandnode">ExpandNode</a></li>
<li><a class="reference internal" href="#groupidnode">GroupIdNode</a></li>
<li><a class="reference internal" href="#hashjoinnode-and-mergejoinnode">HashJoinNode and MergeJoinNode</a></li>
<li><a class="reference internal" href="#nestedloopjoinnode">NestedLoopJoinNode</a></li>
<li><a class="reference internal" href="#orderbynode">OrderByNode</a></li>
<li><a class="reference internal" href="#topnnode">TopNNode</a></li>
<li><a class="reference internal" href="#limitnode">LimitNode</a></li>
<li><a class="reference internal" href="#unnestnode">UnnestNode</a></li>
<li><a class="reference internal" href="#tablewritenode">TableWriteNode</a></li>
<li><a class="reference internal" href="#tablewritemergenode">TableWriteMergeNode</a></li>
<li><a class="reference internal" href="#partitionedoutputnode">PartitionedOutputNode</a></li>
<li><a class="reference internal" href="#valuesnode">ValuesNode</a></li>
<li><a class="reference internal" href="#exchangenode">ExchangeNode</a></li>
<li><a class="reference internal" href="#mergeexchangenode">MergeExchangeNode</a></li>
<li><a class="reference internal" href="#localmergenode">LocalMergeNode</a></li>
<li><a class="reference internal" href="#localpartitionnode">LocalPartitionNode</a></li>
<li><a class="reference internal" href="#enforcesinglerownode">EnforceSingleRowNode</a></li>
<li><a class="reference internal" href="#enforcedistinctnode">EnforceDistinctNode</a></li>
<li><a class="reference internal" href="#assignuniqueidnode">AssignUniqueIdNode</a></li>
<li><a class="reference internal" href="#windownode">WindowNode</a></li>
<li><a class="reference internal" href="#rownumbernode">RowNumberNode</a></li>
<li><a class="reference internal" href="#topnrownumbernode">TopNRowNumberNode</a></li>
<li><a class="reference internal" href="#markdistinctnode">MarkDistinctNode</a></li>
<li><a class="reference internal" href="#mixedunionnode">MixedUnionNode</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#join">Join</a></li>
<li><a class="reference internal" href="#local-exchange">Local Exchange</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="anti-join.html"
                          title="previous chapter">Anti joins</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="task.html"
                          title="next chapter">What’s in the Task?</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/develop/operators.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="task.html" title="What’s in the Task?"
             >next</a> |</li>
        <li class="right" >
          <a href="anti-join.html" title="Anti joins"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Velox  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../develop.html" >Developer Guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Plan Nodes and Operators</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright TBD.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.7.
    </div>
  </body>
</html>