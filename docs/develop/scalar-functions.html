<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>How to add a scalar function? &#8212; Velox  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/nature.css?v=601dbdee" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="How to add an aggregate function?" href="aggregate-functions.html" />
    <link rel="prev" title="Vectors" href="vectors.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="aggregate-functions.html" title="How to add an aggregate function?"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="vectors.html" title="Vectors"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Velox  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../develop.html" accesskey="U">Developer Guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">How to add a scalar function?</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="how-to-add-a-scalar-function">
<h1>How to add a scalar function?<a class="headerlink" href="#how-to-add-a-scalar-function" title="Link to this heading">¶</a></h1>
<section id="simple-functions">
<h2>Simple Functions<a class="headerlink" href="#simple-functions" title="Link to this heading">¶</a></h2>
<p>This document describes the main concepts, features, and examples of the simple
function API in Velox. For more real-world API usage examples, check
<strong>velox/example/SimpleFunctions.cpp</strong>.</p>
<p>A simple scalar function, e.g. a <a class="reference internal" href="../functions/presto/math.html"><span class="doc">mathematical function</span></a>,
can be added by wrapping a C++ function in a templated class. For example, a
ceil function can be implemented as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TExecParams</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">CeilFunction</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">FOLLY_ALWAYS_INLINE</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">call</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>All simple function classes need to be templated, and provide a “call” method
(or one of the variations described below). The top-level template parameter
provides the type system adapter, which allows developers to use non-primitive
types such as strings, arrays, maps, and struct (check below for examples).
Although the top-level template parameter is not used for functions operating
on primitive types, such as the one in the example above, it still needs to be
specified.</p>
<p>The call method itself can also be templated or overloaded to allow the
function to be called on different input types, e.g. float and double. Note
that template instantiation will only happen during function registration,
described in the “Registration” section below.</p>
<p>Please avoid using the obsolete VELOX_UDF_BEGIN/VELOX_UDF_END macros.</p>
<p>The “call” function (or one of its variations) may return (a) void indicating
the function never returns null values, or (b) boolean indicating whether
the result of the computation is null. True means the result is not null;
false means the result is null. If “ceil(0)” were to return null, the function
above could be re-written as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TExecParams</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">NullableCeilFunction</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">FOLLY_ALWAYS_INLINE</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">call</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The argument list must start with an output parameter “result” followed by the
function arguments. The “result” argument must be a reference. Function
arguments must be const references. The C++ types of the function arguments and
the result argument must match <a class="reference internal" href="types.html"><span class="doc">Velox types</span></a>.
Since the result argument must be a reference, some of the types listed below
have a different result argument type:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Velox Type</p></th>
<th class="head"><p>C++ Argument Type</p></th>
<th class="head"><p>C++ Result Type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>VARCHAR</p></td>
<td><p>StringView</p></td>
<td><p>out_type&lt;Varchar&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>VARBINARY</p></td>
<td><p>StringView</p></td>
<td><p>out_type&lt;Varbinary&gt;</p></td>
</tr>
<tr class="row-even"><td><p>ARRAY</p></td>
<td><p>arg_type&lt;Array&lt;E&gt;&gt;</p></td>
<td><p>out_type&lt;Array&lt;E&gt;&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>MAP</p></td>
<td><p>arg_type&lt;Map&lt;K,V&gt;&gt;</p></td>
<td><p>out_type&lt;Map&lt;K, V&gt;&gt;</p></td>
</tr>
<tr class="row-even"><td><p>ROW</p></td>
<td><p>arg_type&lt;Row&lt;T1, T2, T3,…&gt;&gt;</p></td>
<td><p>out_type&lt;Row&lt;T1, T2, T3,…&gt;&gt;</p></td>
</tr>
</tbody>
</table>
<p>arg_type and out_type templates are defined by using the
VELOX_DEFINE_FUNCTION_TYPES(TExecParams) macro in the class definition. These
types provide interfaces similar to std::string, std::vector, std::unordered_map
and std::tuple. The underlying implementations are optimized to read and write
from and to the columnar representation without extra copying. More explanaiton
and the APIs of the arg_type and out_type for string and complex types can be
found in <a class="reference internal" href="view-and-writer-types.html"><span class="doc">View and Writer Types</span></a>.</p>
<p>Note: Do not pay too much attention to complex type mappings at the moment.
They are included here for completeness.</p>
<section id="null-behavior">
<h3>Null Behavior<a class="headerlink" href="#null-behavior" title="Link to this heading">¶</a></h3>
<p>Most functions have default null behavior, e.g. a null value in any of the
arguments produces a null result. The expression evaluation engine
automatically produces nulls for such inputs, eliding a call to the actual
function. If a given function has a different behavior for null inputs, it
must define a “callNullable” function instead of a “call” function. Here is
an artificial example of a ceil function that returns 0 for null input:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TExecParams</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">CeilFunction</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">FOLLY_ALWAYS_INLINE</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">callNullable</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Return 0 if input is null.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Notice that callNullable function takes arguments as raw pointers and not
references to allow for specifying null values. callNullable() can also return
void to indicate that the function does not produce null values.</p>
<section id="null-free-fast-path">
<h4>Null-Free Fast Path<a class="headerlink" href="#null-free-fast-path" title="Link to this heading">¶</a></h4>
<p>A “callNullFree” function may be implemented in place of or along side “call”
and/or “callNullable” functions. When only the “callNullFree” function is
implemented, evaluation of the function will be skipped and null will
automatically be produced if any of the input arguments are null (like deafult
null behavior) or if any of the input arguments are of a complex type and
contain null anywhere in their value, e.g. an array that has a null element.
If “callNullFree” is implemented alongside “call” and/or “callNullable”, an
O(N * D) check is applied to the batch to see if any of the input arguments
may be or contain null, where N is the number of input arguments and D is the
depth of nesting in complex types. Only if it can definitively be determined
that there are no nulls will “callNullFree” be invoked.  In this case,
“callNullFree” can act as a fast path by avoiding any per row null checks.</p>
<p>Here is an example of an array_min function that returns the minimum value in
an array:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TExecParams</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ArrayMinFunction</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VELOX_DEFINE_FUNCTION_TYPES</span><span class="p">(</span><span class="n">TExecParams</span><span class="p">);</span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TInput</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">FOLLY_ALWAYS_INLINE</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">callNullFree</span><span class="p">(</span>
<span class="w">      </span><span class="n">TInput</span><span class="o">&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">null_free_arg_type</span><span class="o">&lt;</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">TInput</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INT32_MAX</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Notice that we can access the elements of “array” without checking their
nullity in “callNullFree”. Also notice that we wrap the input type in the
null_free_arg_type&lt;…&gt; template instead of the arg_type&lt;…&gt; template. This is
required as the input types for complex types are of a different type in
“callNullFree” functions that do not wrap values in an std::optional-like
interface upon access.</p>
</section>
</section>
<section id="determinism">
<h3>Determinism<a class="headerlink" href="#determinism" title="Link to this heading">¶</a></h3>
<p>By default simple functions are assumed to be deterministic, e.g. given the
same inputs they always produce the same results. If this is not the case,
the function must define a static constexpr bool is_deterministic member:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_deterministic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
</pre></div>
</div>
<p>An example of such function is rand():</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TExecParams</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">RandFunction</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_deterministic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">  </span><span class="n">FOLLY_ALWAYS_INLINE</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">call</span><span class="p">(</span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">folly</span><span class="o">::</span><span class="n">Random</span><span class="o">::</span><span class="n">randDouble01</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="all-ascii-fast-path">
<h3>All-ASCII Fast Path<a class="headerlink" href="#all-ascii-fast-path" title="Link to this heading">¶</a></h3>
<p>Functions that process string inputs must work correctly for UTF-8 inputs.
However, these functions often can be implemented more efficiently if input is
known to contain only ASCII characters. Such functions can provide a “call”
method to process UTF-8 strings and a “callAscii” method to process ASCII-only
strings. The engine will check the input strings and invoke “callAscii” method
if input is all ASCII or “call” if input may contain multi-byte characters.</p>
<p>In addition, most functions that take string inputs and produce a string output
have so-called default ASCII behavior, e.g. all-ASCII input guarantees
all-ASCII output. If that’s the case, the function can indicate so by defining
the is_default_ascii_behavior member variable and initializing it to true. The
engine will automatically mark the result strings as all-ASCII. When these
strings are passed as input to some other function, the engine won’t need to
scan the strings to determine whether they are ASCII or not.</p>
<p>Here is an example of a trim function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TExecParams</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">TrimFunction</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VELOX_DEFINE_FUNCTION_TYPES</span><span class="p">(</span><span class="n">TExecParams</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// ASCII input always produces ASCII result.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_default_ascii_behavior</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Properly handles multi-byte characters.</span>
<span class="w">  </span><span class="n">FOLLY_ALWAYS_INLINE</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">call</span><span class="p">(</span>
<span class="w">      </span><span class="n">out_type</span><span class="o">&lt;</span><span class="n">Varchar</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">,</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">Varchar</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">stringImpl</span><span class="o">::</span><span class="n">trimUnicodeWhiteSpace</span><span class="o">&lt;</span><span class="n">leftTrim</span><span class="p">,</span><span class="w"> </span><span class="n">rightTrim</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Assumes input is all ASCII.</span>
<span class="w">  </span><span class="n">FOLLY_ALWAYS_INLINE</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">callAscii</span><span class="p">(</span>
<span class="w">      </span><span class="n">out_type</span><span class="o">&lt;</span><span class="n">Varchar</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">,</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">Varchar</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">stringImpl</span><span class="o">::</span><span class="n">trimAsciiWhiteSpace</span><span class="o">&lt;</span><span class="n">leftTrim</span><span class="p">,</span><span class="w"> </span><span class="n">rightTrim</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="zero-copy-string-result">
<h3>Zero-copy String Result<a class="headerlink" href="#zero-copy-string-result" title="Link to this heading">¶</a></h3>
<p>Functions like <a class="reference internal" href="../functions/presto/string.html#substr" title="substr"><code class="xref py py-func docutils literal notranslate"><span class="pre">substr()</span></code></a> and <a class="reference internal" href="../functions/presto/string.html#trim" title="trim"><code class="xref py py-func docutils literal notranslate"><span class="pre">trim()</span></code></a> can produce zero-copy results by
referencing input strings. To do that they must define a reuse_strings_from_arg
member variable and initialize it to the index of the argument whose strings
are being re-used in the result. This will allow the engine to add a reference
to input string buffers to the result vector and ensure that these buffers will
not go away prematurely. The output types can be scalar strings (varchar and
varbinaries), but also complex types containing strings, such as arrays, maps,
and rows.</p>
<p>The setNoCopy method of the out_type template can be used to set the result
to a string in the input argument without copying. The setEmpty method
can be used to set the result to an empty string.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Results refer to strings in the first argument.</span>
<span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">reuse_strings_from_arg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>Here is an example of a zero-copy function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TExecParams</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">TrimFunction</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VELOX_DEFINE_FUNCTION_TYPES</span><span class="p">(</span><span class="n">TExecParams</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Results refer to strings in the first argument.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">reuse_strings_from_arg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="n">FOLLY_ALWAYS_INLINE</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">call</span><span class="p">(</span>
<span class="w">      </span><span class="n">out_type</span><span class="o">&lt;</span><span class="n">Varchar</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">,</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">Varchar</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">result</span><span class="p">.</span><span class="n">setEmpty</span><span class="p">();</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">setNoCopy</span><span class="p">(</span><span class="n">stringImpl</span><span class="o">::</span><span class="n">trimUnicodeWhiteSpace</span><span class="p">(</span><span class="n">input</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="access-to-session-properties-and-constant-inputs">
<h3>Access to Session Properties and Constant Inputs<a class="headerlink" href="#access-to-session-properties-and-constant-inputs" title="Link to this heading">¶</a></h3>
<p>Some functions require access to session properties such as session’s timezone.
Some examples are the <a class="reference internal" href="../functions/presto/datetime.html#day" title="day"><code class="xref py py-func docutils literal notranslate"><span class="pre">day()</span></code></a>, <a class="reference internal" href="../functions/presto/datetime.html#hour" title="hour"><code class="xref py py-func docutils literal notranslate"><span class="pre">hour()</span></code></a>, and <a class="reference internal" href="../functions/presto/datetime.html#minute" title="minute"><code class="xref py py-func docutils literal notranslate"><span class="pre">minute()</span></code></a> Presto
functions. Other functions could benefit from pre-processing some of the
constant inputs, e.g. compile regular expression patterns or parse date and
time units. To get access to session properties and constant inputs the
function must define an initialize method which receives a constant reference
to QueryConfig and a list of constant pointers for each of the input arguments.
Constant inputs will have their values specified. Inputs which are not constant
will be passed as nullptr’s. The signature of the initialize method is similar
to that of callNullable method with an additional first parameter const
core::QueryConfig&amp;. The engine calls the initialize method once per query and
thread of execution.</p>
<p>Here is an example of an hour function extracting time zone from the session
properties and using it when processing inputs.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TExecParams</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">HourFunction</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VELOX_DEFINE_FUNCTION_TYPES</span><span class="p">(</span><span class="n">TExecParams</span><span class="p">);</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">date</span><span class="o">::</span><span class="n">time_zone</span><span class="o">*</span><span class="w"> </span><span class="n">timeZone_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="w">  </span><span class="n">FOLLY_ALWAYS_INLINE</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">initialize</span><span class="p">(</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">core</span><span class="o">::</span><span class="n">QueryConfig</span><span class="o">&amp;</span><span class="w"> </span><span class="n">config</span><span class="p">,</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">Timestamp</span><span class="o">&gt;*</span><span class="w"> </span><span class="cm">/*timestamp*/</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">timeZone_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getTimeZoneFromConfig</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">FOLLY_ALWAYS_INLINE</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">call</span><span class="p">(</span>
<span class="w">      </span><span class="kt">int64_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">,</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">Timestamp</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">timestamp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">seconds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getSeconds</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span><span class="w"> </span><span class="n">timeZone_</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">tm</span><span class="w"> </span><span class="n">dateTime</span><span class="p">;</span>
<span class="w">    </span><span class="n">gmtime_r</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="kt">time_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">seconds</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dateTime</span><span class="p">);</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dateTime</span><span class="p">.</span><span class="n">tm_hour</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here is another example of the <a class="reference internal" href="../functions/presto/datetime.html#date_trunc" title="date_trunc"><code class="xref py py-func docutils literal notranslate"><span class="pre">date_trunc()</span></code></a> function parsing the constant
unit argument during initialize and re-using parsed value when processing
individual rows.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TExecParams</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">DateTruncFunction</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VELOX_DEFINE_FUNCTION_TYPES</span><span class="p">(</span><span class="n">TExecParams</span><span class="p">);</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">date</span><span class="o">::</span><span class="n">time_zone</span><span class="o">*</span><span class="w"> </span><span class="n">timeZone_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">DateTimeUnit</span><span class="o">&gt;</span><span class="w"> </span><span class="n">unit_</span><span class="p">;</span>

<span class="w">  </span><span class="n">FOLLY_ALWAYS_INLINE</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">initialize</span><span class="p">(</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">core</span><span class="o">::</span><span class="n">QueryConfig</span><span class="o">&amp;</span><span class="w"> </span><span class="n">config</span><span class="p">,</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">Varchar</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">unitString</span><span class="p">,</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">Timestamp</span><span class="o">&gt;*</span><span class="w"> </span><span class="cm">/*timestamp*/</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">timeZone_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getTimeZoneFromConfig</span><span class="p">(</span><span class="n">config</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unitString</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">unit_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fromDateTimeUnitString</span><span class="p">(</span><span class="o">*</span><span class="n">unitString</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">FOLLY_ALWAYS_INLINE</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">call</span><span class="p">(</span>
<span class="w">      </span><span class="n">out_type</span><span class="o">&lt;</span><span class="n">Timestamp</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">,</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">Varchar</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">unitString</span><span class="p">,</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">Timestamp</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">timestamp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">unit</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">unit_</span><span class="p">.</span><span class="n">has_value</span><span class="p">()</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">unit_</span><span class="p">.</span><span class="n">value</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fromDateTimeUnitString</span><span class="p">(</span><span class="n">unitString</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span><span class="o">&lt;</span><span class="n">use</span><span class="w"> </span><span class="n">unit</span><span class="w"> </span><span class="k">enum</span><span class="o">&gt;</span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If the <code class="xref py py-func docutils literal notranslate"><span class="pre">initialize()</span></code> method throws, the exception will be captured and
reported as output for every single active row. If there are no active rows,
the exception will not be raised.</p>
</section>
<section id="registration">
<h3>Registration<a class="headerlink" href="#registration" title="Link to this heading">¶</a></h3>
<p>Use registerFunction template to register simple functions.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="o">&gt;</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Func</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TReturn</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">TArgs</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">registerFunction</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">aliases</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{},</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">returnType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
</pre></div>
</div>
<p>The first template parameter is the class name, the next template parameter is
the return type, the remaining template parameters are argument types. Aliases
parameter allows developers to specify multiple names for the same function,
but each function registration needs to provide at least one name. The “ceil”
function defined above can be registered using the following function call:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">registerFunction</span><span class="o">&lt;</span><span class="n">CeilFunction</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="p">({</span><span class="s">&quot;ceil&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ceiling&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, we register the CeilFunction function that takes a double and returns a
double. If we want to allow the ceil function to be called on float inputs,
we need to call registerFunction again:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">registerFunction</span><span class="o">&lt;</span><span class="n">CeilFunction</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="p">({</span><span class="s">&quot;ceil&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ceiling&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>We need to call registerFunction for each signature we want to support.</p>
</section>
<section id="codegen">
<h3>Codegen<a class="headerlink" href="#codegen" title="Link to this heading">¶</a></h3>
<p>To allow the function to be used in the codegen, extract the “kernel” of the
function into a header file and call that from the “call” or “callNullable”.
Here is an example with ceil function.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;velox/functions/prestosql/ArithmeticImpl.h&quot;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TExecParams</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">CeilFunction</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">FOLLY_ALWAYS_INLINE</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">call</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ceil</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>velox/functions/prestosql/ArithmeticImpl.h:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">ceil</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">results</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Make sure the header files that define the “kernels” are free of dependencies
as much as possible to allow for faster compilation in codegen.</p>
</section>
<section id="variadic-arguments">
<h3>Variadic Arguments<a class="headerlink" href="#variadic-arguments" title="Link to this heading">¶</a></h3>
<p>The last argument to a simple function may be marked “Variadic”. This means
invocations of this function may include 0..N arguments of that type at the end
of the call.  While not a true type in Velox, “Variadic” can be thought of as a
syntactic type, and behaves somewhat similarly to Array.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>C++ Argument Type</p></th>
<th class="head"><p>C++ Actual Argument Type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>arg_type&lt;Variadic&lt;E&gt;&gt;</p></td>
<td><p>NullableVariadicView&lt;E&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>null_free_arg_type&lt;Variadic&lt;E&gt;&gt;</p></td>
<td><p>NullFreeVariadicView&lt;E&gt;</p></td>
</tr>
</tbody>
</table>
<p>Like the NullableArrayView and NullFreeArrayView, VariadicViews has a similar interface to
<em>const std::vector&lt;std::optional&lt;V&gt;&gt;</em>.</p>
<p>NullableVariadicView, and NullFreeVariadicView, supports the following:</p>
<ul class="simple">
<li><p>size_t size() : return the number of arguments that were passed as part of the “Variadic” type in the function invocation.</p></li>
<li><p>operator[](size_t index) : access the value of the argument at index. It returns either null_free_arg_type&lt;E&gt; or OptionalAccessor&lt;E&gt;.</p></li>
<li><p>VariadicView&lt;T&gt;::Iterator begin() : iterator to the first argument.</p></li>
<li><p>VariadicView&lt;T&gt;::Iterator end() : iterator indicating end of iteration.</p></li>
<li><p>bool mayHaveNulls() : a check on the nullity of the arugments (note this takes time proportional to the number of arguments). When it returns false, there are definitely no nulls, a true does not guarantee null existence.</p></li>
<li><p>VariadicView&lt;T&gt;::SkipNullsContainer SkipNulls() : return an iterable container that provides direct access to each argument with a non-null value.</p></li>
</ul>
<p>The code below shows an example of a function that concatenates a variable number of strings:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">VariadicArgsReaderFunction</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">VELOX_DEFINE_FUNCTION_TYPES</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="w">  </span><span class="n">FOLLY_ALWAYS_INLINE</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">call</span><span class="p">(</span>
<span class="w">      </span><span class="n">out_type</span><span class="o">&lt;</span><span class="n">Varchar</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">Variadic</span><span class="o">&lt;</span><span class="n">Varchar</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">inputs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inputs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">output</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>
<section id="vector-functions">
<h2>Vector Functions<a class="headerlink" href="#vector-functions" title="Link to this heading">¶</a></h2>
<p>Simple functions process a single row and produce a single value as a result.
Vector functions process a batch or rows and produce a vector of results.
Some of the defining features of these functions are:</p>
<ul class="simple">
<li><p>take vectors as inputs and produce vectors as a result;</p></li>
<li><p>have access to vector encodings and metadata;</p></li>
<li><p>can be defined for generic input types, e.g. generic arrays, maps and structs;</p></li>
<li><p>allow for implementing <a class="reference internal" href="lambda-functions.html"><span class="doc">lambda functions</span></a>;</p></li>
</ul>
<p>Vector function interface allows for many optimizations that are not available
to simple functions. These optimizations often leverage different vector
encodings and columnar representations of the vectors. Here are some
examples,</p>
<ul class="simple">
<li><p><a class="reference internal" href="../functions/presto/map.html#map_keys" title="map_keys"><code class="xref py py-func docutils literal notranslate"><span class="pre">map_keys()</span></code></a> function takes advantage of the ArrayVector representation and simply returns the inner “keys” vector without doing any computation. Similarly, <a class="reference internal" href="../functions/presto/map.html#map_values" title="map_values"><code class="xref py py-func docutils literal notranslate"><span class="pre">map_values()</span></code></a> function simply returns the inner “values” vector.</p></li>
<li><p><a class="reference internal" href="../functions/presto/map.html#map_entries" title="map_entries"><code class="xref py py-func docutils literal notranslate"><span class="pre">map_entries()</span></code></a> function takes the pieces of the input vector - “nulls”, “sizes” and “offsets”  buffers and “keys” and “values” vectors - and simply repackages them in the form of a RowVector.</p></li>
<li><p><a class="reference internal" href="../functions/presto/array.html#cardinality" title="cardinality"><code class="xref py py-func docutils literal notranslate"><span class="pre">cardinality()</span></code></a> function takes advantage of the ArrayVector and MapVector representations and simply returns the “sizes” buffer of the input vector.</p></li>
<li><p><a class="reference internal" href="../functions/presto/comparison.html#is_null" title="is_null"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_null()</span></code></a> function copies the “nulls” buffer of the input vector, flips the bits in bulk and returns the result.</p></li>
<li><p><a class="reference internal" href="../functions/presto/array.html#element_at" title="element_at"><code class="xref py py-func docutils literal notranslate"><span class="pre">element_at()</span></code></a> function and subscript operator for arrays and maps use dictionary encoding to represent a subset of the input “elements” or “values” vector without copying.</p></li>
</ul>
<p>To define a vector function, make a subclass of exec::VectorFunction and
implement the “apply” method.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">apply</span><span class="p">(</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">SelectivityVector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VectorPtr</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">,</span>
<span class="w">      </span><span class="n">Expr</span><span class="o">*</span><span class="w"> </span><span class="n">caller</span><span class="p">,</span>
<span class="w">      </span><span class="n">EvalCtx</span><span class="o">&amp;</span><span class="w"> </span><span class="n">context</span><span class="p">,</span>
<span class="w">      </span><span class="n">VectorPtr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
</pre></div>
</div>
<section id="input-rows">
<h3>Input rows<a class="headerlink" href="#input-rows" title="Link to this heading">¶</a></h3>
<p>The “rows” parameter specifies the set of rows in the incoming batch to
process. This set may not include all the rows. By default, a vector function
is assumed to have the default null behavior, e.g. null in any input produces
a null result. In this case, the expression evaluation engine will exclude
rows with nulls from the “rows” specified in the call to “apply”. If a
function has a different behavior for null inputs, it must override the
isDefaultNullBehavior method to return false.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">isDefaultNullBehavior</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this case, the “rows” parameter will include rows with null inputs and the
function will need to handle these. By default, the function can assume that
all inputs are not null for all “rows”.</p>
<p>When evaluating a function as part of a conditional expression, e.g. AND, OR,
IF, SWITCH, the set of “rows” represents a subset of the rows that need
evaluating. Consider some examples.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">AND</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">7</span>
</pre></div>
</div>
<p>Here, a &gt; 5 is evaluated on all rows where “a” is not null, but b &gt; 7 is
evaluated on rows where b is not null and a &gt; 5 is true.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">IF</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, a + 5 is evaluated on rows where a is not null and condition is true,
while b - 3 is evaluated on rows where b is not null and condition is not
true.</p>
<p>In some cases, the values outside of “rows” may be undefined, uninitialized or
contain garbage. This would be the case if an earlier filter operation
produced dictionary-encoded vectors with indices pointing to a subset of the
rows which passed the filter. When evaluating f(g(a)), where a = Dict
(a0), function “g” is evaluated on a subset of rows in “a0” and may produce a
result where only that subset of rows is populated. Then, function “f” is
evaluated on the same subset of rows in the result of “g”. The input to “f”
will have values outside of “rows” undefined, uninitialized or contain
garbage.</p>
<p>Note that SelectivityVector::applyToSelected method can be used to loop over
the specified rows in a way that’s rather similar to a standard for loop.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rows</span><span class="p">.</span><span class="n">applyToSelected</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// row is the 0-based row number</span>
<span class="w">    </span><span class="c1">// .... process the row</span>
<span class="p">});</span>
</pre></div>
</div>
</section>
<section id="input-vectors">
<h3>Input vectors<a class="headerlink" href="#input-vectors" title="Link to this heading">¶</a></h3>
<p>The “args” parameter is an std::vector of Velox vectors containing the values
of the function arguments. These vectors are not necessarily flat and may be
dictionary or constant encoded. However, a deterministic function that takes
a single argument and has default null behavior is guaranteed to receive its
only input as a flat or constant vector. By default, a function is assumed to
be deterministic. If that’s not the case, the function must override
isDeterministic method to return false.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">isDeterministic</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="dictionary-encoding.html#decoded-vector"><span class="std std-ref">DecodedVector</span></a> can be used to get a flat vector-like interface to any
vector. A helper class exec::DecodedArgs can be used to decode multiple arguments.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">exec</span><span class="o">::</span><span class="n">DecodedArgs</span><span class="w"> </span><span class="nf">decodedArgs</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">);</span>

<span class="k">auto</span><span class="w"> </span><span class="n">firstArg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decodedArgs</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">secondArg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decodedArgs</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="result-vector">
<h3>Result vector<a class="headerlink" href="#result-vector" title="Link to this heading">¶</a></h3>
<p>The “result” parameter is a raw pointer to VectorPtr, which is a
std::shared_ptr to BaseVector. It can be null, may point to a scratch vector
that is maybe reusable or a partially populated vector whose contents must be
preserved.</p>
<p>A partially populated vector is specified when evaluating the “else” branch of
an IF. In this case, the results of the “then” branch must be preserved. This
can be easily achieved by following one of the two patterns.</p>
<p>Calculate the result for all or just the specified rows into a new vector,
then use EvalCtx::moveOrCopyResult method to either std::move the vector
into “result” or copy individual rows into partially populated “result”.</p>
<p>Here is an example of using moveOrCopyResult to implement map_keys function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">apply</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SelectivityVector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VectorPtr</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">,</span>
<span class="w">    </span><span class="n">exec</span><span class="o">::</span><span class="n">Expr</span><span class="o">*</span><span class="w"> </span><span class="cm">/* caller */</span><span class="p">,</span>
<span class="w">    </span><span class="n">exec</span><span class="o">::</span><span class="n">EvalCtx</span><span class="o">&amp;</span><span class="w"> </span><span class="n">context</span><span class="p">,</span>
<span class="w">    </span><span class="n">VectorPtr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">mapVector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">as</span><span class="o">&lt;</span><span class="n">MapVector</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">mapKeys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mapVector</span><span class="o">-&gt;</span><span class="n">mapKeys</span><span class="p">();</span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">localResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">ArrayVector</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">      </span><span class="n">context</span><span class="p">.</span><span class="n">pool</span><span class="p">(),</span>
<span class="w">      </span><span class="n">ARRAY</span><span class="p">(</span><span class="n">mapKeys</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()),</span>
<span class="w">      </span><span class="n">mapVector</span><span class="o">-&gt;</span><span class="n">nulls</span><span class="p">(),</span>
<span class="w">      </span><span class="n">rows</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
<span class="w">      </span><span class="n">mapVector</span><span class="o">-&gt;</span><span class="n">offsets</span><span class="p">(),</span>
<span class="w">      </span><span class="n">mapVector</span><span class="o">-&gt;</span><span class="n">sizes</span><span class="p">(),</span>
<span class="w">      </span><span class="n">mapKeys</span><span class="p">,</span>
<span class="w">      </span><span class="n">mapVector</span><span class="o">-&gt;</span><span class="n">getNullCount</span><span class="p">());</span>

<span class="w">  </span><span class="n">context</span><span class="p">.</span><span class="n">moveOrCopyResult</span><span class="p">(</span><span class="n">localResult</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Use BaseVector::ensureWritable method to initialize “result” to a flat
uniquely-referenced vector while preserving values in rows not specified
in “rows”. Then, calculate and fill in the “rows” in “result”.
BaseVector::ensureWritable creates a new vector if “result” is null. If
result is not null, but not-flat or not singly-referenced,
BaseVector::ensureWritable creates a new vector and copies non-”rows” values
from “result” into the newly created vector. If “result” is not null and
flat, BaseVector::ensureWritable checks the inner buffers and copies these if
they are not singly referenced. BaseVector::ensureWritable also recursively
calls itself on inner vectors (elements vector for the array, keys and values
for map, fields for struct) to make sure the vector is “writable” all the way
through.</p>
<p>Here is an example of using BaseVector::ensureWritable to implement
cardinality function for maps:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">apply</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SelectivityVector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VectorPtr</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">,</span>
<span class="w">    </span><span class="n">exec</span><span class="o">::</span><span class="n">Expr</span><span class="o">*</span><span class="w"> </span><span class="cm">/* caller */</span><span class="p">,</span>
<span class="w">    </span><span class="n">exec</span><span class="o">::</span><span class="n">EvalCtx</span><span class="o">&amp;</span><span class="w"> </span><span class="n">context</span><span class="p">,</span>
<span class="w">    </span><span class="n">VectorPtr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="n">BaseVector</span><span class="o">::</span><span class="n">ensureWritable</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">BIGINT</span><span class="p">(),</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="n">pool</span><span class="p">(),</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="w">  </span><span class="n">BufferPtr</span><span class="w"> </span><span class="n">resultValues</span><span class="w"> </span><span class="o">=</span>
<span class="w">       </span><span class="n">result</span><span class="o">-&gt;</span><span class="n">as</span><span class="o">&lt;</span><span class="n">FlatVector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mutableValues</span><span class="p">(</span><span class="n">rows</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">rawResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resultValues</span><span class="o">-&gt;</span><span class="n">asMutable</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">mapVector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">as</span><span class="o">&lt;</span><span class="n">MapVector</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">rawSizes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mapVector</span><span class="o">-&gt;</span><span class="n">rawSizes</span><span class="p">();</span>

<span class="w">  </span><span class="n">rows</span><span class="p">.</span><span class="n">applyToSelected</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">vector_size_t</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rawResult</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rawSizes</span><span class="p">[</span><span class="n">row</span><span class="p">];</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="simple-implementation">
<h3>Simple implementation<a class="headerlink" href="#simple-implementation" title="Link to this heading">¶</a></h3>
<p>Vector function interface is very flexible and allows for many interesting
optimizations. It may also feel very complicated. Let’s see how we can use
DecodedVector and BaseVector::ensureWritable to implement the “power(a, b)”
function as a vector function in a way that is not much more complicated than
the simple function. To clarify, it is best to implement the “power” function
as a simple function. I’m using it here for illustration purposes only.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Initialize flat results vector.</span>
<span class="n">BaseVector</span><span class="o">::</span><span class="n">ensureWritable</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">DOUBLE</span><span class="p">(),</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="n">pool</span><span class="p">(),</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">rawResults</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="o">-&gt;</span><span class="n">as</span><span class="o">&lt;</span><span class="n">FlatVector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mutableRawValues</span><span class="p">();</span>

<span class="c1">// Decode the arguments.</span>
<span class="n">DecodedArgs</span><span class="w"> </span><span class="nf">decodedArgs</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decodedArgs</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decodedArgs</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// Loop over rows and calculate the results.</span>
<span class="n">rows</span><span class="p">.</span><span class="n">applyToSelected</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">rawResults</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">valueAt</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">row</span><span class="p">),</span><span class="w"> </span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">valueAt</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">row</span><span class="p">));</span>
<span class="p">});</span>
</pre></div>
</div>
<p>You may want to optimize for the case when both base and exponent being flat
and eliminate the overhead of calling DecodedVector::valueAt template.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">isIdentityMapping</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">isIdentityMapping</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">baseValues</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">base</span><span class="o">-&gt;</span><span class="n">values</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">expValues</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">values</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="n">rows</span><span class="p">.</span><span class="n">applyToSelected</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rawResults</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">baseValues</span><span class="p">[</span><span class="n">row</span><span class="p">],</span><span class="w"> </span><span class="n">expValues</span><span class="p">[</span><span class="n">row</span><span class="p">]);</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">rows</span><span class="p">.</span><span class="n">applyToSelected</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rawResults</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">valueAt</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">row</span><span class="p">),</span><span class="w"> </span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">valueAt</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">row</span><span class="p">));</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You may decide to further optimize for the case of flat base and constant
exponent.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">isIdentityMapping</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">isIdentityMapping</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">baseValues</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">base</span><span class="o">-&gt;</span><span class="n">values</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">expValues</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">values</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="n">rows</span><span class="p">.</span><span class="n">applyToSelected</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rawResults</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">baseValues</span><span class="p">[</span><span class="n">row</span><span class="p">],</span><span class="w"> </span><span class="n">expValues</span><span class="p">[</span><span class="n">row</span><span class="p">]);</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">isIdentityMapping</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">isConstantMapping</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">baseValues</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">base</span><span class="o">-&gt;</span><span class="n">values</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">expValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">valueAt</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">rows</span><span class="p">.</span><span class="n">applyToSelected</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rawResults</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">baseValues</span><span class="p">[</span><span class="n">row</span><span class="p">],</span><span class="w"> </span><span class="n">expValue</span><span class="p">);</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">rows</span><span class="p">.</span><span class="n">applyToSelected</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rawResults</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">valueAt</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">row</span><span class="p">),</span><span class="w"> </span><span class="n">exp</span><span class="o">-&gt;</span><span class="n">valueAt</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">row</span><span class="p">));</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Hopefully, you can see now that additional complexity in the implementation
comes only from introducing optimization paths. Developers need to decide
whether that complexity is justified on a case by case basis.</p>
</section>
<section id="try-expression-support">
<h3>TRY expression support<a class="headerlink" href="#try-expression-support" title="Link to this heading">¶</a></h3>
<p>A built-in TRY expression evaluates input expression and handles certain types
of errors by returning NULL. It is used for the cases where it is preferable
that queries produce NULL or default values instead of failing when corrupt
or invalid data is encountered. To specify default values, the TRY expression
can be used in conjunction with the COALESCE function.</p>
<p>The implementation of the TRY expression relies on the VectorFunction
implementation to call EvalCtx::setError(row, exception) instead of throwing
exceptions directly.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">setError</span><span class="p">(</span><span class="n">vector_size_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">exceptionPtr</span><span class="p">);</span>
</pre></div>
</div>
<p>A typical pattern would be to loop over rows, apply a function wrapped in a
try-catch and call context-&gt;setError(row, std::current_exception()); from the
catch block.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rows</span><span class="p">.</span><span class="n">applyToSelected</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ... calculate and store the result for the row</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">context</span><span class="p">.</span><span class="n">setError</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>There is an EvalCtx::applyToSelectedNoThrow convenience method that can be used
instead of the explicit try-catch block above:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">context</span><span class="p">.</span><span class="n">applyToSelectedNoThrow</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ... calculate and store the result for the row</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Simple functions are compatible with the TRY expression by default. The framework
wraps the “call” and “callNullable” methods in a try-catch and reports errors
using context.setError.</p>
</section>
<section id="id1">
<h3>Registration<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h3>
<p>Use exec::registerVectorFunction to register a stateless vector function.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">registerVectorFunction</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">,</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FunctionSignaturePtr</span><span class="o">&gt;</span><span class="w"> </span><span class="n">signatures</span><span class="p">,</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">VectorFunction</span><span class="o">&gt;</span><span class="w"> </span><span class="n">func</span><span class="p">,</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">overwrite</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span>
</pre></div>
</div>
<p>exec::registerVectorFunction takes a name, a list of supported signatures
and unique_ptr to an instance of the function. An optional “overwrite” flag
specifies whether to overwrite a function if a function with the specified
name already exists.</p>
<p>Use exec::registerStatefulVectorFunction to register a stateful vector
function.</p>
<p>Note: A vector function will be given precedence over a simple function during resolution time.
This is because in certain cases it makes sense to write an optimized vector function, and thus more precedence is given
to a vector function over an equivalent simple function.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">registerStatefulVectorFunction</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">,</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FunctionSignaturePtr</span><span class="o">&gt;</span><span class="w"> </span><span class="n">signatures</span><span class="p">,</span>
<span class="w">    </span><span class="n">VectorFunctionFactory</span><span class="w"> </span><span class="n">factory</span><span class="p">,</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">overwrite</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span>
</pre></div>
</div>
<p>exec::registerStatefulVectorFunction takes a name, a list of supported
signatures and a factory function that can be used to create an instance of
the vector function. Expression evaluation engine uses a factory function to
create a new instance of the vector function for each thread of execution. In
a single-threaded execution, a single instance of the function is used to
process all batches of data. In a multi-threaded execution, each thread makes
a separate instance of the function.</p>
<p>Factory function is called with a function name, types and optionally constant
values for the arguments. For example, regular expressions functions are
often called with constant regular expressions. A stateful vector function
can compile the regular expression once (per thread of execution) and reuse
the compiled expression for multiple batches of data. Similarly, an IN
expression used with a constant IN-list can create a hash set of the values
once and reuse it for all the batches of data.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Represents arguments for stateful vector functions. Stores element type, and</span>
<span class="c1">// the constant value (if supplied).</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">VectorFunctionArg</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">TypePtr</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">VectorPtr</span><span class="w"> </span><span class="n">constantValue</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">using</span><span class="w"> </span><span class="n">VectorFunctionFactory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">VectorFunction</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VectorFunctionArg</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inputArgs</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="function-signature">
<span id="id2"></span><h3>Function signature<a class="headerlink" href="#function-signature" title="Link to this heading">¶</a></h3>
<p>It is recommended to use FunctionSignatureBuilder to create FunctionSignature
instances. FunctionSignatureBuilder and FunctionSignature support Java-like
generics, variable number of arguments and lambdas. Here are some examples.</p>
<p>The length function takes a single argument of type varchar and returns a
bigint:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// varchar -&gt; bigint</span>
<span class="n">exec</span><span class="o">::</span><span class="n">FunctionSignatureBuilder</span><span class="p">()</span>
<span class="w">  </span><span class="p">.</span><span class="n">returnType</span><span class="p">(</span><span class="s">&quot;bigint&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">argumentType</span><span class="p">(</span><span class="s">&quot;varchar&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">build</span><span class="p">()</span>
</pre></div>
</div>
<p>The substr function takes a varchar and two integers for start and length. To
specify types of multiple arguments, call argumentType() method for each
argument in order.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// varchar, integer, integer -&gt; bigint</span>
<span class="n">exec</span><span class="o">::</span><span class="n">FunctionSignatureBuilder</span><span class="p">()</span>
<span class="w">  </span><span class="p">.</span><span class="n">returnType</span><span class="p">(</span><span class="s">&quot;varchar&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">argumentType</span><span class="p">(</span><span class="s">&quot;varchar&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">argumentType</span><span class="p">(</span><span class="s">&quot;integer&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">argumentType</span><span class="p">(</span><span class="s">&quot;integer&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">build</span><span class="p">()</span>
</pre></div>
</div>
<p>The concat function takes an arbitrary number of varchar inputs and returns a
varchar. FunctionSignatureBuilder allows specifying that the last augment may
appear zero or more times by calling variableArity() method.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// varchar... -&gt; varchar</span>
<span class="n">exec</span><span class="o">::</span><span class="n">FunctionSignatureBuilder</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">returnType</span><span class="p">(</span><span class="s">&quot;varchar&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">argumentType</span><span class="p">(</span><span class="s">&quot;varchar&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">variableArity</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">build</span><span class="p">()</span>
</pre></div>
</div>
<p>The map_keys function takes any map and returns an array of map keys.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// map(K,V) -&gt; array(K)</span>
<span class="n">exec</span><span class="o">::</span><span class="n">FunctionSignatureBuilder</span><span class="p">()</span>
<span class="w">  </span><span class="p">.</span><span class="n">knownTypeVariable</span><span class="p">(</span><span class="s">&quot;K&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">typeVariable</span><span class="p">(</span><span class="s">&quot;V&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">returnType</span><span class="p">(</span><span class="s">&quot;array(K)&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">argumentType</span><span class="p">(</span><span class="s">&quot;map(K,V)&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">build</span><span class="p">()</span>
</pre></div>
</div>
<p>The transform function takes an array and a lambda, applies the lambda to each
element of the array and returns a new array of the results.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// array(T), function(T, U) -&gt; array(U)</span>
<span class="n">exec</span><span class="o">::</span><span class="n">FunctionSignatureBuilder</span><span class="p">()</span>
<span class="w">  </span><span class="p">.</span><span class="n">typeVariable</span><span class="p">(</span><span class="s">&quot;T&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">typeVariable</span><span class="p">(</span><span class="s">&quot;U&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">returnType</span><span class="p">(</span><span class="s">&quot;array(U)&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">argumentType</span><span class="p">(</span><span class="s">&quot;array(T)&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">argumentType</span><span class="p">(</span><span class="s">&quot;function(T, U)&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">build</span><span class="p">();</span>
</pre></div>
</div>
<p>The signature of a function that handles DECIMAL types can additionally take
variables and constraints to represent the precision and scale values.
The constraints are evaluated using a type calculator built from Flex and Bison
tools. The decimal arithmetic addition function has the following signature:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// decimal, decimal -&gt; decimal</span>
<span class="n">exec</span><span class="o">::</span><span class="n">FunctionSignatureBuilder</span><span class="p">()</span>
<span class="w">  </span><span class="p">.</span><span class="n">returnType</span><span class="p">(</span><span class="s">&quot;DECIMAL(r_precision, r_scale)&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">argumentType</span><span class="p">(</span><span class="s">&quot;DECIMAL(a_precision, a_scale)&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">argumentType</span><span class="p">(</span><span class="s">&quot;DECIMAL(b_precision, b_scale)&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">variableConstraint</span><span class="p">(</span>
<span class="w">      </span><span class="s">&quot;r_precision&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="s">&quot;min(38, max(a_precision - a_scale, b_precision - b_scale) + max(a_scale, b_scale) + 1)&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">variableConstraint</span><span class="p">(</span><span class="s">&quot;r_scale&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;max(a_scale, b_scale)&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">.</span><span class="n">build</span><span class="p">();</span>
</pre></div>
</div>
<p>The type names used in FunctionSignatureBuilder can be either lowercase
standard types, a special type “any”, or the ones defined by calling
typeVariable() method. “any” type can be used to specify a printf-like
function which takes any number of arguments of any possibly non-matching
types.</p>
</section>
</section>
<section id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="Link to this heading">¶</a></h2>
<p>Add a test using FunctionBaseTest from
velox/functions/prestosql/tests/utils/FunctionBaseTest.h as a base class. Name your test
and the .cpp file &lt;function-name&gt;Test, e.g. CardinalityTest in
CardinalityTest.cpp or IsNullTest in IsNullTest.cpp.</p>
<p>FunctionBaseTest has many helper methods for generating test vectors. It also
provides an evaluate() method that takes a SQL expression and input data,
evaluates the expression and returns the result vector. SQL expression is
parsed using DuckDB and type resolution logic is leveraging the function
signatures specified during registration. assertEqualVectors() method takes
two vectors, expected and actual, and asserts that they represent the same
values. The encodings of the vectors may not be the same.</p>
<p>Here is an example of a test for vector function “contains”:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TEST_F</span><span class="p">(</span><span class="n">ArrayContainsTest</span><span class="p">,</span><span class="w"> </span><span class="n">integerWithNulls</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">arrayVector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">makeNullableArrayVector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">      </span><span class="p">{{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">},</span>
<span class="w">       </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">},</span>
<span class="w">       </span><span class="p">{},</span>
<span class="w">       </span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">},</span>
<span class="w">       </span><span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">},</span>
<span class="w">       </span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">}});</span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">testContains</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">search</span><span class="p">,</span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">expected</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">evaluate</span><span class="o">&lt;</span><span class="n">SimpleVector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span><span class="p">(</span>
<span class="w">        </span><span class="s">&quot;contains(c0, c1)&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="n">makeRowVector</span><span class="p">({</span>
<span class="w">            </span><span class="n">arrayVector</span><span class="p">,</span>
<span class="w">            </span><span class="n">makeConstant</span><span class="p">(</span><span class="n">search</span><span class="p">,</span><span class="w"> </span><span class="n">arrayVector</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()),</span>
<span class="w">        </span><span class="p">}));</span>

<span class="w">    </span><span class="n">assertEqualVectors</span><span class="p">(</span><span class="n">makeNullableFlatVector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expected</span><span class="p">),</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="n">testContains</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">});</span>
<span class="w">  </span><span class="n">testContains</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">});</span>
<span class="w">  </span><span class="n">testContains</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">});</span>
<span class="w">  </span><span class="n">testContains</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">});</span>
<span class="w">  </span><span class="n">testContains</span><span class="p">(</span><span class="mi">-2</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Tests for simple functions could benefit from using the evaluateOnce
() template which takes SQL expression and scalar values for the inputs,
evaluates the expression on a vector of length 1 and returns the scalar
result. Here is an example of a test for simple function “sqrt”:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TEST_F</span><span class="p">(</span><span class="n">ArithmeticTest</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">kDoubleMax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">kNan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">quiet_NaN</span><span class="p">();</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">sqrt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">evaluateOnce</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;sqrt(c0)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">-1.0</span><span class="p">),</span><span class="w"> </span><span class="n">IsNan</span><span class="p">());</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">9</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_FLOAT_EQ</span><span class="p">(</span><span class="mf">1.34078e+154</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">kDoubleMax</span><span class="p">).</span><span class="n">value_or</span><span class="p">(</span><span class="mi">-1</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kNan</span><span class="p">),</span><span class="w"> </span><span class="n">IsNan</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="function-names">
<h2>Function names<a class="headerlink" href="#function-names" title="Link to this heading">¶</a></h2>
<p>For both simple and vector functions, their names are case insensitive. Function
names are converted to lower case automatically when the functions are
registered and when they are resolved for a given expression.</p>
<p>The following names are reserved for special forms and cannot be used as function
names:</p>
<ul class="simple">
<li><p>and</p></li>
<li><p>or</p></li>
<li><p>cast</p></li>
<li><p>if</p></li>
<li><p>switch</p></li>
<li><p>coalesce</p></li>
<li><p>try</p></li>
<li><p>row_constructor</p></li>
</ul>
</section>
<section id="function-resolution-order">
<h2>Function Resolution order<a class="headerlink" href="#function-resolution-order" title="Link to this heading">¶</a></h2>
<p>Vector functions have precedence over simple functions during function resolution. If a function <cite>foo</cite> has
multiple implementations, then the order in which function resolution will proceed is as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Vector Function</p></li>
<li><p>Simple Function which are generic free and variadic free</p></li>
<li><p>Simple Function has variadic but generic free</p></li>
<li><p>Simple Function has generic but no variadic of generic</p></li>
<li><p>Simple function has variadic of generic</p></li>
</ol>
</div></blockquote>
<p>The available function with lowest rank is picked during function resolution.
If there is more than one function with the same lowest rank, we count the number of concrete types in the signature
and return the signature with highest concrete types count. (a concrete type is any type other than variadic or generic).</p>
<p>For example: consider the two signatures bellow which are both of type 4.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">call</span><span class="p">(</span><span class="kt">bool</span><span class="o">&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Any</span><span class="o">&amp;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Variadic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span><span class="w">    </span><span class="c1">// concrete types = 2</span>
<span class="kt">void</span><span class="w"> </span><span class="n">call</span><span class="p">(</span><span class="kt">bool</span><span class="o">&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Any</span><span class="o">&amp;</span><span class="w"> </span><span class="p">,</span><span class="k">const</span><span class="w"> </span><span class="n">Any</span><span class="o">&amp;</span><span class="p">)</span><span class="w">               </span><span class="c1">// concrete types = 1</span>
</pre></div>
</div>
<p>When both of them are valid for a given input, the first one will be picked  since it has more concrete types.
When number of concrete types are the same, the call is ambiguous, and it’s undefined which function is called.</p>
</section>
<section id="benchmarking">
<h2>Benchmarking<a class="headerlink" href="#benchmarking" title="Link to this heading">¶</a></h2>
<p>Add a benchmark using folly::Benchmark framework and FunctionBenchmarkBase
from velox/functions/lib/benchmarks/FunctionBenchmarkBase.h as a base class.
Benchmarks are a great way to check if an optimization is working, evaluate
how much benefit it brings and decide whether it is worth the additional
complexity.</p>
</section>
<section id="documenting">
<h2>Documenting<a class="headerlink" href="#documenting" title="Link to this heading">¶</a></h2>
<p>If a function implements Presto semantics, document it by adding an entry to
one of the <cite>*.rst</cite> files in velox/docs/functions. Each file documents a set of
related functions. E.g. math.rst contains all of the mathematical functions,
while array.rst file contains all of the array functions. Within a file,
functions are listed in alphabetical order.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">How to add a scalar function?</a><ul>
<li><a class="reference internal" href="#simple-functions">Simple Functions</a><ul>
<li><a class="reference internal" href="#null-behavior">Null Behavior</a><ul>
<li><a class="reference internal" href="#null-free-fast-path">Null-Free Fast Path</a></li>
</ul>
</li>
<li><a class="reference internal" href="#determinism">Determinism</a></li>
<li><a class="reference internal" href="#all-ascii-fast-path">All-ASCII Fast Path</a></li>
<li><a class="reference internal" href="#zero-copy-string-result">Zero-copy String Result</a></li>
<li><a class="reference internal" href="#access-to-session-properties-and-constant-inputs">Access to Session Properties and Constant Inputs</a></li>
<li><a class="reference internal" href="#registration">Registration</a></li>
<li><a class="reference internal" href="#codegen">Codegen</a></li>
<li><a class="reference internal" href="#variadic-arguments">Variadic Arguments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vector-functions">Vector Functions</a><ul>
<li><a class="reference internal" href="#input-rows">Input rows</a></li>
<li><a class="reference internal" href="#input-vectors">Input vectors</a></li>
<li><a class="reference internal" href="#result-vector">Result vector</a></li>
<li><a class="reference internal" href="#simple-implementation">Simple implementation</a></li>
<li><a class="reference internal" href="#try-expression-support">TRY expression support</a></li>
<li><a class="reference internal" href="#id1">Registration</a></li>
<li><a class="reference internal" href="#function-signature">Function signature</a></li>
</ul>
</li>
<li><a class="reference internal" href="#testing">Testing</a></li>
<li><a class="reference internal" href="#function-names">Function names</a></li>
<li><a class="reference internal" href="#function-resolution-order">Function Resolution order</a></li>
<li><a class="reference internal" href="#benchmarking">Benchmarking</a></li>
<li><a class="reference internal" href="#documenting">Documenting</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="vectors.html"
                          title="previous chapter">Vectors</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="aggregate-functions.html"
                          title="next chapter">How to add an aggregate function?</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/develop/scalar-functions.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="aggregate-functions.html" title="How to add an aggregate function?"
             >next</a> |</li>
        <li class="right" >
          <a href="vectors.html" title="Vectors"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Velox  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../develop.html" >Developer Guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">How to add a scalar function?</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright TBD.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>