<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Runtime Metrics &#8212; Velox  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../_static/nature.css?v=0f882399" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Runtime Stats" href="stats.html" />
    <link rel="prev" title="Monitoring" href="../monitoring.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="stats.html" title="Runtime Stats"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../monitoring.html" title="Monitoring"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Velox  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../monitoring.html" accesskey="U">Monitoring</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Runtime Metrics</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="runtime-metrics">
<h1>Runtime Metrics<a class="headerlink" href="#runtime-metrics" title="Link to this heading">¶</a></h1>
<p>Runtime metrics are used to collect the metrics of important velox runtime events
for monitoring purpose. The collected metrics can provide insights into the
continuous availability and performance analysis of a Velox runtime system. For
instance, the collected data can help automatically generate alerts at an
outage. Velox provides a framework to collect the metrics which consists of
three steps:</p>
<p><strong>Define</strong>: define the name and type for the metric through DEFINE_METRIC,
DEFINE_HISTOGRAM_METRIC, DEFINE_QUANTILE_STAT, and DEFINE_DYNAMIC_QUANTILE_STAT
macros. DEFINE_HISTOGRAM_METRIC is used for histogram metric type,
DEFINE_QUANTILE_STAT for quantile metrics, DEFINE_DYNAMIC_QUANTILE_STAT for
dynamic quantile metrics, and DEFINE_METRIC is used for the other types (see
metric type definition below). BaseStatsReporter provides methods for metric
definition. Register metrics during startup using registerVeloxMetrics() API.</p>
<p><strong>Record</strong>: record the metric data point using RECORD_METRIC_VALUE,
RECORD_HISTOGRAM_METRIC_VALUE, RECORD_QUANTILE_STAT_VALUE, and
RECORD_DYNAMIC_QUANTILE_STAT_VALUE macros when the corresponding event happens.
BaseStatsReporter provides methods for metric recording.</p>
<p><strong>Export</strong>: aggregates the collected data points based on the defined metrics,
and periodically exports to the backend monitoring service, such as ODS used by
Meta, Apache projects <a class="reference external" href="https://opencensus.io/">OpenCensus</a>  and <a class="reference external" href="https://prometheus.io/">Prometheus</a> provided by OSS. A derived
implementation of BaseStatsReporter is required to integrate with a specific
monitoring service. The metric aggregation granularity and export interval are
also configured based on the actual used monitoring service.</p>
<p>Velox supports seven metric types:</p>
<p><strong>Count</strong>: tracks the count of events, such as the number of query failures.</p>
<p><strong>Sum</strong>: tracks the sum of event data point values, such as sum of query scan
read bytes.</p>
<p><strong>Avg</strong>: tracks the average of event data point values, such as average of query
execution time.</p>
<p><strong>Rate</strong>: tracks the sum of event data point values per second, such as the
number of shuffle requests per second.</p>
<p><strong>Histogram</strong>: tracks the distribution of event data point values, such as query
execution time distribution. The histogram metric divides the entire data range
into a series of adjacent equal-sized intervals or buckets, and then count how
many data values fall into each bucket. DEFINE_HISTOGRAM_METRIC specifies the data
range by min/max values, and the number of buckets. Any collected data value
less than min is counted in min bucket, and any one larger than max is counted
in max bucket. It also allows to specify the value percentiles to report for
monitoring. This allows BaseStatsReporter and the backend monitoring service to
optimize the aggregated data storage.</p>
<p><strong>Quantile</strong>: tracks quantile statistics (percentiles) of event data point values
over configurable sliding time windows, such as P50, P95, and P99 latencies over
the last 60 seconds. Unlike histograms which use fixed buckets, quantile metrics
dynamically calculate percentiles from the actual data distribution.
DEFINE_QUANTILE_STAT specifies the stat types to export (e.g., AVG, COUNT, SUM),
the percentiles to track (as values between 0.0 and 1.0), and the sliding window
periods in seconds. This provides more accurate percentile calculations compared
to histogram approximations, especially for metrics with varying distributions.</p>
<p><strong>Dynamic Quantile</strong>: extends quantile metrics to support dynamic key patterns
with runtime substitution using format placeholders (e.g., “latency.{}.{}” where
placeholders are replaced with actual values like database names or endpoint names).
DEFINE_DYNAMIC_QUANTILE_STAT registers a pattern template, and
RECORD_DYNAMIC_QUANTILE_STAT_VALUE substitutes the placeholders to create specific
metric instances. This enables efficient tracking of quantile metrics across
multiple dimensions without pre-registering every possible combination.</p>
<section id="task-execution">
<h2>Task Execution<a class="headerlink" href="#task-execution" title="Link to this heading">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 40.0%" />
<col style="width: 10.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Metric Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>driver_yield_count</p></td>
<td><p>Count</p></td>
<td><p>The number of times that a driver has yielded from the thread when it
hits the per-driver cpu time slice limit if enforced.</p></td>
</tr>
<tr class="row-odd"><td><p>driver_queue_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of driver queue latency in range of [0, 10s] with
20 buckets. It is configured to report the latency at P50, P90, P99,
and P100 percentiles.</p></td>
</tr>
<tr class="row-even"><td><p>driver_exec_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of driver execution time in range of [0, 30s] with
30 buckets. It is configured to report the latency at P50, P90, P99,
and P100 percentiles.</p></td>
</tr>
<tr class="row-odd"><td><p>task_batch_process_time_ms</p></td>
<td><p>Average</p></td>
<td><p>Tracks the averaged task batch processing time. This only applies for
sequential task execution mode.</p></td>
</tr>
<tr class="row-even"><td><p>task_barrier_process_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>Tracks task barrier execution time in range of [0, 30s] with 30 buckets
and each bucket with time window of 1s. We report P50, P90, P99, and P100.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="memory-management">
<h2>Memory Management<a class="headerlink" href="#memory-management" title="Link to this heading">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 40.0%" />
<col style="width: 10.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Metric Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>cache_shrink_count</p></td>
<td><p>Count</p></td>
<td><p>The number of times that in-memory data cache has been shrunk under
memory pressure.</p></td>
</tr>
<tr class="row-odd"><td><p>cache_shrink_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of cache shrink latency in range of [0, 100s] with 10
buckets. It is configured to report the latency at P50, P90, P99, and
P100 percentiles.</p></td>
</tr>
<tr class="row-even"><td><p>op_memory_reclaim_count</p></td>
<td><p>Count</p></td>
<td><p>The count of operator memory reclaims.</p></td>
</tr>
<tr class="row-odd"><td><p>op_memory_reclaim_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of operator memory reclaim execution time in range of
[0, 600s] with 20 buckets. It is configured to report latency at P50, P90,
P99, and P100 percentiles.</p></td>
</tr>
<tr class="row-even"><td><p>op_memory_reclaim_bytes</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of operator reclaimed bytes in range of [0, 4GB] with 64 buckets
and reports P50, P90, P99, and P100.</p></td>
</tr>
<tr class="row-odd"><td><p>query_memory_reclaim_count</p></td>
<td><p>Count</p></td>
<td><p>The count of query memory reclaims.</p></td>
</tr>
<tr class="row-even"><td><p>query_memory_reclaim_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of query memory reclaim execution time in range of [0, 600s]
with 20 buckets. It is configured to report latency at P50, P90, P99, and
P100 percentiles.</p></td>
</tr>
<tr class="row-odd"><td><p>query_memory_reclaim_bytes</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of query reclaimed bytes in range of [0, 4GB] with 64 buckets
and reports P50, P90, P99, and P100.</p></td>
</tr>
<tr class="row-even"><td><p>task_memory_reclaim_count</p></td>
<td><p>Count</p></td>
<td><p>The count of task memory reclaims.</p></td>
</tr>
<tr class="row-odd"><td><p>task_memory_reclaim_wait_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of task memory reclaim wait time in range of [0, 60s]
with 60 buckets. It is configured to report latency at P50, P90, P99,
and P100 percentiles.</p></td>
</tr>
<tr class="row-even"><td><p>task_memory_reclaim_exec_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of task memory execution time in range of [0, 240s]
with 60 buckets. It is configured to report latency at P50, P90, P99,
and P100 percentiles.</p></td>
</tr>
<tr class="row-odd"><td><p>task_memory_reclaim_wait_timeout_count</p></td>
<td><p>Count</p></td>
<td><p>The number of times that the task memory reclaim wait timeouts.</p></td>
</tr>
<tr class="row-even"><td><p>task_splits_count</p></td>
<td><p>Count</p></td>
<td><p>The total number of splits received by all tasks.</p></td>
</tr>
<tr class="row-odd"><td><p>memory_non_reclaimable_count</p></td>
<td><p>Count</p></td>
<td><p>The number of times that the memory reclaim fails because the operator is executing a
non-reclaimable section where it is expected to have reserved enough memory to execute
without asking for more. Therefore, it is an indicator that the memory reservation
is not sufficient. It excludes counting instances where the operator is in a
non-reclaimable state due to currently being on-thread and running or being already
cancelled.</p></td>
</tr>
<tr class="row-even"><td><p>arbitrator_requests_count</p></td>
<td><p>Count</p></td>
<td><p>The number of times a memory arbitration request was initiated by a
memory pool attempting to grow its capacity.</p></td>
</tr>
<tr class="row-odd"><td><p>arbitrator_local_arbitration_count</p></td>
<td><p>Count</p></td>
<td><p>The number of arbitration that reclaims the used memory from the query which initiates
the memory arbitration request itself. It ensures the memory arbitration request won’t
exceed its per-query memory capacity limit.</p></td>
</tr>
<tr class="row-even"><td><p>arbitrator_global_arbitration_count</p></td>
<td><p>Count</p></td>
<td><p>The number of arbitration which ensures the total allocated query capacity won’t exceed
the arbitrator capacity limit. It may or may not reclaim memory from the query which
initiate the memory arbitration request. This indicates the velox runtime doesn’t have
enough memory to run all the queries at their peak memory usage. We have to trigger
spilling to let them run through completion.</p></td>
</tr>
<tr class="row-odd"><td><p>arbitrator_global_arbitration_num_reclaim_victims</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of the number of query memory pools selected to reclaim memory by one
global memory arbitration round in range of [0, 32] with 32 buckets. It is configured to
report latency at P50, P90, P99, and P100 percentiles.</p></td>
</tr>
<tr class="row-even"><td><p>arbitrator_global_arbitration_failed_victim_count</p></td>
<td><p>Count</p></td>
<td><p>The number of victim query memory pool having nothing to spill.</p></td>
</tr>
<tr class="row-odd"><td><p>arbitrator_aborted_count</p></td>
<td><p>Count</p></td>
<td><p>The number of times a query level memory pool is aborted as a result of
a memory arbitration process. The memory pool aborted will eventually
result in a cancelling the original query.</p></td>
</tr>
<tr class="row-even"><td><p>arbitrator_failures_count</p></td>
<td><p>Count</p></td>
<td><p>The number of times a memory arbitration request failed. This may occur
either because the requester was terminated during the processing of
its request, the arbitration request would surpass the maximum allowed
capacity for the requester, or the arbitration process couldn’t release
the requested amount of memory.</p></td>
</tr>
<tr class="row-odd"><td><p>arbitrator_global_arbitration_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The time distribution of a global arbitration run [0, 600s] with 20 buckets.
It is configured to report the latency at P50, P90, P99, and P100 percentiles.</p></td>
</tr>
<tr class="row-even"><td><p>arbitrator_global_arbitration_wait_count</p></td>
<td><p>Count</p></td>
<td><p>The number of times that an arbitration operation wait for global
arbitration to free up memory.</p></td>
</tr>
<tr class="row-odd"><td><p>arbitrator_global_arbitration_wait_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The time distribution of a global arbitration wait [0, 300s] with 20
buckets. It is configured to report the latency at P50, P90, P99, and P100
percentiles.</p></td>
</tr>
<tr class="row-even"><td><p>arbitrator_op_exec_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of the amount of time it take to complete a single
arbitration operation in range of [0, 600s] with 20 buckets. It is configured
to report the latency at P50, P90, P99 and P100 percentiles.</p></td>
</tr>
<tr class="row-odd"><td><p>arbitrator_free_capacity_bytes</p></td>
<td><p>Average</p></td>
<td><p>The average of total free memory capacity which is managed by the
memory arbitrator.</p></td>
</tr>
<tr class="row-even"><td><p>arbitrator_free_reserved_capacity_bytes</p></td>
<td><p>Average</p></td>
<td><p>The average of free memory capacity reserved to ensure each query has
the minimal required capacity to run.</p></td>
</tr>
<tr class="row-odd"><td><p>memory_pool_initial_capacity_bytes</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of a root memory pool’s initial capacity in range of [0 256MB]
with 32 buckets. It is configured to report the capacity at P50, P90, P99,
and P100 percentiles.</p></td>
</tr>
<tr class="row-even"><td><p>memory_pool_capacity_growth_count</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of a root memory pool cappacity growth attemps through
memory arbitration in range of [0, 256] with 32 buckets. It is configured
to report the count at P50, P90, P99, and P100 percentiles.</p></td>
</tr>
<tr class="row-odd"><td><p>memory_pool_usage_leak_bytes</p></td>
<td><p>Sum</p></td>
<td><p>The leaf memory pool usage leak in bytes.</p></td>
</tr>
<tr class="row-even"><td><p>memory_pool_reservation_leak_bytes</p></td>
<td><p>Sum</p></td>
<td><p>The leaf memory pool reservation leak in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>memory_pool_capacity_leak_bytes</p></td>
<td><p>Sum</p></td>
<td><p>The root memory pool reservation leak in bytes.</p></td>
</tr>
<tr class="row-even"><td><p>memory_allocator_double_free_count</p></td>
<td><p>Count</p></td>
<td><p>Tracks the count of double frees in memory allocator, indicating the
possibility of buffer ownership issues when a buffer is freed more
than once.</p></td>
</tr>
<tr class="row-odd"><td><p>memory_allocator_mapped_bytes</p></td>
<td><p>Avg</p></td>
<td><p>Number of bytes currently mapped in MemoryAllocator. These bytes represent
the bytes that are either currently being allocated or were in the past
allocated, not yet been returned back to the operating system, in the
form of ‘Allocation’ or ‘ContiguousAllocation’.</p></td>
</tr>
<tr class="row-even"><td><p>memory_allocator_allocated_bytes</p></td>
<td><p>Avg</p></td>
<td><p>Number of bytes currently allocated (used) from MemoryAllocator in the form
of ‘Allocation’ or ‘ContiguousAllocation’.</p></td>
</tr>
<tr class="row-odd"><td><p>memory_allocator_external_mapped_bytes</p></td>
<td><p>Avg</p></td>
<td><p>Number of bytes currently mapped in MemoryAllocator, in the form of
‘ContiguousAllocation’.</p></td>
</tr>
<tr class="row-even"><td><p>mmap_allocator_delegated_alloc_bytes</p></td>
<td><p>Avg</p></td>
<td><p>Number of bytes currently allocated from MmapAllocator directly from raw
allocateBytes() interface, and internally allocated by malloc. Only small
chunks of memory are delegated to malloc
NOTE: This applies only to MmapAllocator</p></td>
</tr>
</tbody>
</table>
</section>
<section id="cache">
<h2>Cache<a class="headerlink" href="#cache" title="Link to this heading">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 40.0%" />
<col style="width: 10.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Metric Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>cache_max_age_secs</p></td>
<td><p>Avg</p></td>
<td><p>Max possible age of AsyncDataCache and SsdCache entries since the raw file
was opened to load the cache.</p></td>
</tr>
<tr class="row-odd"><td><p>memory_cache_num_large_entries</p></td>
<td><p>Avg</p></td>
<td><p>Total number of large cache entries.</p></td>
</tr>
<tr class="row-even"><td><p>memory_cache_num_tiny_entries</p></td>
<td><p>Avg</p></td>
<td><p>Total number of tiny cache entries.</p></td>
</tr>
<tr class="row-odd"><td><p>memory_cache_num_empty_entries</p></td>
<td><p>Avg</p></td>
<td><p>Total number of cache entries that do not cache anything.</p></td>
</tr>
<tr class="row-even"><td><p>memory_cache_num_shared_entries</p></td>
<td><p>Avg</p></td>
<td><p>Total number of cache entries that are pinned for shared access.</p></td>
</tr>
<tr class="row-odd"><td><p>memory_cache_num_exclusive_entries</p></td>
<td><p>Avg</p></td>
<td><p>Total number of cache entries that are pinned for exclusive access.</p></td>
</tr>
<tr class="row-even"><td><p>memory_cache_num_prefetched_entries</p></td>
<td><p>Avg</p></td>
<td><p>Total number of cache entries that are being or have been prefetched but
have not been hit.</p></td>
</tr>
<tr class="row-odd"><td><p>memory_cache_total_tiny_bytes</p></td>
<td><p>Avg</p></td>
<td><p>Total number of bytes of the cached data that is much smaller than kTinyDataSize.</p></td>
</tr>
<tr class="row-even"><td><p>memory_cache_total_large_bytes</p></td>
<td><p>Avg</p></td>
<td><p>Total number of bytes of the cached data excluding ‘memory_cache_total_tiny_bytes’</p></td>
</tr>
<tr class="row-odd"><td><p>memory_cache_total_tiny_padding_bytes</p></td>
<td><p>Avg</p></td>
<td><p>Total unused capacity bytes in ‘memory_cache_total_tiny_bytes’.</p></td>
</tr>
<tr class="row-even"><td><p>memory_cache_total_large_padding_bytes</p></td>
<td><p>Avg</p></td>
<td><p>Total unused capacity bytes in ‘memory_cache_total_large_bytes’.</p></td>
</tr>
<tr class="row-odd"><td><p>memory_cache_total_prefetched_bytes</p></td>
<td><p>Avg</p></td>
<td><p>Total bytes of cache entries in prefetch state.</p></td>
</tr>
<tr class="row-even"><td><p>memory_cache_sum_evict_score</p></td>
<td><p>Sum</p></td>
<td><p>Sum of scores of evicted entries. This serves to infer an average lifetime
for entries in cache.</p></td>
</tr>
<tr class="row-odd"><td><p>memory_cache_num_hits</p></td>
<td><p>Sum</p></td>
<td><p>Number of hits (saved IO) since last counter retrieval. The first hit to a
prefetched entry does not count.</p></td>
</tr>
<tr class="row-even"><td><p>memory_cache_hit_bytes</p></td>
<td><p>Sum</p></td>
<td><p>Amount of hit bytes (saved IO) since last counter retrieval. The first hit
to a prefetched entry does not count.</p></td>
</tr>
<tr class="row-odd"><td><p>memory_cache_num_new</p></td>
<td><p>Sum</p></td>
<td><p>Number of new entries created since last counter retrieval.</p></td>
</tr>
<tr class="row-even"><td><p>memory_cache_num_evicts</p></td>
<td><p>Sum</p></td>
<td><p>Number of times a valid entry was removed in order to make space, since
last counter retrieval.</p></td>
</tr>
<tr class="row-odd"><td><p>memory_cache_num_savable_evicts</p></td>
<td><p>Sum</p></td>
<td><p>Number of times a valid entry was removed in order to make space but has not
been saved to SSD yet, since last counter retrieval.</p></td>
</tr>
<tr class="row-even"><td><p>memory_cache_num_evict_checks</p></td>
<td><p>Sum</p></td>
<td><p>Number of entries considered for evicting, since last counter retrieval.</p></td>
</tr>
<tr class="row-odd"><td><p>memory_cache_num_wait_exclusive</p></td>
<td><p>Sum</p></td>
<td><p>Number of times a user waited for an entry to transit from exclusive to
shared mode, since last counter retrieval.</p></td>
</tr>
<tr class="row-even"><td><p>memory_cache_num_alloc_clocks</p></td>
<td><p>Sum</p></td>
<td><p>Clocks spent in allocating or freeing memory for backing cache entries,
since last counter retrieval</p></td>
</tr>
<tr class="row-odd"><td><p>memory_cache_num_aged_out_entries</p></td>
<td><p>Sum</p></td>
<td><p>Number of AsyncDataCache entries that are aged out and evicted.
given configured TTL.</p></td>
</tr>
<tr class="row-even"><td><p>memory_cache_num_stale_entries</p></td>
<td><p>Count</p></td>
<td><p>Number of AsyncDataCache entries that are stale because of cache request
size mismatch.</p></td>
</tr>
<tr class="row-odd"><td><p>ssd_cache_cached_regions</p></td>
<td><p>Avg</p></td>
<td><p>Number of regions currently cached by SSD.</p></td>
</tr>
<tr class="row-even"><td><p>ssd_cache_cached_entries</p></td>
<td><p>Avg</p></td>
<td><p>Number of entries currently cached by SSD.</p></td>
</tr>
<tr class="row-odd"><td><p>ssd_cache_cached_bytes</p></td>
<td><p>Avg</p></td>
<td><p>Total bytes currently cached by SSD.</p></td>
</tr>
<tr class="row-even"><td><p>ssd_cache_read_entries</p></td>
<td><p>Sum</p></td>
<td><p>Total number of entries read from SSD.</p></td>
</tr>
<tr class="row-odd"><td><p>ssd_cache_read_bytes</p></td>
<td><p>Sum</p></td>
<td><p>Total number of bytes read from SSD.</p></td>
</tr>
<tr class="row-even"><td><p>ssd_cache_written_entries</p></td>
<td><p>Sum</p></td>
<td><p>Total number of entries written to SSD.</p></td>
</tr>
<tr class="row-odd"><td><p>ssd_cache_written_bytes</p></td>
<td><p>Sum</p></td>
<td><p>Total number of bytes written to SSD.</p></td>
</tr>
<tr class="row-even"><td><p>ssd_cache_aged_out_entries</p></td>
<td><p>Sum</p></td>
<td><p>Total number of SsdCache entries that are aged out and evicted given
configured TTL.</p></td>
</tr>
<tr class="row-odd"><td><p>ssd_cache_aged_out_regions</p></td>
<td><p>Sum</p></td>
<td><p>Total number of SsdCache regions that are aged out and evicted given
configured TTL.</p></td>
</tr>
<tr class="row-even"><td><p>ssd_cache_open_ssd_errors</p></td>
<td><p>Sum</p></td>
<td><p>Total number of SSD file open errors.</p></td>
</tr>
<tr class="row-odd"><td><p>ssd_cache_open_checkpoint_errors</p></td>
<td><p>Sum</p></td>
<td><p>Total number of SSD checkpoint file open errors.</p></td>
</tr>
<tr class="row-even"><td><p>ssd_cache_open_log_errors</p></td>
<td><p>Sum</p></td>
<td><p>Total number of SSD evict log file open errors.</p></td>
</tr>
<tr class="row-odd"><td><p>ssd_cache_delete_checkpoint_errors</p></td>
<td><p>Sum</p></td>
<td><p>Total number of errors while deleting SSD checkpoint files.</p></td>
</tr>
<tr class="row-even"><td><p>ssd_cache_read_without_checksum</p></td>
<td><p>Sum</p></td>
<td><p>Total number of SSD cache reads without checksum verification
due to SSD cache request size mismatch</p></td>
</tr>
<tr class="row-odd"><td><p>ssd_cache_grow_file_errors</p></td>
<td><p>Sum</p></td>
<td><p>Total number of errors while growing SSD cache files.</p></td>
</tr>
<tr class="row-even"><td><p>ssd_cache_write_ssd_errors</p></td>
<td><p>Sum</p></td>
<td><p>Total number of error while writing to SSD cache files.</p></td>
</tr>
<tr class="row-odd"><td><p>ssd_cache_write_ssd_dropped</p></td>
<td><p>Sum</p></td>
<td><p>Total number of writes dropped due to no cache space.</p></td>
</tr>
<tr class="row-even"><td><p>ssd_cache_write_checkpoint_errors</p></td>
<td><p>Sum</p></td>
<td><p>Total number of errors while writing SSD checkpoint file.</p></td>
</tr>
<tr class="row-odd"><td><p>ssd_cache_read_corruptions</p></td>
<td><p>Sum</p></td>
<td><p>Total number of corrupted SSD data read detected by checksum.</p></td>
</tr>
<tr class="row-even"><td><p>ssd_cache_read_ssd_errors</p></td>
<td><p>Sum</p></td>
<td><p>Total number of errors while reading from SSD cache files.</p></td>
</tr>
<tr class="row-odd"><td><p>ssd_cache_read_checkpoint_errors</p></td>
<td><p>Sum</p></td>
<td><p>Total number of errors while reading from SSD checkpoint files.</p></td>
</tr>
<tr class="row-even"><td><p>ssd_cache_checkpoints_read</p></td>
<td><p>Sum</p></td>
<td><p>Total number of checkpoints read.</p></td>
</tr>
<tr class="row-odd"><td><p>ssd_cache_checkpoints_written</p></td>
<td><p>Sum</p></td>
<td><p>Total number of checkpoints written.</p></td>
</tr>
<tr class="row-even"><td><p>ssd_cache_regions_evicted</p></td>
<td><p>Sum</p></td>
<td><p>Total number of cache regions evicted.</p></td>
</tr>
<tr class="row-odd"><td><p>ssd_cache_recovered_entries</p></td>
<td><p>Sum</p></td>
<td><p>Total number of cache entries recovered from checkpoint.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="storage">
<h2>Storage<a class="headerlink" href="#storage" title="Link to this heading">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 40.0%" />
<col style="width: 10.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Metric Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>storage_throttled_duration_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The time distribution of storage IO throttled duration in range of [0, 30s]
with 30 buckets. It is configured to report the capacity at P50, P90, P99,
and P100 percentiles.</p></td>
</tr>
<tr class="row-odd"><td><p>storage_local_throttled_count</p></td>
<td><p>Count</p></td>
<td><p>The number of times that storage IOs get throttled in a storage directory.</p></td>
</tr>
<tr class="row-even"><td><p>storage_global_throttled_count</p></td>
<td><p>Count</p></td>
<td><p>The number of times that storage IOs get throttled in a storage cluster.</p></td>
</tr>
<tr class="row-odd"><td><p>storage_network_throttled_count</p></td>
<td><p>Count</p></td>
<td><p>The number of times that storage IOs get throttled in a storage cluster because of network.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="spilling">
<h2>Spilling<a class="headerlink" href="#spilling" title="Link to this heading">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 40.0%" />
<col style="width: 10.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Metric Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>spill_max_level_exceeded_count</p></td>
<td><p>Count</p></td>
<td><p>The number of times that a spill-able operator hits the max spill level
limit.</p></td>
</tr>
<tr class="row-odd"><td><p>spill_input_bytes</p></td>
<td><p>Sum</p></td>
<td><p>The number of bytes in memory to spill.</p></td>
</tr>
<tr class="row-even"><td><p>spill_bytes</p></td>
<td><p>Sum</p></td>
<td><p>The number of bytes spilled to disk which can be the number of compressed
bytes if compression is enabled.</p></td>
</tr>
<tr class="row-odd"><td><p>spill_rows_count</p></td>
<td><p>Count</p></td>
<td><p>The number of spilled rows.</p></td>
</tr>
<tr class="row-even"><td><p>spill_files_count</p></td>
<td><p>Count</p></td>
<td><p>The number of spilled files.</p></td>
</tr>
<tr class="row-odd"><td><p>spill_fill_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of the amount of time spent on filling rows for spilling
in range of [0, 600s] with 20 buckets. It is configured to report the
latency at P50, P90, P99, and P100 percentiles.</p></td>
</tr>
<tr class="row-even"><td><p>spill_sort_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of the amount of time spent on sorting rows for spilling
in range of [0, 600s] with 20 buckets. It is configured to report the
latency at P50, P90, P99, and P100 percentiles.</p></td>
</tr>
<tr class="row-odd"><td><p>spill_serialization_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of the amount of time spent on serializing rows for
spilling in range of [0, 600s] with 20 buckets. It is configured to report
the latency at P50, P90, P99, and P100 percentiles.</p></td>
</tr>
<tr class="row-even"><td><p>spill_disk_writes_count</p></td>
<td><p>Count</p></td>
<td><p>The number of disk writes to spill rows.</p></td>
</tr>
<tr class="row-odd"><td><p>spill_flush_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of the amount of time spent on copy out serialized
rows for disk write in range of [0, 600s] with 20 buckets. It is configured
to report the latency at P50, P90, P99, and P100 percentiles. Note:  If
compression is enabled, this includes the compression time.</p></td>
</tr>
<tr class="row-even"><td><p>spill_write_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of the amount of time spent on writing spilled rows to
disk in range of [0, 600s] with 20 buckets. It is configured to report the
latency at P50, P90, P99, and P100 percentiles.</p></td>
</tr>
<tr class="row-odd"><td><p>file_writer_early_flushed_raw_bytes</p></td>
<td><p>Sum</p></td>
<td><p>Number of bytes pre-maturely flushed from file writers because of memory reclaiming.</p></td>
</tr>
<tr class="row-even"><td><p>spill_memory_bytes</p></td>
<td><p>Avg</p></td>
<td><p>The current spilling memory usage in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>spill_peak_memory_bytes</p></td>
<td><p>Avg</p></td>
<td><p>The peak spilling memory usage in bytes.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="exchange">
<h2>Exchange<a class="headerlink" href="#exchange" title="Link to this heading">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 40.0%" />
<col style="width: 10.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Metric Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>exchange_data_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of data exchange latency in range of [0, 50s] with 50
buckets. It is configured to report latency at P50, P90, P99, and P100
percentiles.</p></td>
</tr>
<tr class="row-odd"><td><p>exchange_data_bytes</p></td>
<td><p>Sum</p></td>
<td><p>The exchange data size in bytes.</p></td>
</tr>
<tr class="row-even"><td><p>exchange_data_size</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of exchange data size in range of [0, 128MB] with 128
buckets. It is configured to report the capacity at P50, P90, P99, and P100
percentiles.</p></td>
</tr>
<tr class="row-odd"><td><p>exchange_data_count</p></td>
<td><p>Count</p></td>
<td><p>The number of data exchange requests.</p></td>
</tr>
<tr class="row-even"><td><p>exchange_data_size_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of data exchange size latency in range of [0, 5s] with 50
buckets. It is configured to report latency at P50, P90, P99, and P100
percentiles.</p></td>
</tr>
<tr class="row-odd"><td><p>exchange_data_size_count</p></td>
<td><p>Count</p></td>
<td><p>The number of data size exchange requests.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="hive-connector">
<h2>Hive Connector<a class="headerlink" href="#hive-connector" title="Link to this heading">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 40.0%" />
<col style="width: 10.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Metric Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>hive_file_handle_generate_latency_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of hive file open latency in range of [0, 100s] with 10
buckets. It is configured to report latency at P50, P90, P99, and P100
percentiles.</p></td>
</tr>
<tr class="row-odd"><td><p>hive_sort_writer_finish_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of hive sort writer finish processing time slice in range
of[0, 120s] with 60 buckets. It is configured to report latency at P50,
P90, P99, and P100 percentiles.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="index-join">
<h2>Index Join<a class="headerlink" href="#index-join" title="Link to this heading">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 40.0%" />
<col style="width: 10.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Metric Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>index_lookup_wait_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The time distribution of index lookup time in range of [0, 16s] with 512
buckets and reports P50, P90, P99, and P100.</p></td>
</tr>
<tr class="row-odd"><td><p>index_lookup_blocked_wait_time_ms</p></td>
<td><p>Histogram</p></td>
<td><p>The time distribution of index lookup operator blocked wait time in range
of [0, 16s] with 512 buckets and reports P50, P90, P99, and P100.</p></td>
</tr>
<tr class="row-even"><td><p>index_lookup_result_raw_bytes</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of index lookup result raw bytes in range of [0, 128MB]
with 128 buckets. It is configured to report the capacity at P50, P90, P99,
and P100 percentiles.</p></td>
</tr>
<tr class="row-odd"><td><p>index_lookup_result_bytes</p></td>
<td><p>Histogram</p></td>
<td><p>The distribution of index lookup result bytes in range of [0, 128MB] with
128 buckets. It is configured to report the capacity at P50, P90, P99, and
P100 percentiles.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="table-scan">
<h2>Table Scan<a class="headerlink" href="#table-scan" title="Link to this heading">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 40.0%" />
<col style="width: 10.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Metric Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>table_scan_batch_process_time_ms</p></td>
<td><p>Average</p></td>
<td><p>Tracks the averaged table scan batch processing time in milliseconds.</p></td>
</tr>
<tr class="row-odd"><td><p>table_scan_batch_bytes</p></td>
<td><p>Average</p></td>
<td><p>Tracks the averaged table scan output batch size in bytes.
with 512 buckets and reports P50, P90, P99, and P100</p></td>
</tr>
</tbody>
</table>
</section>
<section id="s3-filesystem">
<h2>S3 FileSystem<a class="headerlink" href="#s3-filesystem" title="Link to this heading">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 40.0%" />
<col style="width: 10.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Metric Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>s3_active_connections</p></td>
<td><p>Sum</p></td>
<td><p>The number of connections open for S3 read operations.</p></td>
</tr>
<tr class="row-odd"><td><p>s3_started_uploads</p></td>
<td><p>Count</p></td>
<td><p>The number of S3 upload calls that were started.</p></td>
</tr>
<tr class="row-even"><td><p>s3_successful_uploads</p></td>
<td><p>Count</p></td>
<td><p>The number of S3 upload calls that were completed.</p></td>
</tr>
<tr class="row-odd"><td><p>s3_failed_uploads</p></td>
<td><p>Count</p></td>
<td><p>The number of S3 upload calls that failed.</p></td>
</tr>
<tr class="row-even"><td><p>s3_metadata_calls</p></td>
<td><p>Count</p></td>
<td><p>The number of S3 head (metadata) calls.</p></td>
</tr>
<tr class="row-odd"><td><p>s3_get_metadata_errors</p></td>
<td><p>Count</p></td>
<td><p>The number of S3 head (metadata) calls that failed.</p></td>
</tr>
<tr class="row-even"><td><p>s3_get_metadata_retries</p></td>
<td><p>Count</p></td>
<td><p>The number of retries made during S3 head (metadata) calls.</p></td>
</tr>
<tr class="row-odd"><td><p>s3_get_object_calls</p></td>
<td><p>Count</p></td>
<td><p>The number of S3 getObject calls.</p></td>
</tr>
<tr class="row-even"><td><p>s3_get_object_errors</p></td>
<td><p>Count</p></td>
<td><p>The number of S3 getObject calls that failed.</p></td>
</tr>
<tr class="row-odd"><td><p>s3_get_object_retries</p></td>
<td><p>Count</p></td>
<td><p>The number of retries made during S3 getObject calls.</p></td>
</tr>
</tbody>
</table>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Runtime Metrics</a><ul>
<li><a class="reference internal" href="#task-execution">Task Execution</a></li>
<li><a class="reference internal" href="#memory-management">Memory Management</a></li>
<li><a class="reference internal" href="#cache">Cache</a></li>
<li><a class="reference internal" href="#storage">Storage</a></li>
<li><a class="reference internal" href="#spilling">Spilling</a></li>
<li><a class="reference internal" href="#exchange">Exchange</a></li>
<li><a class="reference internal" href="#hive-connector">Hive Connector</a></li>
<li><a class="reference internal" href="#index-join">Index Join</a></li>
<li><a class="reference internal" href="#table-scan">Table Scan</a></li>
<li><a class="reference internal" href="#s3-filesystem">S3 FileSystem</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="../monitoring.html"
                          title="previous chapter">Monitoring</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="stats.html"
                          title="next chapter">Runtime Stats</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/monitoring/metrics.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="stats.html" title="Runtime Stats"
             >next</a> |</li>
        <li class="right" >
          <a href="../monitoring.html" title="Monitoring"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Velox  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../monitoring.html" >Monitoring</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Runtime Metrics</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright TBD.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.7.
    </div>
  </body>
</html>