---
slug: segfault-dependency-update
title: "SEGFAULT due to Dependency Update"
authors: [majetideepak, czentgr]
tags: [tech-blog, build]
---

## Background
Velox depends on several [libraries](https://github.com/facebookincubator/velox/blob/main/CMake/resolve_dependency_modules/README.md).
Some of these dependencies include open-source libraries from Meta, including [Folly](https://github.com/facebook/folly) and
[Facebook Thrift(fbthrift)](https://github.com/facebook/fbthrift). These libraries are in active development. These libraries also depend on each other, and hence they all have to be updated to the same version at the same time.

Updating these dependencies typically involves modifying the Velox code to align with any public API or semantic changes in these dependencies.
However, a recent upgrade of Folly and fbthrift to version *v2025.04.28.00* caused a *SEGFAULT* only in one unit test in Velox
named *velox_functions_remote_client_test*.

## Investigation
We immediately put on our *gdb* gloves and looked at the stack traces. This issue was also reproducible in a debug build.
The SEGFAULT occurred in the ThriftServer of fbthrift during initialization of the ThriftServer, but the offending call was invoking a destructor of a certain handler.
However, the corresponding source code was pointing to an invocation of a different function. And this code was present inside a fbthrift
header called *AsyncProcessor.h*
This handler(*RemoteServer*) was implemented in Velox as a Thrift definition. Velox compiled this thrift file using fbthrif, and the generated code
was using the *ServerInterface* class in fbthrift. This *ServerInterface* class was further extended from both the *AsyncProcessorFactory* and
*ServiceHandlerBase* interfaces in fbthrift.
One of the culprits resulting in SEGFAULTS in the past was the conflict due to the usage of Apache Thrift and fbthrift.
However, this was not the root cause this time because we were able to reproduce this issue by just building the test without the Apache Thrift dependency installed.
We were entering a new territory to investigate, and we were not sure where to start.

We then compiled an example called *EchoService* in fbthrift that was very similar to the *RemoteServer*, and it worked. Then we copied and compiled the Velox *RemoveServer*
in fbthrift and that worked too! So the culprit was likely in the compilation flags, which likely differed between fbthrift and Velox.
We enabled the verbose logging for both builds and were able to spot one difference. We saw the GCC *-fcoroutines* flag being used in the fbthrift build.

We were also very curious about the invocation of the destructor instead of the actual function. We wore the gdb gloves again and dumped the entire
vtable for the RemoteServer class and its base classes. The vtables were different when it was built in Velox vs fbthrift.
Specifically, the list of functions inherited from *ServiceHandlerBase* was different.

The vtable for the *RemoteServer* handler in the Velox build had the following entries:

```
folly::SemiFuture<folly::Unit> semifuture_onStartServing()
folly::SemiFuture<folly::Unit> semifuture_onStopRequested()
Thunk ServiceHandlerBase::~ServiceHandlerBase
Thunk ServiceHandlerBase::~ServiceHandlerBase
```

The vtable for the *RemoteServer* handler in the fbthrift build had the following entries:

```
folly::coro::Task<void> co_onStartServing()
folly::coro::Task<void> co_onStopRequested()
folly::SemiFuture<folly::Unit> semifuture_onStartServing()
folly::SemiFuture<folly::Unit> semifuture_onStopRequested()
Thunk ServiceHandlerBase::~ServiceHandlerBase
Thunk ServiceHandlerBase::~ServiceHandlerBase
```

Tying up both the pieces of evidence, we could conclude that Velox generated a different vtable structure compared to what fbthrift (and thus ThriftServer) was built with.
Looking around further, we noticed that the *ServiceHandlerBase* was conditionally adding functions based on the *-fcoroutines* flag.

```
class ServiceHandlerBase {
  ....
 public:
#if FOLLY_HAS_COROUTINES
  virtual folly::coro::Task<void> co_onStartServing() { co_return; }
  virtual folly::coro::Task<void> co_onStopRequested() {
    throw MethodNotImplemented();
  }
#endif

  virtual folly::SemiFuture<folly::Unit> semifuture_onStartServing() {
#if FOLLY_HAS_COROUTINES
    return co_onStartServing().semi();
#else
    return folly::makeSemiFuture();
#endif
  }
```

As a result, the ThriftServer would access an incorrect function, the destructor instead of the expected initialization function, because the functions at the offset used were different, thus resulting in a SEGFAULT.
We recompiled the fbthrift dependency for Velox with coroutines disabled, and the test passed.
