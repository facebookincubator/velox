/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <cstdint>
#include "folly/hash/MurmurHash.h"
#include "velox/common/memory/HashStringAllocator.h"

namespace facebook::velox::functions::aggregate {

/// For technical details of SfmSketch, please refer to the paper
/// <a href="https://arxiv.org/pdf/2302.02056.pdf">Sketch-Flip-Merge: Mergeable
/// Sketches for Private Distinct Counting</a>.
class SfmSketch {
  static constexpr double kNonPrivateEpsilon =
      std::numeric_limits<double>::infinity();
  static constexpr int32_t kMaxIteration = 1000;
  static constexpr uint32_t kMaxIndexBitLength = 16;

 public:
  // Constructor to create a non-private sketch.
  SfmSketch(HashStringAllocator* allocator);

  // Set the sketch size. The size is determined by the indexBitLength and the
  // precision.
  void setSketchSize(uint32_t indexBitLength, uint32_t precision);

  // Count the number of trailing zeros in a 64-bits hash value starting from
  // the most significant bit after the 'indexBitLength' bits.
  static uint32_t numberOfTrailingZeros(uint64_t hash, uint32_t indexBitLength);

  // Add an element to the sketch. Currently, we only support string and numeric
  // types. We will make sure input type is hashable by specifying signatures.
  template <typename T>
  void add(T value) {
    addHash(folly::hash::murmurHash64(
        reinterpret_cast<const char*>(&value),
        sizeof(value),
        /*seed*/ 0));
  }

  // Add a hash to the sketch. The hash is generated by the caller.
  void addHash(uint64_t hash);

  // Another way to add an element to the sketch. Explicitly toggle the bit at
  // 'bucketIndex' and 'zeros' position.
  void addIndexAndZeros(uint32_t bucketIndex, uint32_t zeros);

  // Compute the bit index with the given hash and indexBitLength.
  static uint32_t computeIndex(uint64_t hash, uint32_t indexBitLength);

  // Compute the number of buckets given the indexBitLength.
  static uint32_t numberOfBuckets(uint32_t indexBitLength);

  // Compute the number of bits needed to represent the index of a bucket.
  static uint32_t indexBitLength(uint32_t numberOfBuckets);

  // Calculate the randomized response probability given epsilon.
  static double calculateRandomizedResponseProbability(double epsilon);

  // Probability of a 1-bit remaining a 1-bit under randomized response.
  double getOnProbability() const {
    return 1 - randomizedResponseProbability_;
  }

  uint32_t getNumberOfBits() const {
    return bits_.size() * 8;
  }

  double getRandomizedResponseProbability() const {
    return randomizedResponseProbability_;
  }

  uint32_t getIndexBitLength() const {
    return indexBitLength_;
  }

  uint32_t getPrecision() const {
    return precision_;
  }

  bool privacyEnabled() const {
    return randomizedResponseProbability_ > 0;
  }

 private:
  static void validateEpsilon(double epsilon);
  static void validatePrecision(uint32_t precision, uint32_t indexBitLength);
  static void validatePrefixLength(uint32_t indexBitLength);
  static void validateRandomizedResponseProbability(double p);

  // Probability of observing a run of zeros of length level in any single
  // bucket
  double observationProbability(uint32_t level) const;

  // Flip the bit at given bucketIndex and zeros position.
  void setBitTrue(uint32_t bucketIndex, uint32_t zeros);

  // Number of bits to represent the index of a bucket.
  uint32_t indexBitLength_{0};

  // Number of trailing zeros in a hash value.
  uint32_t precision_{0};

  // Probability of a bit being flipped.
  double randomizedResponseProbability_{0};

  // The underline bit representation of the sketch.
  std::vector<int8_t, facebook::velox::StlAllocator<int8_t>> bits_;
};
} // namespace facebook::velox::functions::aggregate
