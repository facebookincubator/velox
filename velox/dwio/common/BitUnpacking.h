/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include "velox/common/base/Exceptions.h"
#include "velox/dwio/common/exception/Exception.h"

#if defined(__AVX2__) and defined(__BMI2__)

#include <immintrin.h>
#include <algorithm>
#include <cstdint>
#include <iomanip>
#include <iostream>
#include <optional>

// The implementation in this file uses all (static) inline functions instead of
// using a class. This is to avoid function dispatch cost and facilitate
// inlining.
namespace facebook::velox::dwio::common {

// Pdep instruction masks for uint8_t. Generated by generatePdepMasks(8).
static constexpr const uint64_t kPdepMask8[] = {
    0x0000000000000000,
    0x0101010101010101,
    0x0303030303030303,
    0x0707070707070707,
    0x0f0f0f0f0f0f0f0f,
    0x1f1f1f1f1f1f1f1f,
    0x3f3f3f3f3f3f3f3f,
    0x7f7f7f7f7f7f7f7f,
    0xffffffffffffffff};

// Pdep instruction masks for uint16_t. Generated by generatePdepMasks(16).
static constexpr const uint64_t kPdepMask16[] = {
    0x0000000000000000,
    0x0001000100010001,
    0x0003000300030003,
    0x0007000700070007,
    0x000f000f000f000f,
    0x001f001f001f001f,
    0x003f003f003f003f,
    0x007f007f007f007f,
    0x00ff00ff00ff00ff,
    0x01ff01ff01ff01ff,
    0x03ff03ff03ff03ff,
    0x07ff07ff07ff07ff,
    0x0fff0fff0fff0fff,
    0x1fff1fff1fff1fff,
    0x3fff3fff3fff3fff,
    0x7fff7fff7fff7fff,
    0xffffffffffffffff};

// Pdep instruction masks for uint32_t. Generated by generatePdepMasks(32).
static constexpr const uint64_t kPdepMask32[] = {
    0x0000000000000000, 0x0000000100000001, 0x0000000300000003,
    0x0000000700000007, 0x0000000f0000000f, 0x0000001f0000001f,
    0x0000003f0000003f, 0x0000007f0000007f, 0x000000ff000000ff,
    0x000001ff000001ff, 0x000003ff000003ff, 0x000007ff000007ff,
    0x00000fff00000fff, 0x00001fff00001fff, 0x00003fff00003fff,
    0x00007fff00007fff, 0x0000ffff0000ffff, 0x0001ffff0001ffff,
    0x0003ffff0003ffff, 0x0007ffff0007ffff, 0x000fffff000fffff,
    0x001fffff001fffff, 0x003fffff003fffff, 0x007fffff007fffff,
    0x00ffffff00ffffff, 0x01ffffff01ffffff, 0x03ffffff03ffffff,
    0x07ffffff07ffffff, 0x0fffffff0fffffff, 0x1fffffff1fffffff,
    0x3fffffff3fffffff, 0x7fffffff7fffffff, 0xffffffffffffffff};

// Unpack numValues number of uint16_t values with bitWidth in
// [1, 4] range.
static inline void unpack1to4(
    uint8_t bitWidth,
    const uint8_t*& inputBuffer,
    uint64_t numValues,
    uint16_t*& outputBuffer) {
  uint64_t pdepMask = kPdepMask8[bitWidth];

  uint64_t numBytesPerTime = (bitWidth * 16 + 7) / 8;
  uint64_t shift = bitWidth * 8;
  uint64_t numBytes = (numValues * bitWidth + 7) / 8;
  alignas(16) uint64_t intermediateValues[2];
  auto readEndOffset = inputBuffer + numBytes;

  // Process 2 * bitWidth bytes (16 values) a time.
  while (inputBuffer <= readEndOffset - 8) {
    uint64_t val = *reinterpret_cast<const uint64_t*>(inputBuffer);

    intermediateValues[0] = _pdep_u64(val, pdepMask);
    intermediateValues[1] = _pdep_u64(val >> shift, pdepMask);
    __m256i result = _mm256_cvtepu8_epi16(
        _mm_load_si128(reinterpret_cast<const __m128i*>(intermediateValues)));
    _mm256_storeu_si256(reinterpret_cast<__m256i*>(outputBuffer), result);

    inputBuffer += numBytesPerTime;
    outputBuffer += 16;
  }

  // Finish the last batch which has < 8 bytes. Now Process 8 values a time.
  uint64_t val = 0;
  while (inputBuffer < readEndOffset) {
    std::memcpy(&val, inputBuffer, bitWidth);

    uint64_t intermediateValue = _pdep_u64(val, pdepMask);
    __m256i result = _mm256_cvtepu8_epi16(_mm_loadl_epi64(
        (reinterpret_cast<const __m128i*>(&intermediateValue))));
    _mm256_storeu_si256(reinterpret_cast<__m256i*>(outputBuffer), result);

    inputBuffer += bitWidth;
    outputBuffer += 8;
  }
}

// Unpack numValues number of uint16_t values with bitWidth in [5, 8] range.
// Note that for bitWidth = 8, this solution is about the same as the simple
// 8->16 lane width conversion solution without pdep on Intel i9 compiled by
// clang.
static inline void unpack5to8(
    const uint8_t bitWidth,
    const uint8_t*& inputBuffer,
    uint64_t numValues,
    uint16_t*& outputBuffer) {
  uint64_t pdepMask = kPdepMask8[bitWidth];

  auto readEndOffset = inputBuffer + (numValues * bitWidth + 7) / 8;
  alignas(16) uint64_t intermediateValues[2];

  // Process 2 * bitWidth bytes (16 values) a time.
  while (inputBuffer <= readEndOffset - 16) {
    uint64_t value1 = 0;
    std::memcpy(&value1, inputBuffer, bitWidth);
    intermediateValues[0] = _pdep_u64(value1, pdepMask);

    uint64_t value2 = 0;
    std::memcpy(&value2, inputBuffer + bitWidth, bitWidth);
    intermediateValues[1] = _pdep_u64(value2, pdepMask);

    __m256i result = _mm256_cvtepu8_epi16(
        _mm_load_si128(reinterpret_cast<const __m128i*>(intermediateValues)));
    _mm256_storeu_si256(reinterpret_cast<__m256i*>(outputBuffer), result);

    inputBuffer += bitWidth * 2;
    outputBuffer += 16;
  }

  // Finish the last batch which has < 16 bytes. Now Process bitWidth
  // bytes (8 values) a time.
  while (inputBuffer < readEndOffset) {
    uint64_t value = 0;
    std::memcpy(&value, inputBuffer, bitWidth);
    uint64_t intermediateValue = _pdep_u64(value, pdepMask);

    __m256i result = _mm256_cvtepu8_epi16(_mm_loadl_epi64(
        (reinterpret_cast<const __m128i*>(&intermediateValue))));
    _mm256_storeu_si256(reinterpret_cast<__m256i*>(outputBuffer), result);

    inputBuffer += bitWidth;
    outputBuffer += 8;
  }
}

// Unpack numValues number of uint16_t values with bitWidth = 8.
static inline void unpack8_cast(
    const uint8_t*& inputBuffer,
    uint64_t numValues,
    uint16_t*& outputBuffer) {
  uint64_t numBytes = (numValues * 8 + 7) / 8;
  auto readEndOffset = inputBuffer + numBytes;

  alignas(16) uint64_t vals[2];

  // Process bitWidth bytes (16 values) a time.
  while (inputBuffer < readEndOffset - 16) {
    vals[0] = *reinterpret_cast<const uint64_t*>(inputBuffer);
    vals[1] = *reinterpret_cast<const uint64_t*>(inputBuffer + 8);

    __m256i result = _mm256_cvtepu8_epi16(*((const __m128i*)vals));
    _mm256_storeu_si256(reinterpret_cast<__m256i*>(outputBuffer), result);

    inputBuffer += 16;
    outputBuffer += 16;
  }

  // Finish the last batch which has < 16 bytes. Now process 8
  // bytes (8 values) a time.
  uint64_t val = 0;
  while (inputBuffer < readEndOffset) {
    std::memcpy(&val, inputBuffer, 8);

    __m256i result =
        _mm256_cvtepu8_epi16(_mm_loadl_epi64((const __m128i*)&val));
    _mm256_storeu_si256(reinterpret_cast<__m256i*>(outputBuffer), result);

    inputBuffer += 8;
    outputBuffer += 8;
  }
}

// Unpack numValues number of uint16_t values with bitWidth in {9, 11, 13, 15}.
static inline void unpack9to15(
    const uint8_t bitWidth,
    const uint8_t*& inputBuffer,
    uint64_t numValues,
    uint16_t*& outputBuffer) {
  uint64_t pdepMask = kPdepMask16[bitWidth];

  uint8_t bytes2 = bitWidth / 2;
  uint8_t bytes1 = bitWidth - bytes2;

  uint8_t shift1 = bitWidth * 4;
  uint8_t shift2 = bytes1 * 8 - shift1;
  uint64_t valueMask = (1L << shift1) - 1;

  // Process bitWidth bytes (2 * 4 values) a time.
  auto readEndOffset = inputBuffer + (numValues * bitWidth + 7) / 8;
  while (inputBuffer < readEndOffset) {
    // Process the first part of bytes1 bytes.
    uint64_t value1 = 0;
    std::memcpy(&value1, inputBuffer, bytes1);
    *reinterpret_cast<uint64_t*>(outputBuffer) =
        _pdep_u64(value1 & valueMask, pdepMask);

    // Process the second part of bytes2 bytes.
    uint64_t value2 = 0;
    std::memcpy(&value2, inputBuffer + bytes1, bytes2);
    *reinterpret_cast<uint64_t*>(outputBuffer + 4) =
        _pdep_u64((value1 >> shift1) | (value2 << shift2), pdepMask);

    inputBuffer += bitWidth;
    outputBuffer += 8;
  }
}

// Unpack numValues number of uint16_t values with bitWidth = 16
static inline void unpack16(
    const uint8_t*& inputBuffer,
    uint64_t numValues,
    uint16_t*& outputBuffer) {
  uint64_t numBytes = numValues * 2;
  std::memcpy(outputBuffer, inputBuffer, numBytes);

  inputBuffer += numBytes;
  outputBuffer += numBytes;
}

// Unpack numValues number of uint32_t values with bitWidth in [5, 8] range.
static inline void unpack1to7(
    uint8_t bitWidth,
    const uint8_t*& inputBuffer,
    uint64_t numValues,
    uint32_t*& outputBuffer) {
  uint64_t pdepMask = kPdepMask8[bitWidth];

  uint64_t numBytes = (numValues * bitWidth + 7) / 8;
  auto readEndOffset = inputBuffer + numBytes;

  // Process bitWidth bytes (8 values) a time.
  while (inputBuffer <= readEndOffset - 8) {
    uint64_t val = *reinterpret_cast<const uint64_t*>(inputBuffer);

    uint64_t intermediateVal = _pdep_u64(val, pdepMask);
    __m256i result = _mm256_cvtepu8_epi32(
        _mm_loadl_epi64(reinterpret_cast<const __m128i*>(&intermediateVal)));
    _mm256_storeu_si256(reinterpret_cast<__m256i*>(outputBuffer), result);

    inputBuffer += bitWidth;
    outputBuffer += 8;
  }

  // last <8 bytes
  uint64_t val = 0;
  while (inputBuffer < readEndOffset) {
    std::memcpy(&val, inputBuffer, bitWidth);

    uint64_t intermediateVal = _pdep_u64(val, pdepMask);
    __m256i result = _mm256_cvtepu8_epi32(
        _mm_loadl_epi64(reinterpret_cast<const __m128i*>(&intermediateVal)));
    _mm256_storeu_si256(reinterpret_cast<__m256i*>(outputBuffer), result);

    inputBuffer += bitWidth;
    outputBuffer += 8;
  }
}

// Unpack numValues number of uint32_t values with bitWidth = 8.
static inline void unpack8(
    const uint8_t*& inputBuffer,
    uint64_t numValues,
    uint32_t*& outputBuffer) {
  uint64_t numBytes = (numValues * 8 + 7) / 8;
  auto readEndOffset = inputBuffer + numBytes;

  // Process 8 bytes (8 values) a time.
  while (inputBuffer < readEndOffset) {
    __m256i result = _mm256_cvtepu8_epi32(
        _mm_loadl_epi64(reinterpret_cast<const __m128i*>(inputBuffer)));
    _mm256_storeu_si256(reinterpret_cast<__m256i*>(outputBuffer), result);

    inputBuffer += 8;
    outputBuffer += 8;
  }
}

// Unpack numValues number of uint32_t values with bitWidth in [9, 15] range.
inline void unpack9to15(
    uint8_t bitWidth,
    const uint8_t*& inputBuffer,
    uint64_t numValues,
    uint32_t*& outputBuffer) {
  uint64_t pdepMask = kPdepMask16[bitWidth];

  uint8_t shift1 = bitWidth * 4;
  uint8_t shift2 = 64 - shift1;

  alignas(16) uint64_t values[2] = {0, 0};
  alignas(16) uint64_t intermediateValues[2];

  uint64_t numBytes = (numValues * bitWidth + 7) / 8;
  auto readEndOffset = inputBuffer + numBytes;

  // Process bitWidth bytes (8 values) a time.
  while (inputBuffer < readEndOffset) {
    std::memcpy(values, inputBuffer, bitWidth);

    intermediateValues[0] = _pdep_u64(values[0], pdepMask);
    intermediateValues[1] =
        _pdep_u64((values[0] >> shift1) | (values[1] << shift2), pdepMask);

    __m256i result = _mm256_cvtepu16_epi32(
        _mm_load_si128(reinterpret_cast<const __m128i*>(intermediateValues)));
    _mm256_storeu_si256(reinterpret_cast<__m256i*>(outputBuffer), result);

    inputBuffer += bitWidth;
    outputBuffer += 8;
  }
}

// Unpack numValues number of uint32_t values with bitWidth = 16.
static inline void unpack16(
    const uint8_t*& inputBuffer,
    uint64_t numValues,
    uint32_t*& outputBuffer) {
  uint64_t numBytes = (numValues * 16 + 7) / 8;
  auto readEndOffset = inputBuffer + numBytes;

  // Process 16 bytes (8 values) a time.
  while (inputBuffer < readEndOffset) {
    __m256i result = _mm256_cvtepu16_epi32(
        _mm_loadu_si128(reinterpret_cast<const __m128i*>(inputBuffer)));
    _mm256_storeu_si256(reinterpret_cast<__m256i*>(outputBuffer), result);

    inputBuffer += 16;
    outputBuffer += 8;
  }
}

// Unpack numValues number of uint32_t values with bitWidth in [17, 21] range.
static inline void unpack17to21(
    uint8_t bitWidth,
    const uint8_t*& inputBuffer,
    uint64_t numValues,
    uint32_t*& outputBuffer) {
  uint64_t pdepMask = kPdepMask32[bitWidth];

  uint8_t rightShift1 = bitWidth * 2;
  uint8_t leftShift1 = 64 - rightShift1;
  uint8_t rightShift2 = bitWidth * 4 - 64;
  uint8_t rightShift3 = bitWidth * 6 - 64;
  uint8_t leftShift3 = 128 - bitWidth * 6;

  alignas(16) uint64_t values[4] = {0, 0, 0, 0};

  uint64_t numBytes = (numValues * bitWidth + 7) / 8;
  auto readEndOffset = inputBuffer + numBytes;

  // Process bitWidth bytes (8 values) a time.
  while (inputBuffer < readEndOffset) {
    std::memcpy(values, inputBuffer, bitWidth);

    *reinterpret_cast<uint64_t*>(outputBuffer) = _pdep_u64(values[0], pdepMask);
    *(reinterpret_cast<uint64_t*>(outputBuffer) + 1) = _pdep_u64(
        (values[0] >> rightShift1) | (values[1] << leftShift1), pdepMask);
    *(reinterpret_cast<uint64_t*>(outputBuffer) + 2) =
        _pdep_u64(values[1] >> rightShift2, pdepMask);
    *(reinterpret_cast<uint64_t*>(outputBuffer) + 3) = _pdep_u64(
        (values[1] >> rightShift3) | (values[2] << leftShift3), pdepMask);

    inputBuffer += bitWidth;
    outputBuffer += 8;
  }
}

// Unpack numValues number of uint32_t values with bitWidth in [22, 31] range.
static inline void unpack22to31(
    uint8_t bitWidth,
    const uint8_t*& inputBuffer,
    uint64_t numValues,
    uint32_t*& outputBuffer) {
  uint64_t pdepMask = kPdepMask32[bitWidth];

  uint8_t rightShift1 = bitWidth * 2;
  uint8_t leftShift1 = 64 - rightShift1;
  uint8_t rightShift2 = bitWidth * 4 - 64;
  uint8_t leftShift2 = 128 - bitWidth * 4;
  uint8_t rightShift3 = bitWidth * 6 - 128;
  uint8_t leftShift3 = bitWidth * 8 - 128;

  alignas(16) uint64_t values[4] = {0, 0, 0, 0};

  uint64_t numBytes = (numValues * bitWidth + 7) / 8;
  auto readEndOffset = inputBuffer + numBytes;

  // Process bitWidth bytes (8 values) a time.
  while (inputBuffer < readEndOffset) {
    std::memcpy(values, inputBuffer, bitWidth);

    *reinterpret_cast<uint64_t*>(outputBuffer) = _pdep_u64(values[0], pdepMask);
    *(reinterpret_cast<uint64_t*>(outputBuffer) + 1) = _pdep_u64(
        (values[0] >> rightShift1) | (values[1] << leftShift1), pdepMask);
    *(reinterpret_cast<uint64_t*>(outputBuffer) + 2) = _pdep_u64(
        (values[1] >> rightShift2) | (values[2] << leftShift2), pdepMask);
    *(reinterpret_cast<uint64_t*>(outputBuffer) + 3) = _pdep_u64(
        (values[1] >> rightShift3) | (values[2] << leftShift3), pdepMask);

    inputBuffer += bitWidth;
    outputBuffer += 8;
  }
}

// Unpack numValues number of uint16_t values with bitWidth = 16
static inline void unpack32(
    const uint8_t*& inputBuffer,
    uint64_t numValues,
    uint32_t*& outputBuffer) {
  uint64_t numBytes = numValues * 4;
  std::memcpy(outputBuffer, inputBuffer, numBytes);

  inputBuffer += numBytes;
  outputBuffer += numBytes;
}

/// Unpack numValues number of uint8_t values from inputBuffer. The results will
/// be written to outputBuffer. numValues must be a multiple of 8. The caller
/// needs to make sure the inputBufferLen contains at least numValues number of
/// packed values.
inline void unpack(
    uint8_t bitWidth,
    const uint8_t*& inputBuffer,
    uint64_t inputBufferLen,
    uint64_t numValues,
    uint8_t*& outputBuffer) {
  DWIO_ENSURE(bitWidth >= 1 && bitWidth <= 8);
  DWIO_ENSURE((numValues & 0x7) == 0);
  DWIO_ENSURE(inputBufferLen * 8 >= bitWidth * numValues);

  uint64_t mask = kPdepMask8[bitWidth];
  uint64_t numBytes = (numValues * bitWidth + 7) / 8;
  auto readEndOffset = inputBuffer + numBytes;

  // Process bitWidth bytes (8 values) a time. Note that for bitWidth 8, the
  // performance of direct memcpy is about the same as this solution.
  while (inputBuffer <= readEndOffset - 8) {
    // Using memcpy() here may result in non-optimized loops by clong.
    uint64_t val = *reinterpret_cast<const uint64_t*>(inputBuffer);
    *(reinterpret_cast<uint64_t*>(outputBuffer)) = _pdep_u64(val, mask);
    inputBuffer += bitWidth;
    outputBuffer += 8;
  }

  // last batch of 8 values that is less than 8 bytes
  uint64_t val = 0;
  while (inputBuffer < readEndOffset) {
    std::memcpy(&val, inputBuffer, bitWidth);

    *(reinterpret_cast<uint64_t*>(outputBuffer)) = _pdep_u64(val, mask);
    inputBuffer += bitWidth;
    outputBuffer += 8;
  }
}

/// Unpack numValues number of uint8_t values from inputBuffer. The results will
/// be written to outputBuffer. numValues must be a multiple of 8. The caller
/// needs to make sure the inputBufferLen contains at least numValues number of
/// packed values.
inline void unpack(
    uint8_t bitWidth,
    const uint8_t*& inputBuffer,
    uint64_t inputBufferLen,
    uint64_t numValues,
    uint16_t*& outputBuffer) {
  DWIO_ENSURE(bitWidth >= 1 && bitWidth <= 16);
  DWIO_ENSURE((numValues & 0x7) == 0);
  DWIO_ENSURE(inputBufferLen * 8 >= bitWidth * numValues);

  switch (bitWidth) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      unpack5to8(bitWidth, inputBuffer, numValues, outputBuffer);
      break;
    case 8:
      unpack8_cast(inputBuffer, numValues, outputBuffer);
      break;
    case 9:
    case 11:
    case 13:
    case 15:
    case 10:
    case 12:
    case 14:
      unpack9to15(bitWidth, inputBuffer, numValues, outputBuffer);
      break;
    case 16:
      unpack16(inputBuffer, numValues, outputBuffer);
      break;
    default:
      DWIO_RAISE("invalid bitWidth");
  }
}

/// Unpack numValues number of uint8_t values from inputBuffer. The results will
/// be written to outputBuffer. numValues must be a multiple of 8. The caller
/// needs to make sure the inputBufferLen contains at least numValues number of
/// packed values.
inline void unpack(
    uint8_t bitWidth,
    const uint8_t*& inputBuffer,
    uint64_t inputBufferLen,
    uint64_t numValues,
    uint32_t*& outputBuffer) {
  DWIO_ENSURE(bitWidth >= 1 && bitWidth <= 32);
  DWIO_ENSURE((numValues & 0x7) == 0);
  DWIO_ENSURE(inputBufferLen * 8 >= bitWidth * numValues);

  switch (bitWidth) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      unpack1to7(bitWidth, inputBuffer, numValues, outputBuffer);
      break;
    case 8:
      unpack8(inputBuffer, numValues, outputBuffer);
      break;
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      unpack9to15(bitWidth, inputBuffer, numValues, outputBuffer);
      break;
    case 16:
      unpack16(inputBuffer, numValues, outputBuffer);
      break;
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
      unpack17to21(bitWidth, inputBuffer, numValues, outputBuffer);
      break;
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
      unpack22to31(bitWidth, inputBuffer, numValues, outputBuffer);
      break;
    case 32:
      unpack32(inputBuffer, numValues, outputBuffer);
      break;
    default:
      DWIO_RAISE("invalid bitWidth");
  }
}

void generatePdepMasks(uint8_t outBitWidth) {
  uint8_t numBatches = 64 / outBitWidth;
  for (uint8_t i = 0; i <= outBitWidth; i++) {
    uint64_t mask = (1l << i) - 1;
    uint64_t val = mask;
    for (uint8_t j = 1; j < numBatches; j++) {
      val = (val << outBitWidth) | mask;
    }
    std::cout << "0x" << std::hex << std::setfill('0') << std::setw(16) << val
              << ", ";
  }
  std::cout << std::endl;
}
} // namespace facebook::velox::dwio::common

#else
namespace facebook::velox::dwio::common {

inline void unpack(
    uint8_t bitWidth,
    const uint8_t*& inputBuffer,
    uint64_t inputBufferLen,
    uint64_t numValues,
    uint8_t*& outputBuffer) {
  DWIO_ENSURE(bitWidth >= 1 && bitWidth <= 8);
  DWIO_ENSURE((numValues & 0x7) == 0);
  DWIO_ENSURE(inputBufferLen * 8 >= bitWidth * numValues);

  VELOX_NYI();
}

inline void unpack(
    uint8_t bitWidth,
    const uint8_t*& inputBuffer,
    uint64_t inputBufferLen,
    uint64_t numValues,
    uint16_t*& outputBuffer) {
  DWIO_ENSURE(bitWidth >= 1 && bitWidth <= 16);
  DWIO_ENSURE((numValues & 0x7) == 0);
  DWIO_ENSURE(inputBufferLen * 8 >= bitWidth * numValues);

  VELOX_NYI();
}

inline void unpack(
    uint8_t bitWidth,
    const uint8_t*& inputBuffer,
    uint64_t inputBufferLen,
    uint64_t numValues,
    uint32_t*& outputBuffer) {
  DWIO_ENSURE(bitWidth >= 1 && bitWidth <= 16);
  DWIO_ENSURE((numValues & 0x7) == 0);
  DWIO_ENSURE(inputBufferLen * 8 >= bitWidth * numValues);

  VELOX_NYI();
}

} // namespace facebook::velox::dwio::common

#endif