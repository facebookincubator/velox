/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Autogenerated by Thrift Compiler (0.18.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "parquet_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h> // @manual

namespace facebook::velox::parquet::arrow::format {

int _kTypeValues[] = {
    Type::BOOLEAN,
    Type::INT32,
    Type::INT64,
    Type::INT96,
    Type::FLOAT,
    Type::DOUBLE,
    Type::BYTE_ARRAY,
    Type::FIXED_LEN_BYTE_ARRAY};
const char* _kTypeNames[] = {
    "BOOLEAN",
    "INT32",
    "INT64",
    "INT96",
    "FLOAT",
    "DOUBLE",
    "BYTE_ARRAY",
    "FIXED_LEN_BYTE_ARRAY"};
const std::map<int, const char*> _Type_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(8, _kTypeValues, _kTypeNames),
    ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Type::type& val) {
  std::map<int, const char*>::const_iterator it =
      _Type_VALUES_TO_NAMES.find(val);
  if (it != _Type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Type::type& val) {
  std::map<int, const char*>::const_iterator it =
      _Type_VALUES_TO_NAMES.find(val);
  if (it != _Type_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kConvertedTypeValues[] = {
    /**
     * a BYTE_ARRAY actually contains UTF8 encoded chars
     */
    ConvertedType::UTF8,
    /**
     * a map is converted as an optional field containing a repeated key/value
     * pair
     */
    ConvertedType::MAP,
    /**
     * a key/value pair is converted into a group of two fields
     */
    ConvertedType::MAP_KEY_VALUE,
    /**
     * a list is converted into an optional field containing a repeated field
     * for its values
     */
    ConvertedType::LIST,
    /**
     * an enum is converted into a binary field
     */
    ConvertedType::ENUM,
    /**
     * A decimal value.
     *
     * This may be used to annotate binary or fixed primitive types. The
     * underlying byte array stores the unscaled value encoded as two's
     * complement using big-endian byte order (the most significant byte is the
     * zeroth element). The value of the decimal is the value * 10^{-scale}.
     *
     * This must be accompanied by a (maximum) precision and a scale in the
     * SchemaElement. The precision specifies the number of digits in the
     * decimal and the scale stores the location of the decimal point. For
     * example 1.23 would have precision 3 (3 total digits) and scale 2 (the
     * decimal point is 2 digits over).
     */
    ConvertedType::DECIMAL,
    /**
     * A Date
     *
     * Stored as days since Unix epoch, encoded as the INT32 physical type.
     *
     */
    ConvertedType::DATE,
    /**
     * A time
     *
     * The total number of milliseconds since midnight.  The value is stored
     * as an INT32 physical type.
     */
    ConvertedType::TIME_MILLIS,
    /**
     * A time.
     *
     * The total number of microseconds since midnight.  The value is stored as
     * an INT64 physical type.
     */
    ConvertedType::TIME_MICROS,
    /**
     * A date/time combination
     *
     * Date and time recorded as milliseconds since the Unix epoch.  Recorded as
     * a physical type of INT64.
     */
    ConvertedType::TIMESTAMP_MILLIS,
    /**
     * A date/time combination
     *
     * Date and time recorded as microseconds since the Unix epoch.  The value
     * is stored as an INT64 physical type.
     */
    ConvertedType::TIMESTAMP_MICROS,
    /**
     * An unsigned integer value.
     *
     * The number describes the maximum number of meaningful data bits in
     * the stored value. 8, 16 and 32 bit values are stored using the
     * INT32 physical type.  64 bit values are stored using the INT64
     * physical type.
     *
     */
    ConvertedType::UINT_8,
    ConvertedType::UINT_16,
    ConvertedType::UINT_32,
    ConvertedType::UINT_64,
    /**
     * A signed integer value.
     *
     * The number describes the maximum number of meaningful data bits in
     * the stored value. 8, 16 and 32 bit values are stored using the
     * INT32 physical type.  64 bit values are stored using the INT64
     * physical type.
     *
     */
    ConvertedType::INT_8,
    ConvertedType::INT_16,
    ConvertedType::INT_32,
    ConvertedType::INT_64,
    /**
     * An embedded JSON document
     *
     * A JSON document embedded within a single UTF8 column.
     */
    ConvertedType::JSON,
    /**
     * An embedded BSON document
     *
     * A BSON document embedded within a single BINARY column.
     */
    ConvertedType::BSON,
    /**
     * An interval of time
     *
     * This type annotates data stored as a FIXED_LEN_BYTE_ARRAY of length 12
     * This data is composed of three separate little endian unsigned
     * integers.  Each stores a component of a duration of time.  The first
     * integer identifies the number of months associated with the duration,
     * the second identifies the number of days associated with the duration
     * and the third identifies the number of milliseconds associated with
     * the provided duration.  This duration of time is independent of any
     * particular timezone or date.
     */
    ConvertedType::INTERVAL};
const char* _kConvertedTypeNames[] = {
    /**
     * a BYTE_ARRAY actually contains UTF8 encoded chars
     */
    "UTF8",
    /**
     * a map is converted as an optional field containing a repeated key/value
     * pair
     */
    "MAP",
    /**
     * a key/value pair is converted into a group of two fields
     */
    "MAP_KEY_VALUE",
    /**
     * a list is converted into an optional field containing a repeated field
     * for its values
     */
    "LIST",
    /**
     * an enum is converted into a binary field
     */
    "ENUM",
    /**
     * A decimal value.
     *
     * This may be used to annotate binary or fixed primitive types. The
     * underlying byte array stores the unscaled value encoded as two's
     * complement using big-endian byte order (the most significant byte is the
     * zeroth element). The value of the decimal is the value * 10^{-scale}.
     *
     * This must be accompanied by a (maximum) precision and a scale in the
     * SchemaElement. The precision specifies the number of digits in the
     * decimal and the scale stores the location of the decimal point. For
     * example 1.23 would have precision 3 (3 total digits) and scale 2 (the
     * decimal point is 2 digits over).
     */
    "DECIMAL",
    /**
     * A Date
     *
     * Stored as days since Unix epoch, encoded as the INT32 physical type.
     *
     */
    "DATE",
    /**
     * A time
     *
     * The total number of milliseconds since midnight.  The value is stored
     * as an INT32 physical type.
     */
    "TIME_MILLIS",
    /**
     * A time.
     *
     * The total number of microseconds since midnight.  The value is stored as
     * an INT64 physical type.
     */
    "TIME_MICROS",
    /**
     * A date/time combination
     *
     * Date and time recorded as milliseconds since the Unix epoch.  Recorded as
     * a physical type of INT64.
     */
    "TIMESTAMP_MILLIS",
    /**
     * A date/time combination
     *
     * Date and time recorded as microseconds since the Unix epoch.  The value
     * is stored as an INT64 physical type.
     */
    "TIMESTAMP_MICROS",
    /**
     * An unsigned integer value.
     *
     * The number describes the maximum number of meaningful data bits in
     * the stored value. 8, 16 and 32 bit values are stored using the
     * INT32 physical type.  64 bit values are stored using the INT64
     * physical type.
     *
     */
    "UINT_8",
    "UINT_16",
    "UINT_32",
    "UINT_64",
    /**
     * A signed integer value.
     *
     * The number describes the maximum number of meaningful data bits in
     * the stored value. 8, 16 and 32 bit values are stored using the
     * INT32 physical type.  64 bit values are stored using the INT64
     * physical type.
     *
     */
    "INT_8",
    "INT_16",
    "INT_32",
    "INT_64",
    /**
     * An embedded JSON document
     *
     * A JSON document embedded within a single UTF8 column.
     */
    "JSON",
    /**
     * An embedded BSON document
     *
     * A BSON document embedded within a single BINARY column.
     */
    "BSON",
    /**
     * An interval of time
     *
     * This type annotates data stored as a FIXED_LEN_BYTE_ARRAY of length 12
     * This data is composed of three separate little endian unsigned
     * integers.  Each stores a component of a duration of time.  The first
     * integer identifies the number of months associated with the duration,
     * the second identifies the number of days associated with the duration
     * and the third identifies the number of milliseconds associated with
     * the provided duration.  This duration of time is independent of any
     * particular timezone or date.
     */
    "INTERVAL"};
const std::map<int, const char*> _ConvertedType_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(
        22,
        _kConvertedTypeValues,
        _kConvertedTypeNames),
    ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ConvertedType::type& val) {
  std::map<int, const char*>::const_iterator it =
      _ConvertedType_VALUES_TO_NAMES.find(val);
  if (it != _ConvertedType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ConvertedType::type& val) {
  std::map<int, const char*>::const_iterator it =
      _ConvertedType_VALUES_TO_NAMES.find(val);
  if (it != _ConvertedType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFieldRepetitionTypeValues[] = {
    /**
     * This field is required (can not be null) and each record has exactly 1
     * value.
     */
    FieldRepetitionType::REQUIRED,
    /**
     * The field is optional (can be null) and each record has 0 or 1 values.
     */
    FieldRepetitionType::OPTIONAL,
    /**
     * The field is repeated and can contain 0 or more values
     */
    FieldRepetitionType::REPEATED};
const char* _kFieldRepetitionTypeNames[] = {
    /**
     * This field is required (can not be null) and each record has exactly 1
     * value.
     */
    "REQUIRED",
    /**
     * The field is optional (can be null) and each record has 0 or 1 values.
     */
    "OPTIONAL",
    /**
     * The field is repeated and can contain 0 or more values
     */
    "REPEATED"};
const std::map<int, const char*> _FieldRepetitionType_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(
        3,
        _kFieldRepetitionTypeValues,
        _kFieldRepetitionTypeNames),
    ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(
    std::ostream& out,
    const FieldRepetitionType::type& val) {
  std::map<int, const char*>::const_iterator it =
      _FieldRepetitionType_VALUES_TO_NAMES.find(val);
  if (it != _FieldRepetitionType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const FieldRepetitionType::type& val) {
  std::map<int, const char*>::const_iterator it =
      _FieldRepetitionType_VALUES_TO_NAMES.find(val);
  if (it != _FieldRepetitionType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kEncodingValues[] = {
    /**
     * Default encoding.
     * BOOLEAN - 1 bit per value. 0 is false; 1 is true.
     * INT32 - 4 bytes per value.  Stored as little-endian.
     * INT64 - 8 bytes per value.  Stored as little-endian.
     * FLOAT - 4 bytes per value.  IEEE. Stored as little-endian.
     * DOUBLE - 8 bytes per value.  IEEE. Stored as little-endian.
     * BYTE_ARRAY - 4 byte length stored as little endian, followed by bytes.
     * FIXED_LEN_BYTE_ARRAY - Just the bytes.
     */
    Encoding::PLAIN,
    /**
     * Deprecated: Dictionary encoding. The values in the dictionary are encoded
     * in the plain type. in a data page use RLE_DICTIONARY instead. in a
     * Dictionary page use PLAIN instead
     */
    Encoding::PLAIN_DICTIONARY,
    /**
     * Group packed run length encoding. Usable for definition/repetition levels
     * encoding and Booleans (on one bit: 0 is false; 1 is true.)
     */
    Encoding::RLE,
    /**
     * Bit packed encoding.  This can only be used if the data has a known max
     * width.  Usable for definition/repetition levels encoding.
     */
    Encoding::BIT_PACKED,
    /**
     * Delta encoding for integers. This can be used for int columns and works
     * best on sorted data
     */
    Encoding::DELTA_BINARY_PACKED,
    /**
     * Encoding for byte arrays to separate the length values and the data. The
     * lengths are encoded using DELTA_BINARY_PACKED
     */
    Encoding::DELTA_LENGTH_BYTE_ARRAY,
    /**
     * Incremental-encoded byte array. Prefix lengths are encoded using
     * DELTA_BINARY_PACKED. Suffixes are stored as delta length byte arrays.
     */
    Encoding::DELTA_BYTE_ARRAY,
    /**
     * Dictionary encoding: the ids are encoded using the RLE encoding
     */
    Encoding::RLE_DICTIONARY,
    /**
     * Encoding for floating-point data.
     * K byte-streams are created where K is the size in bytes of the data type.
     * The individual bytes of an FP value are scattered to the corresponding
     * stream and the streams are concatenated. This itself does not reduce the
     * size of the data but can lead to better compression afterwards.
     */
    Encoding::BYTE_STREAM_SPLIT};
const char* _kEncodingNames[] = {
    /**
     * Default encoding.
     * BOOLEAN - 1 bit per value. 0 is false; 1 is true.
     * INT32 - 4 bytes per value.  Stored as little-endian.
     * INT64 - 8 bytes per value.  Stored as little-endian.
     * FLOAT - 4 bytes per value.  IEEE. Stored as little-endian.
     * DOUBLE - 8 bytes per value.  IEEE. Stored as little-endian.
     * BYTE_ARRAY - 4 byte length stored as little endian, followed by bytes.
     * FIXED_LEN_BYTE_ARRAY - Just the bytes.
     */
    "PLAIN",
    /**
     * Deprecated: Dictionary encoding. The values in the dictionary are encoded
     * in the plain type. in a data page use RLE_DICTIONARY instead. in a
     * Dictionary page use PLAIN instead
     */
    "PLAIN_DICTIONARY",
    /**
     * Group packed run length encoding. Usable for definition/repetition levels
     * encoding and Booleans (on one bit: 0 is false; 1 is true.)
     */
    "RLE",
    /**
     * Bit packed encoding.  This can only be used if the data has a known max
     * width.  Usable for definition/repetition levels encoding.
     */
    "BIT_PACKED",
    /**
     * Delta encoding for integers. This can be used for int columns and works
     * best on sorted data
     */
    "DELTA_BINARY_PACKED",
    /**
     * Encoding for byte arrays to separate the length values and the data. The
     * lengths are encoded using DELTA_BINARY_PACKED
     */
    "DELTA_LENGTH_BYTE_ARRAY",
    /**
     * Incremental-encoded byte array. Prefix lengths are encoded using
     * DELTA_BINARY_PACKED. Suffixes are stored as delta length byte arrays.
     */
    "DELTA_BYTE_ARRAY",
    /**
     * Dictionary encoding: the ids are encoded using the RLE encoding
     */
    "RLE_DICTIONARY",
    /**
     * Encoding for floating-point data.
     * K byte-streams are created where K is the size in bytes of the data type.
     * The individual bytes of an FP value are scattered to the corresponding
     * stream and the streams are concatenated. This itself does not reduce the
     * size of the data but can lead to better compression afterwards.
     */
    "BYTE_STREAM_SPLIT"};
const std::map<int, const char*> _Encoding_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(9, _kEncodingValues, _kEncodingNames),
    ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Encoding::type& val) {
  std::map<int, const char*>::const_iterator it =
      _Encoding_VALUES_TO_NAMES.find(val);
  if (it != _Encoding_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Encoding::type& val) {
  std::map<int, const char*>::const_iterator it =
      _Encoding_VALUES_TO_NAMES.find(val);
  if (it != _Encoding_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCompressionCodecValues[] = {
    CompressionCodec::UNCOMPRESSED,
    CompressionCodec::SNAPPY,
    CompressionCodec::GZIP,
    CompressionCodec::LZO,
    CompressionCodec::BROTLI,
    CompressionCodec::LZ4,
    CompressionCodec::ZSTD,
    CompressionCodec::LZ4_RAW};
const char* _kCompressionCodecNames[] = {
    "UNCOMPRESSED",
    "SNAPPY",
    "GZIP",
    "LZO",
    "BROTLI",
    "LZ4",
    "ZSTD",
    "LZ4_RAW"};
const std::map<int, const char*> _CompressionCodec_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(
        8,
        _kCompressionCodecValues,
        _kCompressionCodecNames),
    ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const CompressionCodec::type& val) {
  std::map<int, const char*>::const_iterator it =
      _CompressionCodec_VALUES_TO_NAMES.find(val);
  if (it != _CompressionCodec_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CompressionCodec::type& val) {
  std::map<int, const char*>::const_iterator it =
      _CompressionCodec_VALUES_TO_NAMES.find(val);
  if (it != _CompressionCodec_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPageTypeValues[] = {
    PageType::DATA_PAGE,
    PageType::INDEX_PAGE,
    PageType::DICTIONARY_PAGE,
    PageType::DATA_PAGE_V2};
const char* _kPageTypeNames[] = {
    "DATA_PAGE",
    "INDEX_PAGE",
    "DICTIONARY_PAGE",
    "DATA_PAGE_V2"};
const std::map<int, const char*> _PageType_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(4, _kPageTypeValues, _kPageTypeNames),
    ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const PageType::type& val) {
  std::map<int, const char*>::const_iterator it =
      _PageType_VALUES_TO_NAMES.find(val);
  if (it != _PageType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PageType::type& val) {
  std::map<int, const char*>::const_iterator it =
      _PageType_VALUES_TO_NAMES.find(val);
  if (it != _PageType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kBoundaryOrderValues[] = {
    BoundaryOrder::UNORDERED,
    BoundaryOrder::ASCENDING,
    BoundaryOrder::DESCENDING};
const char* _kBoundaryOrderNames[] = {"UNORDERED", "ASCENDING", "DESCENDING"};
const std::map<int, const char*> _BoundaryOrder_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(
        3,
        _kBoundaryOrderValues,
        _kBoundaryOrderNames),
    ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const BoundaryOrder::type& val) {
  std::map<int, const char*>::const_iterator it =
      _BoundaryOrder_VALUES_TO_NAMES.find(val);
  if (it != _BoundaryOrder_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const BoundaryOrder::type& val) {
  std::map<int, const char*>::const_iterator it =
      _BoundaryOrder_VALUES_TO_NAMES.find(val);
  if (it != _BoundaryOrder_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

Statistics::~Statistics() noexcept {}

void Statistics::__set_max(const std::string& val) {
  this->max = val;
  __isset.max = true;
}

void Statistics::__set_min(const std::string& val) {
  this->min = val;
  __isset.min = true;
}

void Statistics::__set_null_count(const int64_t val) {
  this->null_count = val;
  __isset.null_count = true;
}

void Statistics::__set_distinct_count(const int64_t val) {
  this->distinct_count = val;
  __isset.distinct_count = true;
}

void Statistics::__set_max_value(const std::string& val) {
  this->max_value = val;
  __isset.max_value = true;
}

void Statistics::__set_min_value(const std::string& val) {
  this->min_value = val;
  __isset.min_value = true;
}
std::ostream& operator<<(std::ostream& out, const Statistics& obj) {
  obj.printTo(out);
  return out;
}

uint32_t Statistics::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->null_count);
          this->__isset.null_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->distinct_count);
          this->__isset.distinct_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->max_value);
          this->__isset.max_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->min_value);
          this->__isset.min_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Statistics::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Statistics");

  if (this->__isset.max) {
    xfer +=
        oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->max);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.min) {
    xfer +=
        oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->min);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.null_count) {
    xfer += oprot->writeFieldBegin(
        "null_count", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->null_count);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.distinct_count) {
    xfer += oprot->writeFieldBegin(
        "distinct_count", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->distinct_count);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_value) {
    xfer += oprot->writeFieldBegin(
        "max_value", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->max_value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.min_value) {
    xfer += oprot->writeFieldBegin(
        "min_value", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeBinary(this->min_value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Statistics& a, Statistics& b) {
  using ::std::swap;
  swap(a.max, b.max);
  swap(a.min, b.min);
  swap(a.null_count, b.null_count);
  swap(a.distinct_count, b.distinct_count);
  swap(a.max_value, b.max_value);
  swap(a.min_value, b.min_value);
  swap(a.__isset, b.__isset);
}

Statistics::Statistics(const Statistics& other0) {
  max = other0.max;
  min = other0.min;
  null_count = other0.null_count;
  distinct_count = other0.distinct_count;
  max_value = other0.max_value;
  min_value = other0.min_value;
  __isset = other0.__isset;
}
Statistics::Statistics(Statistics&& other1) noexcept {
  max = std::move(other1.max);
  min = std::move(other1.min);
  null_count = other1.null_count;
  distinct_count = other1.distinct_count;
  max_value = std::move(other1.max_value);
  min_value = std::move(other1.min_value);
  __isset = other1.__isset;
}
Statistics& Statistics::operator=(const Statistics& other2) {
  max = other2.max;
  min = other2.min;
  null_count = other2.null_count;
  distinct_count = other2.distinct_count;
  max_value = other2.max_value;
  min_value = other2.min_value;
  __isset = other2.__isset;
  return *this;
}
Statistics& Statistics::operator=(Statistics&& other3) noexcept {
  max = std::move(other3.max);
  min = std::move(other3.min);
  null_count = other3.null_count;
  distinct_count = other3.distinct_count;
  max_value = std::move(other3.max_value);
  min_value = std::move(other3.min_value);
  __isset = other3.__isset;
  return *this;
}
void Statistics::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Statistics(";
  out << "max=";
  (__isset.max ? (out << to_string(max)) : (out << "<null>"));
  out << ", "
      << "min=";
  (__isset.min ? (out << to_string(min)) : (out << "<null>"));
  out << ", "
      << "null_count=";
  (__isset.null_count ? (out << to_string(null_count)) : (out << "<null>"));
  out << ", "
      << "distinct_count=";
  (__isset.distinct_count ? (out << to_string(distinct_count))
                          : (out << "<null>"));
  out << ", "
      << "max_value=";
  (__isset.max_value ? (out << to_string(max_value)) : (out << "<null>"));
  out << ", "
      << "min_value=";
  (__isset.min_value ? (out << to_string(min_value)) : (out << "<null>"));
  out << ")";
}

StringType::~StringType() noexcept {}

std::ostream& operator<<(std::ostream& out, const StringType& obj) {
  obj.printTo(out);
  return out;
}

uint32_t StringType::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StringType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StringType");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StringType& a, StringType& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

StringType::StringType(const StringType& other4) noexcept {
  (void)other4;
}
StringType::StringType(StringType&& other5) noexcept {
  (void)other5;
}
StringType& StringType::operator=(const StringType& other6) noexcept {
  (void)other6;
  return *this;
}
StringType& StringType::operator=(StringType&& other7) noexcept {
  (void)other7;
  return *this;
}
void StringType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StringType(";
  out << ")";
}

UUIDType::~UUIDType() noexcept {}

std::ostream& operator<<(std::ostream& out, const UUIDType& obj) {
  obj.printTo(out);
  return out;
}

uint32_t UUIDType::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UUIDType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UUIDType");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UUIDType& a, UUIDType& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

UUIDType::UUIDType(const UUIDType& other8) noexcept {
  (void)other8;
}
UUIDType::UUIDType(UUIDType&& other9) noexcept {
  (void)other9;
}
UUIDType& UUIDType::operator=(const UUIDType& other10) noexcept {
  (void)other10;
  return *this;
}
UUIDType& UUIDType::operator=(UUIDType&& other11) noexcept {
  (void)other11;
  return *this;
}
void UUIDType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UUIDType(";
  out << ")";
}

MapType::~MapType() noexcept {}

std::ostream& operator<<(std::ostream& out, const MapType& obj) {
  obj.printTo(out);
  return out;
}

uint32_t MapType::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MapType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MapType");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MapType& a, MapType& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

MapType::MapType(const MapType& other12) noexcept {
  (void)other12;
}
MapType::MapType(MapType&& other13) noexcept {
  (void)other13;
}
MapType& MapType::operator=(const MapType& other14) noexcept {
  (void)other14;
  return *this;
}
MapType& MapType::operator=(MapType&& other15) noexcept {
  (void)other15;
  return *this;
}
void MapType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MapType(";
  out << ")";
}

ListType::~ListType() noexcept {}

std::ostream& operator<<(std::ostream& out, const ListType& obj) {
  obj.printTo(out);
  return out;
}

uint32_t ListType::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListType");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListType& a, ListType& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

ListType::ListType(const ListType& other16) noexcept {
  (void)other16;
}
ListType::ListType(ListType&& other17) noexcept {
  (void)other17;
}
ListType& ListType::operator=(const ListType& other18) noexcept {
  (void)other18;
  return *this;
}
ListType& ListType::operator=(ListType&& other19) noexcept {
  (void)other19;
  return *this;
}
void ListType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListType(";
  out << ")";
}

EnumType::~EnumType() noexcept {}

std::ostream& operator<<(std::ostream& out, const EnumType& obj) {
  obj.printTo(out);
  return out;
}

uint32_t EnumType::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EnumType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EnumType");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EnumType& a, EnumType& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

EnumType::EnumType(const EnumType& other20) noexcept {
  (void)other20;
}
EnumType::EnumType(EnumType&& other21) noexcept {
  (void)other21;
}
EnumType& EnumType::operator=(const EnumType& other22) noexcept {
  (void)other22;
  return *this;
}
EnumType& EnumType::operator=(EnumType&& other23) noexcept {
  (void)other23;
  return *this;
}
void EnumType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EnumType(";
  out << ")";
}

DateType::~DateType() noexcept {}

std::ostream& operator<<(std::ostream& out, const DateType& obj) {
  obj.printTo(out);
  return out;
}

uint32_t DateType::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DateType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DateType");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DateType& a, DateType& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

DateType::DateType(const DateType& other24) noexcept {
  (void)other24;
}
DateType::DateType(DateType&& other25) noexcept {
  (void)other25;
}
DateType& DateType::operator=(const DateType& other26) noexcept {
  (void)other26;
  return *this;
}
DateType& DateType::operator=(DateType&& other27) noexcept {
  (void)other27;
  return *this;
}
void DateType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DateType(";
  out << ")";
}

NullType::~NullType() noexcept {}

std::ostream& operator<<(std::ostream& out, const NullType& obj) {
  obj.printTo(out);
  return out;
}

uint32_t NullType::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NullType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NullType");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NullType& a, NullType& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

NullType::NullType(const NullType& other28) noexcept {
  (void)other28;
}
NullType::NullType(NullType&& other29) noexcept {
  (void)other29;
}
NullType& NullType::operator=(const NullType& other30) noexcept {
  (void)other30;
  return *this;
}
NullType& NullType::operator=(NullType&& other31) noexcept {
  (void)other31;
  return *this;
}
void NullType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NullType(";
  out << ")";
}

DecimalType::~DecimalType() noexcept {}

void DecimalType::__set_scale(const int32_t val) {
  this->scale = val;
}

void DecimalType::__set_precision(const int32_t val) {
  this->precision = val;
}
std::ostream& operator<<(std::ostream& out, const DecimalType& obj) {
  obj.printTo(out);
  return out;
}

uint32_t DecimalType::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_scale = false;
  bool isset_precision = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scale);
          isset_scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->precision);
          isset_precision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_scale)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_precision)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DecimalType::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DecimalType");

  xfer += oprot->writeFieldBegin("scale", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->scale);
  xfer += oprot->writeFieldEnd();

  xfer +=
      oprot->writeFieldBegin("precision", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->precision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DecimalType& a, DecimalType& b) {
  using ::std::swap;
  swap(a.scale, b.scale);
  swap(a.precision, b.precision);
}

DecimalType::DecimalType(const DecimalType& other32) noexcept {
  scale = other32.scale;
  precision = other32.precision;
}
DecimalType::DecimalType(DecimalType&& other33) noexcept {
  scale = other33.scale;
  precision = other33.precision;
}
DecimalType& DecimalType::operator=(const DecimalType& other34) noexcept {
  scale = other34.scale;
  precision = other34.precision;
  return *this;
}
DecimalType& DecimalType::operator=(DecimalType&& other35) noexcept {
  scale = other35.scale;
  precision = other35.precision;
  return *this;
}
void DecimalType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DecimalType(";
  out << "scale=" << to_string(scale);
  out << ", "
      << "precision=" << to_string(precision);
  out << ")";
}

MilliSeconds::~MilliSeconds() noexcept {}

std::ostream& operator<<(std::ostream& out, const MilliSeconds& obj) {
  obj.printTo(out);
  return out;
}

uint32_t MilliSeconds::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MilliSeconds::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MilliSeconds");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MilliSeconds& a, MilliSeconds& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

MilliSeconds::MilliSeconds(const MilliSeconds& other36) noexcept {
  (void)other36;
}
MilliSeconds::MilliSeconds(MilliSeconds&& other37) noexcept {
  (void)other37;
}
MilliSeconds& MilliSeconds::operator=(const MilliSeconds& other38) noexcept {
  (void)other38;
  return *this;
}
MilliSeconds& MilliSeconds::operator=(MilliSeconds&& other39) noexcept {
  (void)other39;
  return *this;
}
void MilliSeconds::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MilliSeconds(";
  out << ")";
}

MicroSeconds::~MicroSeconds() noexcept {}

std::ostream& operator<<(std::ostream& out, const MicroSeconds& obj) {
  obj.printTo(out);
  return out;
}

uint32_t MicroSeconds::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MicroSeconds::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MicroSeconds");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MicroSeconds& a, MicroSeconds& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

MicroSeconds::MicroSeconds(const MicroSeconds& other40) noexcept {
  (void)other40;
}
MicroSeconds::MicroSeconds(MicroSeconds&& other41) noexcept {
  (void)other41;
}
MicroSeconds& MicroSeconds::operator=(const MicroSeconds& other42) noexcept {
  (void)other42;
  return *this;
}
MicroSeconds& MicroSeconds::operator=(MicroSeconds&& other43) noexcept {
  (void)other43;
  return *this;
}
void MicroSeconds::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MicroSeconds(";
  out << ")";
}

NanoSeconds::~NanoSeconds() noexcept {}

std::ostream& operator<<(std::ostream& out, const NanoSeconds& obj) {
  obj.printTo(out);
  return out;
}

uint32_t NanoSeconds::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NanoSeconds::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NanoSeconds");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NanoSeconds& a, NanoSeconds& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

NanoSeconds::NanoSeconds(const NanoSeconds& other44) noexcept {
  (void)other44;
}
NanoSeconds::NanoSeconds(NanoSeconds&& other45) noexcept {
  (void)other45;
}
NanoSeconds& NanoSeconds::operator=(const NanoSeconds& other46) noexcept {
  (void)other46;
  return *this;
}
NanoSeconds& NanoSeconds::operator=(NanoSeconds&& other47) noexcept {
  (void)other47;
  return *this;
}
void NanoSeconds::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NanoSeconds(";
  out << ")";
}

TimeUnit::~TimeUnit() noexcept {}

void TimeUnit::__set_MILLIS(const MilliSeconds& val) {
  this->MILLIS = val;
  __isset.MILLIS = true;
}

void TimeUnit::__set_MICROS(const MicroSeconds& val) {
  this->MICROS = val;
  __isset.MICROS = true;
}

void TimeUnit::__set_NANOS(const NanoSeconds& val) {
  this->NANOS = val;
  __isset.NANOS = true;
}
std::ostream& operator<<(std::ostream& out, const TimeUnit& obj) {
  obj.printTo(out);
  return out;
}

uint32_t TimeUnit::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->MILLIS.read(iprot);
          this->__isset.MILLIS = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->MICROS.read(iprot);
          this->__isset.MICROS = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->NANOS.read(iprot);
          this->__isset.NANOS = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimeUnit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimeUnit");

  if (this->__isset.MILLIS) {
    xfer += oprot->writeFieldBegin(
        "MILLIS", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->MILLIS.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.MICROS) {
    xfer += oprot->writeFieldBegin(
        "MICROS", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->MICROS.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.NANOS) {
    xfer += oprot->writeFieldBegin(
        "NANOS", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->NANOS.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimeUnit& a, TimeUnit& b) {
  using ::std::swap;
  swap(a.MILLIS, b.MILLIS);
  swap(a.MICROS, b.MICROS);
  swap(a.NANOS, b.NANOS);
  swap(a.__isset, b.__isset);
}

TimeUnit::TimeUnit(const TimeUnit& other48) noexcept {
  MILLIS = other48.MILLIS;
  MICROS = other48.MICROS;
  NANOS = other48.NANOS;
  __isset = other48.__isset;
}
TimeUnit::TimeUnit(TimeUnit&& other49) noexcept {
  MILLIS = std::move(other49.MILLIS);
  MICROS = std::move(other49.MICROS);
  NANOS = std::move(other49.NANOS);
  __isset = other49.__isset;
}
TimeUnit& TimeUnit::operator=(const TimeUnit& other50) noexcept {
  MILLIS = other50.MILLIS;
  MICROS = other50.MICROS;
  NANOS = other50.NANOS;
  __isset = other50.__isset;
  return *this;
}
TimeUnit& TimeUnit::operator=(TimeUnit&& other51) noexcept {
  MILLIS = std::move(other51.MILLIS);
  MICROS = std::move(other51.MICROS);
  NANOS = std::move(other51.NANOS);
  __isset = other51.__isset;
  return *this;
}
void TimeUnit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimeUnit(";
  out << "MILLIS=";
  (__isset.MILLIS ? (out << to_string(MILLIS)) : (out << "<null>"));
  out << ", "
      << "MICROS=";
  (__isset.MICROS ? (out << to_string(MICROS)) : (out << "<null>"));
  out << ", "
      << "NANOS=";
  (__isset.NANOS ? (out << to_string(NANOS)) : (out << "<null>"));
  out << ")";
}

TimestampType::~TimestampType() noexcept {}

void TimestampType::__set_isAdjustedToUTC(const bool val) {
  this->isAdjustedToUTC = val;
}

void TimestampType::__set_unit(const TimeUnit& val) {
  this->unit = val;
}
std::ostream& operator<<(std::ostream& out, const TimestampType& obj) {
  obj.printTo(out);
  return out;
}

uint32_t TimestampType::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_isAdjustedToUTC = false;
  bool isset_unit = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAdjustedToUTC);
          isset_isAdjustedToUTC = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->unit.read(iprot);
          isset_unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_isAdjustedToUTC)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_unit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TimestampType::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimestampType");

  xfer += oprot->writeFieldBegin(
      "isAdjustedToUTC", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isAdjustedToUTC);
  xfer += oprot->writeFieldEnd();

  xfer +=
      oprot->writeFieldBegin("unit", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->unit.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimestampType& a, TimestampType& b) {
  using ::std::swap;
  swap(a.isAdjustedToUTC, b.isAdjustedToUTC);
  swap(a.unit, b.unit);
}

TimestampType::TimestampType(const TimestampType& other52) noexcept {
  isAdjustedToUTC = other52.isAdjustedToUTC;
  unit = other52.unit;
}
TimestampType::TimestampType(TimestampType&& other53) noexcept {
  isAdjustedToUTC = other53.isAdjustedToUTC;
  unit = std::move(other53.unit);
}
TimestampType& TimestampType::operator=(const TimestampType& other54) noexcept {
  isAdjustedToUTC = other54.isAdjustedToUTC;
  unit = other54.unit;
  return *this;
}
TimestampType& TimestampType::operator=(TimestampType&& other55) noexcept {
  isAdjustedToUTC = other55.isAdjustedToUTC;
  unit = std::move(other55.unit);
  return *this;
}
void TimestampType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimestampType(";
  out << "isAdjustedToUTC=" << to_string(isAdjustedToUTC);
  out << ", "
      << "unit=" << to_string(unit);
  out << ")";
}

TimeType::~TimeType() noexcept {}

void TimeType::__set_isAdjustedToUTC(const bool val) {
  this->isAdjustedToUTC = val;
}

void TimeType::__set_unit(const TimeUnit& val) {
  this->unit = val;
}
std::ostream& operator<<(std::ostream& out, const TimeType& obj) {
  obj.printTo(out);
  return out;
}

uint32_t TimeType::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_isAdjustedToUTC = false;
  bool isset_unit = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAdjustedToUTC);
          isset_isAdjustedToUTC = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->unit.read(iprot);
          isset_unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_isAdjustedToUTC)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_unit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TimeType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TimeType");

  xfer += oprot->writeFieldBegin(
      "isAdjustedToUTC", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isAdjustedToUTC);
  xfer += oprot->writeFieldEnd();

  xfer +=
      oprot->writeFieldBegin("unit", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->unit.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimeType& a, TimeType& b) {
  using ::std::swap;
  swap(a.isAdjustedToUTC, b.isAdjustedToUTC);
  swap(a.unit, b.unit);
}

TimeType::TimeType(const TimeType& other56) noexcept {
  isAdjustedToUTC = other56.isAdjustedToUTC;
  unit = other56.unit;
}
TimeType::TimeType(TimeType&& other57) noexcept {
  isAdjustedToUTC = other57.isAdjustedToUTC;
  unit = std::move(other57.unit);
}
TimeType& TimeType::operator=(const TimeType& other58) noexcept {
  isAdjustedToUTC = other58.isAdjustedToUTC;
  unit = other58.unit;
  return *this;
}
TimeType& TimeType::operator=(TimeType&& other59) noexcept {
  isAdjustedToUTC = other59.isAdjustedToUTC;
  unit = std::move(other59.unit);
  return *this;
}
void TimeType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimeType(";
  out << "isAdjustedToUTC=" << to_string(isAdjustedToUTC);
  out << ", "
      << "unit=" << to_string(unit);
  out << ")";
}

IntType::~IntType() noexcept {}

void IntType::__set_bitWidth(const int8_t val) {
  this->bitWidth = val;
}

void IntType::__set_isSigned(const bool val) {
  this->isSigned = val;
}
std::ostream& operator<<(std::ostream& out, const IntType& obj) {
  obj.printTo(out);
  return out;
}

uint32_t IntType::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_bitWidth = false;
  bool isset_isSigned = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->bitWidth);
          isset_bitWidth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSigned);
          isset_isSigned = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_bitWidth)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isSigned)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t IntType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IntType");

  xfer +=
      oprot->writeFieldBegin("bitWidth", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->bitWidth);
  xfer += oprot->writeFieldEnd();

  xfer +=
      oprot->writeFieldBegin("isSigned", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isSigned);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IntType& a, IntType& b) {
  using ::std::swap;
  swap(a.bitWidth, b.bitWidth);
  swap(a.isSigned, b.isSigned);
}

IntType::IntType(const IntType& other60) noexcept {
  bitWidth = other60.bitWidth;
  isSigned = other60.isSigned;
}
IntType::IntType(IntType&& other61) noexcept {
  bitWidth = other61.bitWidth;
  isSigned = other61.isSigned;
}
IntType& IntType::operator=(const IntType& other62) noexcept {
  bitWidth = other62.bitWidth;
  isSigned = other62.isSigned;
  return *this;
}
IntType& IntType::operator=(IntType&& other63) noexcept {
  bitWidth = other63.bitWidth;
  isSigned = other63.isSigned;
  return *this;
}
void IntType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IntType(";
  out << "bitWidth=" << to_string(bitWidth);
  out << ", "
      << "isSigned=" << to_string(isSigned);
  out << ")";
}

JsonType::~JsonType() noexcept {}

std::ostream& operator<<(std::ostream& out, const JsonType& obj) {
  obj.printTo(out);
  return out;
}

uint32_t JsonType::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t JsonType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("JsonType");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(JsonType& a, JsonType& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

JsonType::JsonType(const JsonType& other64) noexcept {
  (void)other64;
}
JsonType::JsonType(JsonType&& other65) noexcept {
  (void)other65;
}
JsonType& JsonType::operator=(const JsonType& other66) noexcept {
  (void)other66;
  return *this;
}
JsonType& JsonType::operator=(JsonType&& other67) noexcept {
  (void)other67;
  return *this;
}
void JsonType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "JsonType(";
  out << ")";
}

BsonType::~BsonType() noexcept {}

std::ostream& operator<<(std::ostream& out, const BsonType& obj) {
  obj.printTo(out);
  return out;
}

uint32_t BsonType::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BsonType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BsonType");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BsonType& a, BsonType& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

BsonType::BsonType(const BsonType& other68) noexcept {
  (void)other68;
}
BsonType::BsonType(BsonType&& other69) noexcept {
  (void)other69;
}
BsonType& BsonType::operator=(const BsonType& other70) noexcept {
  (void)other70;
  return *this;
}
BsonType& BsonType::operator=(BsonType&& other71) noexcept {
  (void)other71;
  return *this;
}
void BsonType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BsonType(";
  out << ")";
}

LogicalType::~LogicalType() noexcept {}

void LogicalType::__set_STRING(const StringType& val) {
  this->STRING = val;
  __isset.STRING = true;
}

void LogicalType::__set_MAP(const MapType& val) {
  this->MAP = val;
  __isset.MAP = true;
}

void LogicalType::__set_LIST(const ListType& val) {
  this->LIST = val;
  __isset.LIST = true;
}

void LogicalType::__set_ENUM(const EnumType& val) {
  this->ENUM = val;
  __isset.ENUM = true;
}

void LogicalType::__set_DECIMAL(const DecimalType& val) {
  this->DECIMAL = val;
  __isset.DECIMAL = true;
}

void LogicalType::__set_DATE(const DateType& val) {
  this->DATE = val;
  __isset.DATE = true;
}

void LogicalType::__set_TIME(const TimeType& val) {
  this->TIME = val;
  __isset.TIME = true;
}

void LogicalType::__set_TIMESTAMP(const TimestampType& val) {
  this->TIMESTAMP = val;
  __isset.TIMESTAMP = true;
}

void LogicalType::__set_INTEGER(const IntType& val) {
  this->INTEGER = val;
  __isset.INTEGER = true;
}

void LogicalType::__set_UNKNOWN(const NullType& val) {
  this->UNKNOWN = val;
  __isset.UNKNOWN = true;
}

void LogicalType::__set_JSON(const JsonType& val) {
  this->JSON = val;
  __isset.JSON = true;
}

void LogicalType::__set_BSON(const BsonType& val) {
  this->BSON = val;
  __isset.BSON = true;
}

void LogicalType::__set_UUID(const UUIDType& val) {
  this->UUID = val;
  __isset.UUID = true;
}
std::ostream& operator<<(std::ostream& out, const LogicalType& obj) {
  obj.printTo(out);
  return out;
}

uint32_t LogicalType::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->STRING.read(iprot);
          this->__isset.STRING = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->MAP.read(iprot);
          this->__isset.MAP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->LIST.read(iprot);
          this->__isset.LIST = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ENUM.read(iprot);
          this->__isset.ENUM = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->DECIMAL.read(iprot);
          this->__isset.DECIMAL = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->DATE.read(iprot);
          this->__isset.DATE = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->TIME.read(iprot);
          this->__isset.TIME = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->TIMESTAMP.read(iprot);
          this->__isset.TIMESTAMP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->INTEGER.read(iprot);
          this->__isset.INTEGER = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->UNKNOWN.read(iprot);
          this->__isset.UNKNOWN = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->JSON.read(iprot);
          this->__isset.JSON = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->BSON.read(iprot);
          this->__isset.BSON = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->UUID.read(iprot);
          this->__isset.UUID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LogicalType::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LogicalType");

  if (this->__isset.STRING) {
    xfer += oprot->writeFieldBegin(
        "STRING", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->STRING.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.MAP) {
    xfer +=
        oprot->writeFieldBegin("MAP", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->MAP.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.LIST) {
    xfer +=
        oprot->writeFieldBegin("LIST", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->LIST.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ENUM) {
    xfer +=
        oprot->writeFieldBegin("ENUM", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->ENUM.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.DECIMAL) {
    xfer += oprot->writeFieldBegin(
        "DECIMAL", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->DECIMAL.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.DATE) {
    xfer +=
        oprot->writeFieldBegin("DATE", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->DATE.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.TIME) {
    xfer +=
        oprot->writeFieldBegin("TIME", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->TIME.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.TIMESTAMP) {
    xfer += oprot->writeFieldBegin(
        "TIMESTAMP", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->TIMESTAMP.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.INTEGER) {
    xfer += oprot->writeFieldBegin(
        "INTEGER", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->INTEGER.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.UNKNOWN) {
    xfer += oprot->writeFieldBegin(
        "UNKNOWN", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->UNKNOWN.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.JSON) {
    xfer += oprot->writeFieldBegin(
        "JSON", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->JSON.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.BSON) {
    xfer += oprot->writeFieldBegin(
        "BSON", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->BSON.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.UUID) {
    xfer += oprot->writeFieldBegin(
        "UUID", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->UUID.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LogicalType& a, LogicalType& b) {
  using ::std::swap;
  swap(a.STRING, b.STRING);
  swap(a.MAP, b.MAP);
  swap(a.LIST, b.LIST);
  swap(a.ENUM, b.ENUM);
  swap(a.DECIMAL, b.DECIMAL);
  swap(a.DATE, b.DATE);
  swap(a.TIME, b.TIME);
  swap(a.TIMESTAMP, b.TIMESTAMP);
  swap(a.INTEGER, b.INTEGER);
  swap(a.UNKNOWN, b.UNKNOWN);
  swap(a.JSON, b.JSON);
  swap(a.BSON, b.BSON);
  swap(a.UUID, b.UUID);
  swap(a.__isset, b.__isset);
}

LogicalType::LogicalType(const LogicalType& other72) noexcept {
  STRING = other72.STRING;
  MAP = other72.MAP;
  LIST = other72.LIST;
  ENUM = other72.ENUM;
  DECIMAL = other72.DECIMAL;
  DATE = other72.DATE;
  TIME = other72.TIME;
  TIMESTAMP = other72.TIMESTAMP;
  INTEGER = other72.INTEGER;
  UNKNOWN = other72.UNKNOWN;
  JSON = other72.JSON;
  BSON = other72.BSON;
  UUID = other72.UUID;
  __isset = other72.__isset;
}
LogicalType::LogicalType(LogicalType&& other73) noexcept {
  STRING = std::move(other73.STRING);
  MAP = std::move(other73.MAP);
  LIST = std::move(other73.LIST);
  ENUM = std::move(other73.ENUM);
  DECIMAL = std::move(other73.DECIMAL);
  DATE = std::move(other73.DATE);
  TIME = std::move(other73.TIME);
  TIMESTAMP = std::move(other73.TIMESTAMP);
  INTEGER = std::move(other73.INTEGER);
  UNKNOWN = std::move(other73.UNKNOWN);
  JSON = std::move(other73.JSON);
  BSON = std::move(other73.BSON);
  UUID = std::move(other73.UUID);
  __isset = other73.__isset;
}
LogicalType& LogicalType::operator=(const LogicalType& other74) noexcept {
  STRING = other74.STRING;
  MAP = other74.MAP;
  LIST = other74.LIST;
  ENUM = other74.ENUM;
  DECIMAL = other74.DECIMAL;
  DATE = other74.DATE;
  TIME = other74.TIME;
  TIMESTAMP = other74.TIMESTAMP;
  INTEGER = other74.INTEGER;
  UNKNOWN = other74.UNKNOWN;
  JSON = other74.JSON;
  BSON = other74.BSON;
  UUID = other74.UUID;
  __isset = other74.__isset;
  return *this;
}
LogicalType& LogicalType::operator=(LogicalType&& other75) noexcept {
  STRING = std::move(other75.STRING);
  MAP = std::move(other75.MAP);
  LIST = std::move(other75.LIST);
  ENUM = std::move(other75.ENUM);
  DECIMAL = std::move(other75.DECIMAL);
  DATE = std::move(other75.DATE);
  TIME = std::move(other75.TIME);
  TIMESTAMP = std::move(other75.TIMESTAMP);
  INTEGER = std::move(other75.INTEGER);
  UNKNOWN = std::move(other75.UNKNOWN);
  JSON = std::move(other75.JSON);
  BSON = std::move(other75.BSON);
  UUID = std::move(other75.UUID);
  __isset = other75.__isset;
  return *this;
}
void LogicalType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LogicalType(";
  out << "STRING=";
  (__isset.STRING ? (out << to_string(STRING)) : (out << "<null>"));
  out << ", "
      << "MAP=";
  (__isset.MAP ? (out << to_string(MAP)) : (out << "<null>"));
  out << ", "
      << "LIST=";
  (__isset.LIST ? (out << to_string(LIST)) : (out << "<null>"));
  out << ", "
      << "ENUM=";
  (__isset.ENUM ? (out << to_string(ENUM)) : (out << "<null>"));
  out << ", "
      << "DECIMAL=";
  (__isset.DECIMAL ? (out << to_string(DECIMAL)) : (out << "<null>"));
  out << ", "
      << "DATE=";
  (__isset.DATE ? (out << to_string(DATE)) : (out << "<null>"));
  out << ", "
      << "TIME=";
  (__isset.TIME ? (out << to_string(TIME)) : (out << "<null>"));
  out << ", "
      << "TIMESTAMP=";
  (__isset.TIMESTAMP ? (out << to_string(TIMESTAMP)) : (out << "<null>"));
  out << ", "
      << "INTEGER=";
  (__isset.INTEGER ? (out << to_string(INTEGER)) : (out << "<null>"));
  out << ", "
      << "UNKNOWN=";
  (__isset.UNKNOWN ? (out << to_string(UNKNOWN)) : (out << "<null>"));
  out << ", "
      << "JSON=";
  (__isset.JSON ? (out << to_string(JSON)) : (out << "<null>"));
  out << ", "
      << "BSON=";
  (__isset.BSON ? (out << to_string(BSON)) : (out << "<null>"));
  out << ", "
      << "UUID=";
  (__isset.UUID ? (out << to_string(UUID)) : (out << "<null>"));
  out << ")";
}

SchemaElement::~SchemaElement() noexcept {}

void SchemaElement::__set_type(const Type::type val) {
  this->type = val;
  __isset.type = true;
}

void SchemaElement::__set_type_length(const int32_t val) {
  this->type_length = val;
  __isset.type_length = true;
}

void SchemaElement::__set_repetition_type(const FieldRepetitionType::type val) {
  this->repetition_type = val;
  __isset.repetition_type = true;
}

void SchemaElement::__set_name(const std::string& val) {
  this->name = val;
}

void SchemaElement::__set_num_children(const int32_t val) {
  this->num_children = val;
  __isset.num_children = true;
}

void SchemaElement::__set_converted_type(const ConvertedType::type val) {
  this->converted_type = val;
  __isset.converted_type = true;
}

void SchemaElement::__set_scale(const int32_t val) {
  this->scale = val;
  __isset.scale = true;
}

void SchemaElement::__set_precision(const int32_t val) {
  this->precision = val;
  __isset.precision = true;
}

void SchemaElement::__set_field_id(const int32_t val) {
  this->field_id = val;
  __isset.field_id = true;
}

void SchemaElement::__set_logicalType(const LogicalType& val) {
  this->logicalType = val;
  __isset.logicalType = true;
}
std::ostream& operator<<(std::ostream& out, const SchemaElement& obj) {
  obj.printTo(out);
  return out;
}

uint32_t SchemaElement::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast76;
          xfer += iprot->readI32(ecast76);
          this->type = static_cast<Type::type>(ecast76);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type_length);
          this->__isset.type_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast77;
          xfer += iprot->readI32(ecast77);
          this->repetition_type =
              static_cast<FieldRepetitionType::type>(ecast77);
          this->__isset.repetition_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_children);
          this->__isset.num_children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast78;
          xfer += iprot->readI32(ecast78);
          this->converted_type = static_cast<ConvertedType::type>(ecast78);
          this->__isset.converted_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scale);
          this->__isset.scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->precision);
          this->__isset.precision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field_id);
          this->__isset.field_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->logicalType.read(iprot);
          this->__isset.logicalType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SchemaElement::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaElement");

  if (this->__isset.type) {
    xfer +=
        oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(static_cast<int32_t>(this->type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type_length) {
    xfer += oprot->writeFieldBegin(
        "type_length", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->type_length);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.repetition_type) {
    xfer += oprot->writeFieldBegin(
        "repetition_type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(static_cast<int32_t>(this->repetition_type));
    xfer += oprot->writeFieldEnd();
  }
  xfer +=
      oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.num_children) {
    xfer += oprot->writeFieldBegin(
        "num_children", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->num_children);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.converted_type) {
    xfer += oprot->writeFieldBegin(
        "converted_type", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(static_cast<int32_t>(this->converted_type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scale) {
    xfer +=
        oprot->writeFieldBegin("scale", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->scale);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.precision) {
    xfer += oprot->writeFieldBegin(
        "precision", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->precision);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.field_id) {
    xfer += oprot->writeFieldBegin(
        "field_id", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->field_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logicalType) {
    xfer += oprot->writeFieldBegin(
        "logicalType", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->logicalType.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaElement& a, SchemaElement& b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.type_length, b.type_length);
  swap(a.repetition_type, b.repetition_type);
  swap(a.name, b.name);
  swap(a.num_children, b.num_children);
  swap(a.converted_type, b.converted_type);
  swap(a.scale, b.scale);
  swap(a.precision, b.precision);
  swap(a.field_id, b.field_id);
  swap(a.logicalType, b.logicalType);
  swap(a.__isset, b.__isset);
}

SchemaElement::SchemaElement(const SchemaElement& other79) {
  type = other79.type;
  type_length = other79.type_length;
  repetition_type = other79.repetition_type;
  name = other79.name;
  num_children = other79.num_children;
  converted_type = other79.converted_type;
  scale = other79.scale;
  precision = other79.precision;
  field_id = other79.field_id;
  logicalType = other79.logicalType;
  __isset = other79.__isset;
}
SchemaElement::SchemaElement(SchemaElement&& other80) noexcept {
  type = other80.type;
  type_length = other80.type_length;
  repetition_type = other80.repetition_type;
  name = std::move(other80.name);
  num_children = other80.num_children;
  converted_type = other80.converted_type;
  scale = other80.scale;
  precision = other80.precision;
  field_id = other80.field_id;
  logicalType = std::move(other80.logicalType);
  __isset = other80.__isset;
}
SchemaElement& SchemaElement::operator=(const SchemaElement& other81) {
  type = other81.type;
  type_length = other81.type_length;
  repetition_type = other81.repetition_type;
  name = other81.name;
  num_children = other81.num_children;
  converted_type = other81.converted_type;
  scale = other81.scale;
  precision = other81.precision;
  field_id = other81.field_id;
  logicalType = other81.logicalType;
  __isset = other81.__isset;
  return *this;
}
SchemaElement& SchemaElement::operator=(SchemaElement&& other82) noexcept {
  type = other82.type;
  type_length = other82.type_length;
  repetition_type = other82.repetition_type;
  name = std::move(other82.name);
  num_children = other82.num_children;
  converted_type = other82.converted_type;
  scale = other82.scale;
  precision = other82.precision;
  field_id = other82.field_id;
  logicalType = std::move(other82.logicalType);
  __isset = other82.__isset;
  return *this;
}
void SchemaElement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaElement(";
  out << "type=";
  (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", "
      << "type_length=";
  (__isset.type_length ? (out << to_string(type_length)) : (out << "<null>"));
  out << ", "
      << "repetition_type=";
  (__isset.repetition_type ? (out << to_string(repetition_type))
                           : (out << "<null>"));
  out << ", "
      << "name=" << to_string(name);
  out << ", "
      << "num_children=";
  (__isset.num_children ? (out << to_string(num_children)) : (out << "<null>"));
  out << ", "
      << "converted_type=";
  (__isset.converted_type ? (out << to_string(converted_type))
                          : (out << "<null>"));
  out << ", "
      << "scale=";
  (__isset.scale ? (out << to_string(scale)) : (out << "<null>"));
  out << ", "
      << "precision=";
  (__isset.precision ? (out << to_string(precision)) : (out << "<null>"));
  out << ", "
      << "field_id=";
  (__isset.field_id ? (out << to_string(field_id)) : (out << "<null>"));
  out << ", "
      << "logicalType=";
  (__isset.logicalType ? (out << to_string(logicalType)) : (out << "<null>"));
  out << ")";
}

DataPageHeader::~DataPageHeader() noexcept {}

void DataPageHeader::__set_num_values(const int32_t val) {
  this->num_values = val;
}

void DataPageHeader::__set_encoding(const Encoding::type val) {
  this->encoding = val;
}

void DataPageHeader::__set_definition_level_encoding(const Encoding::type val) {
  this->definition_level_encoding = val;
}

void DataPageHeader::__set_repetition_level_encoding(const Encoding::type val) {
  this->repetition_level_encoding = val;
}

void DataPageHeader::__set_statistics(const Statistics& val) {
  this->statistics = val;
  __isset.statistics = true;
}
std::ostream& operator<<(std::ostream& out, const DataPageHeader& obj) {
  obj.printTo(out);
  return out;
}

uint32_t DataPageHeader::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_num_values = false;
  bool isset_encoding = false;
  bool isset_definition_level_encoding = false;
  bool isset_repetition_level_encoding = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_values);
          isset_num_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast83;
          xfer += iprot->readI32(ecast83);
          this->encoding = static_cast<Encoding::type>(ecast83);
          isset_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast84;
          xfer += iprot->readI32(ecast84);
          this->definition_level_encoding =
              static_cast<Encoding::type>(ecast84);
          isset_definition_level_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast85;
          xfer += iprot->readI32(ecast85);
          this->repetition_level_encoding =
              static_cast<Encoding::type>(ecast85);
          isset_repetition_level_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->statistics.read(iprot);
          this->__isset.statistics = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_num_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_encoding)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_definition_level_encoding)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_repetition_level_encoding)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DataPageHeader::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DataPageHeader");

  xfer += oprot->writeFieldBegin(
      "num_values", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_values);
  xfer += oprot->writeFieldEnd();

  xfer +=
      oprot->writeFieldBegin("encoding", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->encoding));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "definition_level_encoding", ::apache::thrift::protocol::T_I32, 3);
  xfer +=
      oprot->writeI32(static_cast<int32_t>(this->definition_level_encoding));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "repetition_level_encoding", ::apache::thrift::protocol::T_I32, 4);
  xfer +=
      oprot->writeI32(static_cast<int32_t>(this->repetition_level_encoding));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.statistics) {
    xfer += oprot->writeFieldBegin(
        "statistics", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->statistics.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DataPageHeader& a, DataPageHeader& b) {
  using ::std::swap;
  swap(a.num_values, b.num_values);
  swap(a.encoding, b.encoding);
  swap(a.definition_level_encoding, b.definition_level_encoding);
  swap(a.repetition_level_encoding, b.repetition_level_encoding);
  swap(a.statistics, b.statistics);
  swap(a.__isset, b.__isset);
}

DataPageHeader::DataPageHeader(const DataPageHeader& other86) {
  num_values = other86.num_values;
  encoding = other86.encoding;
  definition_level_encoding = other86.definition_level_encoding;
  repetition_level_encoding = other86.repetition_level_encoding;
  statistics = other86.statistics;
  __isset = other86.__isset;
}
DataPageHeader::DataPageHeader(DataPageHeader&& other87) noexcept {
  num_values = other87.num_values;
  encoding = other87.encoding;
  definition_level_encoding = other87.definition_level_encoding;
  repetition_level_encoding = other87.repetition_level_encoding;
  statistics = std::move(other87.statistics);
  __isset = other87.__isset;
}
DataPageHeader& DataPageHeader::operator=(const DataPageHeader& other88) {
  num_values = other88.num_values;
  encoding = other88.encoding;
  definition_level_encoding = other88.definition_level_encoding;
  repetition_level_encoding = other88.repetition_level_encoding;
  statistics = other88.statistics;
  __isset = other88.__isset;
  return *this;
}
DataPageHeader& DataPageHeader::operator=(DataPageHeader&& other89) noexcept {
  num_values = other89.num_values;
  encoding = other89.encoding;
  definition_level_encoding = other89.definition_level_encoding;
  repetition_level_encoding = other89.repetition_level_encoding;
  statistics = std::move(other89.statistics);
  __isset = other89.__isset;
  return *this;
}
void DataPageHeader::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DataPageHeader(";
  out << "num_values=" << to_string(num_values);
  out << ", "
      << "encoding=" << to_string(encoding);
  out << ", "
      << "definition_level_encoding=" << to_string(definition_level_encoding);
  out << ", "
      << "repetition_level_encoding=" << to_string(repetition_level_encoding);
  out << ", "
      << "statistics=";
  (__isset.statistics ? (out << to_string(statistics)) : (out << "<null>"));
  out << ")";
}

IndexPageHeader::~IndexPageHeader() noexcept {}

std::ostream& operator<<(std::ostream& out, const IndexPageHeader& obj) {
  obj.printTo(out);
  return out;
}

uint32_t IndexPageHeader::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IndexPageHeader::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IndexPageHeader");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IndexPageHeader& a, IndexPageHeader& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

IndexPageHeader::IndexPageHeader(const IndexPageHeader& other90) noexcept {
  (void)other90;
}
IndexPageHeader::IndexPageHeader(IndexPageHeader&& other91) noexcept {
  (void)other91;
}
IndexPageHeader& IndexPageHeader::operator=(
    const IndexPageHeader& other92) noexcept {
  (void)other92;
  return *this;
}
IndexPageHeader& IndexPageHeader::operator=(
    IndexPageHeader&& other93) noexcept {
  (void)other93;
  return *this;
}
void IndexPageHeader::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IndexPageHeader(";
  out << ")";
}

DictionaryPageHeader::~DictionaryPageHeader() noexcept {}

void DictionaryPageHeader::__set_num_values(const int32_t val) {
  this->num_values = val;
}

void DictionaryPageHeader::__set_encoding(const Encoding::type val) {
  this->encoding = val;
}

void DictionaryPageHeader::__set_is_sorted(const bool val) {
  this->is_sorted = val;
  __isset.is_sorted = true;
}
std::ostream& operator<<(std::ostream& out, const DictionaryPageHeader& obj) {
  obj.printTo(out);
  return out;
}

uint32_t DictionaryPageHeader::read(
    ::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_num_values = false;
  bool isset_encoding = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_values);
          isset_num_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast94;
          xfer += iprot->readI32(ecast94);
          this->encoding = static_cast<Encoding::type>(ecast94);
          isset_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_sorted);
          this->__isset.is_sorted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_num_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_encoding)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DictionaryPageHeader::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DictionaryPageHeader");

  xfer += oprot->writeFieldBegin(
      "num_values", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_values);
  xfer += oprot->writeFieldEnd();

  xfer +=
      oprot->writeFieldBegin("encoding", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->encoding));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.is_sorted) {
    xfer += oprot->writeFieldBegin(
        "is_sorted", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->is_sorted);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DictionaryPageHeader& a, DictionaryPageHeader& b) {
  using ::std::swap;
  swap(a.num_values, b.num_values);
  swap(a.encoding, b.encoding);
  swap(a.is_sorted, b.is_sorted);
  swap(a.__isset, b.__isset);
}

DictionaryPageHeader::DictionaryPageHeader(
    const DictionaryPageHeader& other95) noexcept {
  num_values = other95.num_values;
  encoding = other95.encoding;
  is_sorted = other95.is_sorted;
  __isset = other95.__isset;
}
DictionaryPageHeader::DictionaryPageHeader(
    DictionaryPageHeader&& other96) noexcept {
  num_values = other96.num_values;
  encoding = other96.encoding;
  is_sorted = other96.is_sorted;
  __isset = other96.__isset;
}
DictionaryPageHeader& DictionaryPageHeader::operator=(
    const DictionaryPageHeader& other97) noexcept {
  num_values = other97.num_values;
  encoding = other97.encoding;
  is_sorted = other97.is_sorted;
  __isset = other97.__isset;
  return *this;
}
DictionaryPageHeader& DictionaryPageHeader::operator=(
    DictionaryPageHeader&& other98) noexcept {
  num_values = other98.num_values;
  encoding = other98.encoding;
  is_sorted = other98.is_sorted;
  __isset = other98.__isset;
  return *this;
}
void DictionaryPageHeader::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DictionaryPageHeader(";
  out << "num_values=" << to_string(num_values);
  out << ", "
      << "encoding=" << to_string(encoding);
  out << ", "
      << "is_sorted=";
  (__isset.is_sorted ? (out << to_string(is_sorted)) : (out << "<null>"));
  out << ")";
}

DataPageHeaderV2::~DataPageHeaderV2() noexcept {}

void DataPageHeaderV2::__set_num_values(const int32_t val) {
  this->num_values = val;
}

void DataPageHeaderV2::__set_num_nulls(const int32_t val) {
  this->num_nulls = val;
}

void DataPageHeaderV2::__set_num_rows(const int32_t val) {
  this->num_rows = val;
}

void DataPageHeaderV2::__set_encoding(const Encoding::type val) {
  this->encoding = val;
}

void DataPageHeaderV2::__set_definition_levels_byte_length(const int32_t val) {
  this->definition_levels_byte_length = val;
}

void DataPageHeaderV2::__set_repetition_levels_byte_length(const int32_t val) {
  this->repetition_levels_byte_length = val;
}

void DataPageHeaderV2::__set_is_compressed(const bool val) {
  this->is_compressed = val;
  __isset.is_compressed = true;
}

void DataPageHeaderV2::__set_statistics(const Statistics& val) {
  this->statistics = val;
  __isset.statistics = true;
}
std::ostream& operator<<(std::ostream& out, const DataPageHeaderV2& obj) {
  obj.printTo(out);
  return out;
}

uint32_t DataPageHeaderV2::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_num_values = false;
  bool isset_num_nulls = false;
  bool isset_num_rows = false;
  bool isset_encoding = false;
  bool isset_definition_levels_byte_length = false;
  bool isset_repetition_levels_byte_length = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_values);
          isset_num_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_nulls);
          isset_num_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_rows);
          isset_num_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast99;
          xfer += iprot->readI32(ecast99);
          this->encoding = static_cast<Encoding::type>(ecast99);
          isset_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->definition_levels_byte_length);
          isset_definition_levels_byte_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->repetition_levels_byte_length);
          isset_repetition_levels_byte_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_compressed);
          this->__isset.is_compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->statistics.read(iprot);
          this->__isset.statistics = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_num_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_rows)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_encoding)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_definition_levels_byte_length)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_repetition_levels_byte_length)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DataPageHeaderV2::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DataPageHeaderV2");

  xfer += oprot->writeFieldBegin(
      "num_values", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_values);
  xfer += oprot->writeFieldEnd();

  xfer +=
      oprot->writeFieldBegin("num_nulls", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num_nulls);
  xfer += oprot->writeFieldEnd();

  xfer +=
      oprot->writeFieldBegin("num_rows", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->num_rows);
  xfer += oprot->writeFieldEnd();

  xfer +=
      oprot->writeFieldBegin("encoding", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(static_cast<int32_t>(this->encoding));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "definition_levels_byte_length", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->definition_levels_byte_length);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "repetition_levels_byte_length", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->repetition_levels_byte_length);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.is_compressed) {
    xfer += oprot->writeFieldBegin(
        "is_compressed", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_compressed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.statistics) {
    xfer += oprot->writeFieldBegin(
        "statistics", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->statistics.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DataPageHeaderV2& a, DataPageHeaderV2& b) {
  using ::std::swap;
  swap(a.num_values, b.num_values);
  swap(a.num_nulls, b.num_nulls);
  swap(a.num_rows, b.num_rows);
  swap(a.encoding, b.encoding);
  swap(a.definition_levels_byte_length, b.definition_levels_byte_length);
  swap(a.repetition_levels_byte_length, b.repetition_levels_byte_length);
  swap(a.is_compressed, b.is_compressed);
  swap(a.statistics, b.statistics);
  swap(a.__isset, b.__isset);
}

DataPageHeaderV2::DataPageHeaderV2(const DataPageHeaderV2& other100) {
  num_values = other100.num_values;
  num_nulls = other100.num_nulls;
  num_rows = other100.num_rows;
  encoding = other100.encoding;
  definition_levels_byte_length = other100.definition_levels_byte_length;
  repetition_levels_byte_length = other100.repetition_levels_byte_length;
  is_compressed = other100.is_compressed;
  statistics = other100.statistics;
  __isset = other100.__isset;
}
DataPageHeaderV2::DataPageHeaderV2(DataPageHeaderV2&& other101) noexcept {
  num_values = other101.num_values;
  num_nulls = other101.num_nulls;
  num_rows = other101.num_rows;
  encoding = other101.encoding;
  definition_levels_byte_length = other101.definition_levels_byte_length;
  repetition_levels_byte_length = other101.repetition_levels_byte_length;
  is_compressed = other101.is_compressed;
  statistics = std::move(other101.statistics);
  __isset = other101.__isset;
}
DataPageHeaderV2& DataPageHeaderV2::operator=(
    const DataPageHeaderV2& other102) {
  num_values = other102.num_values;
  num_nulls = other102.num_nulls;
  num_rows = other102.num_rows;
  encoding = other102.encoding;
  definition_levels_byte_length = other102.definition_levels_byte_length;
  repetition_levels_byte_length = other102.repetition_levels_byte_length;
  is_compressed = other102.is_compressed;
  statistics = other102.statistics;
  __isset = other102.__isset;
  return *this;
}
DataPageHeaderV2& DataPageHeaderV2::operator=(
    DataPageHeaderV2&& other103) noexcept {
  num_values = other103.num_values;
  num_nulls = other103.num_nulls;
  num_rows = other103.num_rows;
  encoding = other103.encoding;
  definition_levels_byte_length = other103.definition_levels_byte_length;
  repetition_levels_byte_length = other103.repetition_levels_byte_length;
  is_compressed = other103.is_compressed;
  statistics = std::move(other103.statistics);
  __isset = other103.__isset;
  return *this;
}
void DataPageHeaderV2::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DataPageHeaderV2(";
  out << "num_values=" << to_string(num_values);
  out << ", "
      << "num_nulls=" << to_string(num_nulls);
  out << ", "
      << "num_rows=" << to_string(num_rows);
  out << ", "
      << "encoding=" << to_string(encoding);
  out << ", "
      << "definition_levels_byte_length="
      << to_string(definition_levels_byte_length);
  out << ", "
      << "repetition_levels_byte_length="
      << to_string(repetition_levels_byte_length);
  out << ", "
      << "is_compressed=";
  (__isset.is_compressed ? (out << to_string(is_compressed))
                         : (out << "<null>"));
  out << ", "
      << "statistics=";
  (__isset.statistics ? (out << to_string(statistics)) : (out << "<null>"));
  out << ")";
}

SplitBlockAlgorithm::~SplitBlockAlgorithm() noexcept {}

std::ostream& operator<<(std::ostream& out, const SplitBlockAlgorithm& obj) {
  obj.printTo(out);
  return out;
}

uint32_t SplitBlockAlgorithm::read(
    ::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SplitBlockAlgorithm::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SplitBlockAlgorithm");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SplitBlockAlgorithm& a, SplitBlockAlgorithm& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

SplitBlockAlgorithm::SplitBlockAlgorithm(
    const SplitBlockAlgorithm& other104) noexcept {
  (void)other104;
}
SplitBlockAlgorithm::SplitBlockAlgorithm(
    SplitBlockAlgorithm&& other105) noexcept {
  (void)other105;
}
SplitBlockAlgorithm& SplitBlockAlgorithm::operator=(
    const SplitBlockAlgorithm& other106) noexcept {
  (void)other106;
  return *this;
}
SplitBlockAlgorithm& SplitBlockAlgorithm::operator=(
    SplitBlockAlgorithm&& other107) noexcept {
  (void)other107;
  return *this;
}
void SplitBlockAlgorithm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SplitBlockAlgorithm(";
  out << ")";
}

BloomFilterAlgorithm::~BloomFilterAlgorithm() noexcept {}

void BloomFilterAlgorithm::__set_BLOCK(const SplitBlockAlgorithm& val) {
  this->BLOCK = val;
  __isset.BLOCK = true;
}
std::ostream& operator<<(std::ostream& out, const BloomFilterAlgorithm& obj) {
  obj.printTo(out);
  return out;
}

uint32_t BloomFilterAlgorithm::read(
    ::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->BLOCK.read(iprot);
          this->__isset.BLOCK = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BloomFilterAlgorithm::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BloomFilterAlgorithm");

  if (this->__isset.BLOCK) {
    xfer += oprot->writeFieldBegin(
        "BLOCK", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->BLOCK.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BloomFilterAlgorithm& a, BloomFilterAlgorithm& b) {
  using ::std::swap;
  swap(a.BLOCK, b.BLOCK);
  swap(a.__isset, b.__isset);
}

BloomFilterAlgorithm::BloomFilterAlgorithm(
    const BloomFilterAlgorithm& other108) noexcept {
  BLOCK = other108.BLOCK;
  __isset = other108.__isset;
}
BloomFilterAlgorithm::BloomFilterAlgorithm(
    BloomFilterAlgorithm&& other109) noexcept {
  BLOCK = std::move(other109.BLOCK);
  __isset = other109.__isset;
}
BloomFilterAlgorithm& BloomFilterAlgorithm::operator=(
    const BloomFilterAlgorithm& other110) noexcept {
  BLOCK = other110.BLOCK;
  __isset = other110.__isset;
  return *this;
}
BloomFilterAlgorithm& BloomFilterAlgorithm::operator=(
    BloomFilterAlgorithm&& other111) noexcept {
  BLOCK = std::move(other111.BLOCK);
  __isset = other111.__isset;
  return *this;
}
void BloomFilterAlgorithm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BloomFilterAlgorithm(";
  out << "BLOCK=";
  (__isset.BLOCK ? (out << to_string(BLOCK)) : (out << "<null>"));
  out << ")";
}

XxHash::~XxHash() noexcept {}

std::ostream& operator<<(std::ostream& out, const XxHash& obj) {
  obj.printTo(out);
  return out;
}

uint32_t XxHash::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t XxHash::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("XxHash");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(XxHash& a, XxHash& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

XxHash::XxHash(const XxHash& other112) noexcept {
  (void)other112;
}
XxHash::XxHash(XxHash&& other113) noexcept {
  (void)other113;
}
XxHash& XxHash::operator=(const XxHash& other114) noexcept {
  (void)other114;
  return *this;
}
XxHash& XxHash::operator=(XxHash&& other115) noexcept {
  (void)other115;
  return *this;
}
void XxHash::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "XxHash(";
  out << ")";
}

BloomFilterHash::~BloomFilterHash() noexcept {}

void BloomFilterHash::__set_XXHASH(const XxHash& val) {
  this->XXHASH = val;
  __isset.XXHASH = true;
}
std::ostream& operator<<(std::ostream& out, const BloomFilterHash& obj) {
  obj.printTo(out);
  return out;
}

uint32_t BloomFilterHash::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->XXHASH.read(iprot);
          this->__isset.XXHASH = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BloomFilterHash::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BloomFilterHash");

  if (this->__isset.XXHASH) {
    xfer += oprot->writeFieldBegin(
        "XXHASH", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->XXHASH.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BloomFilterHash& a, BloomFilterHash& b) {
  using ::std::swap;
  swap(a.XXHASH, b.XXHASH);
  swap(a.__isset, b.__isset);
}

BloomFilterHash::BloomFilterHash(const BloomFilterHash& other116) noexcept {
  XXHASH = other116.XXHASH;
  __isset = other116.__isset;
}
BloomFilterHash::BloomFilterHash(BloomFilterHash&& other117) noexcept {
  XXHASH = std::move(other117.XXHASH);
  __isset = other117.__isset;
}
BloomFilterHash& BloomFilterHash::operator=(
    const BloomFilterHash& other118) noexcept {
  XXHASH = other118.XXHASH;
  __isset = other118.__isset;
  return *this;
}
BloomFilterHash& BloomFilterHash::operator=(
    BloomFilterHash&& other119) noexcept {
  XXHASH = std::move(other119.XXHASH);
  __isset = other119.__isset;
  return *this;
}
void BloomFilterHash::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BloomFilterHash(";
  out << "XXHASH=";
  (__isset.XXHASH ? (out << to_string(XXHASH)) : (out << "<null>"));
  out << ")";
}

Uncompressed::~Uncompressed() noexcept {}

std::ostream& operator<<(std::ostream& out, const Uncompressed& obj) {
  obj.printTo(out);
  return out;
}

uint32_t Uncompressed::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Uncompressed::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Uncompressed");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Uncompressed& a, Uncompressed& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

Uncompressed::Uncompressed(const Uncompressed& other120) noexcept {
  (void)other120;
}
Uncompressed::Uncompressed(Uncompressed&& other121) noexcept {
  (void)other121;
}
Uncompressed& Uncompressed::operator=(const Uncompressed& other122) noexcept {
  (void)other122;
  return *this;
}
Uncompressed& Uncompressed::operator=(Uncompressed&& other123) noexcept {
  (void)other123;
  return *this;
}
void Uncompressed::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Uncompressed(";
  out << ")";
}

BloomFilterCompression::~BloomFilterCompression() noexcept {}

void BloomFilterCompression::__set_UNCOMPRESSED(const Uncompressed& val) {
  this->UNCOMPRESSED = val;
  __isset.UNCOMPRESSED = true;
}
std::ostream& operator<<(std::ostream& out, const BloomFilterCompression& obj) {
  obj.printTo(out);
  return out;
}

uint32_t BloomFilterCompression::read(
    ::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->UNCOMPRESSED.read(iprot);
          this->__isset.UNCOMPRESSED = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BloomFilterCompression::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BloomFilterCompression");

  if (this->__isset.UNCOMPRESSED) {
    xfer += oprot->writeFieldBegin(
        "UNCOMPRESSED", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->UNCOMPRESSED.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BloomFilterCompression& a, BloomFilterCompression& b) {
  using ::std::swap;
  swap(a.UNCOMPRESSED, b.UNCOMPRESSED);
  swap(a.__isset, b.__isset);
}

BloomFilterCompression::BloomFilterCompression(
    const BloomFilterCompression& other124) noexcept {
  UNCOMPRESSED = other124.UNCOMPRESSED;
  __isset = other124.__isset;
}
BloomFilterCompression::BloomFilterCompression(
    BloomFilterCompression&& other125) noexcept {
  UNCOMPRESSED = std::move(other125.UNCOMPRESSED);
  __isset = other125.__isset;
}
BloomFilterCompression& BloomFilterCompression::operator=(
    const BloomFilterCompression& other126) noexcept {
  UNCOMPRESSED = other126.UNCOMPRESSED;
  __isset = other126.__isset;
  return *this;
}
BloomFilterCompression& BloomFilterCompression::operator=(
    BloomFilterCompression&& other127) noexcept {
  UNCOMPRESSED = std::move(other127.UNCOMPRESSED);
  __isset = other127.__isset;
  return *this;
}
void BloomFilterCompression::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BloomFilterCompression(";
  out << "UNCOMPRESSED=";
  (__isset.UNCOMPRESSED ? (out << to_string(UNCOMPRESSED)) : (out << "<null>"));
  out << ")";
}

BloomFilterHeader::~BloomFilterHeader() noexcept {}

void BloomFilterHeader::__set_numBytes(const int32_t val) {
  this->numBytes = val;
}

void BloomFilterHeader::__set_algorithm(const BloomFilterAlgorithm& val) {
  this->algorithm = val;
}

void BloomFilterHeader::__set_hash(const BloomFilterHash& val) {
  this->hash = val;
}

void BloomFilterHeader::__set_compression(const BloomFilterCompression& val) {
  this->compression = val;
}
std::ostream& operator<<(std::ostream& out, const BloomFilterHeader& obj) {
  obj.printTo(out);
  return out;
}

uint32_t BloomFilterHeader::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numBytes = false;
  bool isset_algorithm = false;
  bool isset_hash = false;
  bool isset_compression = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numBytes);
          isset_numBytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->algorithm.read(iprot);
          isset_algorithm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hash.read(iprot);
          isset_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->compression.read(iprot);
          isset_compression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numBytes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_algorithm)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_compression)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t BloomFilterHeader::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BloomFilterHeader");

  xfer +=
      oprot->writeFieldBegin("numBytes", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->numBytes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "algorithm", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->algorithm.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer +=
      oprot->writeFieldBegin("hash", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->hash.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "compression", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->compression.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BloomFilterHeader& a, BloomFilterHeader& b) {
  using ::std::swap;
  swap(a.numBytes, b.numBytes);
  swap(a.algorithm, b.algorithm);
  swap(a.hash, b.hash);
  swap(a.compression, b.compression);
}

BloomFilterHeader::BloomFilterHeader(
    const BloomFilterHeader& other128) noexcept {
  numBytes = other128.numBytes;
  algorithm = other128.algorithm;
  hash = other128.hash;
  compression = other128.compression;
}
BloomFilterHeader::BloomFilterHeader(BloomFilterHeader&& other129) noexcept {
  numBytes = other129.numBytes;
  algorithm = std::move(other129.algorithm);
  hash = std::move(other129.hash);
  compression = std::move(other129.compression);
}
BloomFilterHeader& BloomFilterHeader::operator=(
    const BloomFilterHeader& other130) noexcept {
  numBytes = other130.numBytes;
  algorithm = other130.algorithm;
  hash = other130.hash;
  compression = other130.compression;
  return *this;
}
BloomFilterHeader& BloomFilterHeader::operator=(
    BloomFilterHeader&& other131) noexcept {
  numBytes = other131.numBytes;
  algorithm = std::move(other131.algorithm);
  hash = std::move(other131.hash);
  compression = std::move(other131.compression);
  return *this;
}
void BloomFilterHeader::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BloomFilterHeader(";
  out << "numBytes=" << to_string(numBytes);
  out << ", "
      << "algorithm=" << to_string(algorithm);
  out << ", "
      << "hash=" << to_string(hash);
  out << ", "
      << "compression=" << to_string(compression);
  out << ")";
}

PageHeader::~PageHeader() noexcept {}

void PageHeader::__set_type(const PageType::type val) {
  this->type = val;
}

void PageHeader::__set_uncompressed_page_size(const int32_t val) {
  this->uncompressed_page_size = val;
}

void PageHeader::__set_compressed_page_size(const int32_t val) {
  this->compressed_page_size = val;
}

void PageHeader::__set_crc(const int32_t val) {
  this->crc = val;
  __isset.crc = true;
}

void PageHeader::__set_data_page_header(const DataPageHeader& val) {
  this->data_page_header = val;
  __isset.data_page_header = true;
}

void PageHeader::__set_index_page_header(const IndexPageHeader& val) {
  this->index_page_header = val;
  __isset.index_page_header = true;
}

void PageHeader::__set_dictionary_page_header(const DictionaryPageHeader& val) {
  this->dictionary_page_header = val;
  __isset.dictionary_page_header = true;
}

void PageHeader::__set_data_page_header_v2(const DataPageHeaderV2& val) {
  this->data_page_header_v2 = val;
  __isset.data_page_header_v2 = true;
}
std::ostream& operator<<(std::ostream& out, const PageHeader& obj) {
  obj.printTo(out);
  return out;
}

uint32_t PageHeader::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;
  bool isset_uncompressed_page_size = false;
  bool isset_compressed_page_size = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast132;
          xfer += iprot->readI32(ecast132);
          this->type = static_cast<PageType::type>(ecast132);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uncompressed_page_size);
          isset_uncompressed_page_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->compressed_page_size);
          isset_compressed_page_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->crc);
          this->__isset.crc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data_page_header.read(iprot);
          this->__isset.data_page_header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->index_page_header.read(iprot);
          this->__isset.index_page_header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dictionary_page_header.read(iprot);
          this->__isset.dictionary_page_header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data_page_header_v2.read(iprot);
          this->__isset.data_page_header_v2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_uncompressed_page_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_compressed_page_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PageHeader::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PageHeader");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "uncompressed_page_size", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uncompressed_page_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "compressed_page_size", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->compressed_page_size);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.crc) {
    xfer += oprot->writeFieldBegin("crc", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->crc);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.data_page_header) {
    xfer += oprot->writeFieldBegin(
        "data_page_header", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->data_page_header.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.index_page_header) {
    xfer += oprot->writeFieldBegin(
        "index_page_header", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->index_page_header.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dictionary_page_header) {
    xfer += oprot->writeFieldBegin(
        "dictionary_page_header", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->dictionary_page_header.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.data_page_header_v2) {
    xfer += oprot->writeFieldBegin(
        "data_page_header_v2", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->data_page_header_v2.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PageHeader& a, PageHeader& b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.uncompressed_page_size, b.uncompressed_page_size);
  swap(a.compressed_page_size, b.compressed_page_size);
  swap(a.crc, b.crc);
  swap(a.data_page_header, b.data_page_header);
  swap(a.index_page_header, b.index_page_header);
  swap(a.dictionary_page_header, b.dictionary_page_header);
  swap(a.data_page_header_v2, b.data_page_header_v2);
  swap(a.__isset, b.__isset);
}

PageHeader::PageHeader(const PageHeader& other133) {
  type = other133.type;
  uncompressed_page_size = other133.uncompressed_page_size;
  compressed_page_size = other133.compressed_page_size;
  crc = other133.crc;
  data_page_header = other133.data_page_header;
  index_page_header = other133.index_page_header;
  dictionary_page_header = other133.dictionary_page_header;
  data_page_header_v2 = other133.data_page_header_v2;
  __isset = other133.__isset;
}
PageHeader::PageHeader(PageHeader&& other134) noexcept {
  type = other134.type;
  uncompressed_page_size = other134.uncompressed_page_size;
  compressed_page_size = other134.compressed_page_size;
  crc = other134.crc;
  data_page_header = std::move(other134.data_page_header);
  index_page_header = std::move(other134.index_page_header);
  dictionary_page_header = std::move(other134.dictionary_page_header);
  data_page_header_v2 = std::move(other134.data_page_header_v2);
  __isset = other134.__isset;
}
PageHeader& PageHeader::operator=(const PageHeader& other135) {
  type = other135.type;
  uncompressed_page_size = other135.uncompressed_page_size;
  compressed_page_size = other135.compressed_page_size;
  crc = other135.crc;
  data_page_header = other135.data_page_header;
  index_page_header = other135.index_page_header;
  dictionary_page_header = other135.dictionary_page_header;
  data_page_header_v2 = other135.data_page_header_v2;
  __isset = other135.__isset;
  return *this;
}
PageHeader& PageHeader::operator=(PageHeader&& other136) noexcept {
  type = other136.type;
  uncompressed_page_size = other136.uncompressed_page_size;
  compressed_page_size = other136.compressed_page_size;
  crc = other136.crc;
  data_page_header = std::move(other136.data_page_header);
  index_page_header = std::move(other136.index_page_header);
  dictionary_page_header = std::move(other136.dictionary_page_header);
  data_page_header_v2 = std::move(other136.data_page_header_v2);
  __isset = other136.__isset;
  return *this;
}
void PageHeader::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PageHeader(";
  out << "type=" << to_string(type);
  out << ", "
      << "uncompressed_page_size=" << to_string(uncompressed_page_size);
  out << ", "
      << "compressed_page_size=" << to_string(compressed_page_size);
  out << ", "
      << "crc=";
  (__isset.crc ? (out << to_string(crc)) : (out << "<null>"));
  out << ", "
      << "data_page_header=";
  (__isset.data_page_header ? (out << to_string(data_page_header))
                            : (out << "<null>"));
  out << ", "
      << "index_page_header=";
  (__isset.index_page_header ? (out << to_string(index_page_header))
                             : (out << "<null>"));
  out << ", "
      << "dictionary_page_header=";
  (__isset.dictionary_page_header ? (out << to_string(dictionary_page_header))
                                  : (out << "<null>"));
  out << ", "
      << "data_page_header_v2=";
  (__isset.data_page_header_v2 ? (out << to_string(data_page_header_v2))
                               : (out << "<null>"));
  out << ")";
}

KeyValue::~KeyValue() noexcept {}

void KeyValue::__set_key(const std::string& val) {
  this->key = val;
}

void KeyValue::__set_value(const std::string& val) {
  this->value = val;
  __isset.value = true;
}
std::ostream& operator<<(std::ostream& out, const KeyValue& obj) {
  obj.printTo(out);
  return out;
}

uint32_t KeyValue::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_key = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KeyValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KeyValue");

  xfer +=
      oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin(
        "value", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KeyValue& a, KeyValue& b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

KeyValue::KeyValue(const KeyValue& other137) {
  key = other137.key;
  value = other137.value;
  __isset = other137.__isset;
}
KeyValue::KeyValue(KeyValue&& other138) noexcept {
  key = std::move(other138.key);
  value = std::move(other138.value);
  __isset = other138.__isset;
}
KeyValue& KeyValue::operator=(const KeyValue& other139) {
  key = other139.key;
  value = other139.value;
  __isset = other139.__isset;
  return *this;
}
KeyValue& KeyValue::operator=(KeyValue&& other140) noexcept {
  key = std::move(other140.key);
  value = std::move(other140.value);
  __isset = other140.__isset;
  return *this;
}
void KeyValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KeyValue(";
  out << "key=" << to_string(key);
  out << ", "
      << "value=";
  (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ")";
}

SortingColumn::~SortingColumn() noexcept {}

void SortingColumn::__set_column_idx(const int32_t val) {
  this->column_idx = val;
}

void SortingColumn::__set_descending(const bool val) {
  this->descending = val;
}

void SortingColumn::__set_nulls_first(const bool val) {
  this->nulls_first = val;
}
std::ostream& operator<<(std::ostream& out, const SortingColumn& obj) {
  obj.printTo(out);
  return out;
}

uint32_t SortingColumn::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_column_idx = false;
  bool isset_descending = false;
  bool isset_nulls_first = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->column_idx);
          isset_column_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->descending);
          isset_descending = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->nulls_first);
          isset_nulls_first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_column_idx)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_descending)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls_first)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SortingColumn::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SortingColumn");

  xfer += oprot->writeFieldBegin(
      "column_idx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->column_idx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "descending", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->descending);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "nulls_first", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->nulls_first);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SortingColumn& a, SortingColumn& b) {
  using ::std::swap;
  swap(a.column_idx, b.column_idx);
  swap(a.descending, b.descending);
  swap(a.nulls_first, b.nulls_first);
}

SortingColumn::SortingColumn(const SortingColumn& other141) noexcept {
  column_idx = other141.column_idx;
  descending = other141.descending;
  nulls_first = other141.nulls_first;
}
SortingColumn::SortingColumn(SortingColumn&& other142) noexcept {
  column_idx = other142.column_idx;
  descending = other142.descending;
  nulls_first = other142.nulls_first;
}
SortingColumn& SortingColumn::operator=(
    const SortingColumn& other143) noexcept {
  column_idx = other143.column_idx;
  descending = other143.descending;
  nulls_first = other143.nulls_first;
  return *this;
}
SortingColumn& SortingColumn::operator=(SortingColumn&& other144) noexcept {
  column_idx = other144.column_idx;
  descending = other144.descending;
  nulls_first = other144.nulls_first;
  return *this;
}
void SortingColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SortingColumn(";
  out << "column_idx=" << to_string(column_idx);
  out << ", "
      << "descending=" << to_string(descending);
  out << ", "
      << "nulls_first=" << to_string(nulls_first);
  out << ")";
}

PageEncodingStats::~PageEncodingStats() noexcept {}

void PageEncodingStats::__set_page_type(const PageType::type val) {
  this->page_type = val;
}

void PageEncodingStats::__set_encoding(const Encoding::type val) {
  this->encoding = val;
}

void PageEncodingStats::__set_count(const int32_t val) {
  this->count = val;
}
std::ostream& operator<<(std::ostream& out, const PageEncodingStats& obj) {
  obj.printTo(out);
  return out;
}

uint32_t PageEncodingStats::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_page_type = false;
  bool isset_encoding = false;
  bool isset_count = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast145;
          xfer += iprot->readI32(ecast145);
          this->page_type = static_cast<PageType::type>(ecast145);
          isset_page_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast146;
          xfer += iprot->readI32(ecast146);
          this->encoding = static_cast<Encoding::type>(ecast146);
          isset_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_page_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_encoding)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PageEncodingStats::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PageEncodingStats");

  xfer +=
      oprot->writeFieldBegin("page_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->page_type));
  xfer += oprot->writeFieldEnd();

  xfer +=
      oprot->writeFieldBegin("encoding", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->encoding));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PageEncodingStats& a, PageEncodingStats& b) {
  using ::std::swap;
  swap(a.page_type, b.page_type);
  swap(a.encoding, b.encoding);
  swap(a.count, b.count);
}

PageEncodingStats::PageEncodingStats(
    const PageEncodingStats& other147) noexcept {
  page_type = other147.page_type;
  encoding = other147.encoding;
  count = other147.count;
}
PageEncodingStats::PageEncodingStats(PageEncodingStats&& other148) noexcept {
  page_type = other148.page_type;
  encoding = other148.encoding;
  count = other148.count;
}
PageEncodingStats& PageEncodingStats::operator=(
    const PageEncodingStats& other149) noexcept {
  page_type = other149.page_type;
  encoding = other149.encoding;
  count = other149.count;
  return *this;
}
PageEncodingStats& PageEncodingStats::operator=(
    PageEncodingStats&& other150) noexcept {
  page_type = other150.page_type;
  encoding = other150.encoding;
  count = other150.count;
  return *this;
}
void PageEncodingStats::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PageEncodingStats(";
  out << "page_type=" << to_string(page_type);
  out << ", "
      << "encoding=" << to_string(encoding);
  out << ", "
      << "count=" << to_string(count);
  out << ")";
}

ColumnMetaData::~ColumnMetaData() noexcept {}

void ColumnMetaData::__set_type(const Type::type val) {
  this->type = val;
}

void ColumnMetaData::__set_encodings(const std::vector<Encoding::type>& val) {
  this->encodings = val;
}

void ColumnMetaData::__set_path_in_schema(const std::vector<std::string>& val) {
  this->path_in_schema = val;
}

void ColumnMetaData::__set_codec(const CompressionCodec::type val) {
  this->codec = val;
}

void ColumnMetaData::__set_num_values(const int64_t val) {
  this->num_values = val;
}

void ColumnMetaData::__set_total_uncompressed_size(const int64_t val) {
  this->total_uncompressed_size = val;
}

void ColumnMetaData::__set_total_compressed_size(const int64_t val) {
  this->total_compressed_size = val;
}

void ColumnMetaData::__set_key_value_metadata(
    const std::vector<KeyValue>& val) {
  this->key_value_metadata = val;
  __isset.key_value_metadata = true;
}

void ColumnMetaData::__set_data_page_offset(const int64_t val) {
  this->data_page_offset = val;
}

void ColumnMetaData::__set_index_page_offset(const int64_t val) {
  this->index_page_offset = val;
  __isset.index_page_offset = true;
}

void ColumnMetaData::__set_dictionary_page_offset(const int64_t val) {
  this->dictionary_page_offset = val;
  __isset.dictionary_page_offset = true;
}

void ColumnMetaData::__set_statistics(const Statistics& val) {
  this->statistics = val;
  __isset.statistics = true;
}

void ColumnMetaData::__set_encoding_stats(
    const std::vector<PageEncodingStats>& val) {
  this->encoding_stats = val;
  __isset.encoding_stats = true;
}

void ColumnMetaData::__set_bloom_filter_offset(const int64_t val) {
  this->bloom_filter_offset = val;
  __isset.bloom_filter_offset = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnMetaData& obj) {
  obj.printTo(out);
  return out;
}

uint32_t ColumnMetaData::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;
  bool isset_encodings = false;
  bool isset_path_in_schema = false;
  bool isset_codec = false;
  bool isset_num_values = false;
  bool isset_total_uncompressed_size = false;
  bool isset_total_compressed_size = false;
  bool isset_data_page_offset = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast151;
          xfer += iprot->readI32(ecast151);
          this->type = static_cast<Type::type>(ecast151);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->encodings.clear();
            uint32_t _size152;
            ::apache::thrift::protocol::TType _etype155;
            xfer += iprot->readListBegin(_etype155, _size152);
            this->encodings.resize(_size152);
            uint32_t _i156;
            for (_i156 = 0; _i156 < _size152; ++_i156) {
              int32_t ecast157;
              xfer += iprot->readI32(ecast157);
              this->encodings[_i156] = static_cast<Encoding::type>(ecast157);
            }
            xfer += iprot->readListEnd();
          }
          isset_encodings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->path_in_schema.clear();
            uint32_t _size158;
            ::apache::thrift::protocol::TType _etype161;
            xfer += iprot->readListBegin(_etype161, _size158);
            this->path_in_schema.resize(_size158);
            uint32_t _i162;
            for (_i162 = 0; _i162 < _size158; ++_i162) {
              xfer += iprot->readString(this->path_in_schema[_i162]);
            }
            xfer += iprot->readListEnd();
          }
          isset_path_in_schema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast163;
          xfer += iprot->readI32(ecast163);
          this->codec = static_cast<CompressionCodec::type>(ecast163);
          isset_codec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_values);
          isset_num_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_uncompressed_size);
          isset_total_uncompressed_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_compressed_size);
          isset_total_compressed_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_value_metadata.clear();
            uint32_t _size164;
            ::apache::thrift::protocol::TType _etype167;
            xfer += iprot->readListBegin(_etype167, _size164);
            this->key_value_metadata.resize(_size164);
            uint32_t _i168;
            for (_i168 = 0; _i168 < _size164; ++_i168) {
              xfer += this->key_value_metadata[_i168].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.key_value_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->data_page_offset);
          isset_data_page_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->index_page_offset);
          this->__isset.index_page_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dictionary_page_offset);
          this->__isset.dictionary_page_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->statistics.read(iprot);
          this->__isset.statistics = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->encoding_stats.clear();
            uint32_t _size169;
            ::apache::thrift::protocol::TType _etype172;
            xfer += iprot->readListBegin(_etype172, _size169);
            this->encoding_stats.resize(_size169);
            uint32_t _i173;
            for (_i173 = 0; _i173 < _size169; ++_i173) {
              xfer += this->encoding_stats[_i173].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.encoding_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bloom_filter_offset);
          this->__isset.bloom_filter_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_encodings)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_path_in_schema)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_codec)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_total_uncompressed_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_total_compressed_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data_page_offset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnMetaData::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnMetaData");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "encodings", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(
        ::apache::thrift::protocol::T_I32,
        static_cast<uint32_t>(this->encodings.size()));
    std::vector<Encoding::type>::const_iterator _iter174;
    for (_iter174 = this->encodings.begin(); _iter174 != this->encodings.end();
         ++_iter174) {
      xfer += oprot->writeI32(static_cast<int32_t>((*_iter174)));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "path_in_schema", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(
        ::apache::thrift::protocol::T_STRING,
        static_cast<uint32_t>(this->path_in_schema.size()));
    std::vector<std::string>::const_iterator _iter175;
    for (_iter175 = this->path_in_schema.begin();
         _iter175 != this->path_in_schema.end();
         ++_iter175) {
      xfer += oprot->writeString((*_iter175));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("codec", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(static_cast<int32_t>(this->codec));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "num_values", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->num_values);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "total_uncompressed_size", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->total_uncompressed_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "total_compressed_size", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->total_compressed_size);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.key_value_metadata) {
    xfer += oprot->writeFieldBegin(
        "key_value_metadata", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(
          ::apache::thrift::protocol::T_STRUCT,
          static_cast<uint32_t>(this->key_value_metadata.size()));
      std::vector<KeyValue>::const_iterator _iter176;
      for (_iter176 = this->key_value_metadata.begin();
           _iter176 != this->key_value_metadata.end();
           ++_iter176) {
        xfer += (*_iter176).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin(
      "data_page_offset", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->data_page_offset);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.index_page_offset) {
    xfer += oprot->writeFieldBegin(
        "index_page_offset", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->index_page_offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dictionary_page_offset) {
    xfer += oprot->writeFieldBegin(
        "dictionary_page_offset", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->dictionary_page_offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.statistics) {
    xfer += oprot->writeFieldBegin(
        "statistics", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->statistics.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.encoding_stats) {
    xfer += oprot->writeFieldBegin(
        "encoding_stats", ::apache::thrift::protocol::T_LIST, 13);
    {
      xfer += oprot->writeListBegin(
          ::apache::thrift::protocol::T_STRUCT,
          static_cast<uint32_t>(this->encoding_stats.size()));
      std::vector<PageEncodingStats>::const_iterator _iter177;
      for (_iter177 = this->encoding_stats.begin();
           _iter177 != this->encoding_stats.end();
           ++_iter177) {
        xfer += (*_iter177).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bloom_filter_offset) {
    xfer += oprot->writeFieldBegin(
        "bloom_filter_offset", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->bloom_filter_offset);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnMetaData& a, ColumnMetaData& b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.encodings, b.encodings);
  swap(a.path_in_schema, b.path_in_schema);
  swap(a.codec, b.codec);
  swap(a.num_values, b.num_values);
  swap(a.total_uncompressed_size, b.total_uncompressed_size);
  swap(a.total_compressed_size, b.total_compressed_size);
  swap(a.key_value_metadata, b.key_value_metadata);
  swap(a.data_page_offset, b.data_page_offset);
  swap(a.index_page_offset, b.index_page_offset);
  swap(a.dictionary_page_offset, b.dictionary_page_offset);
  swap(a.statistics, b.statistics);
  swap(a.encoding_stats, b.encoding_stats);
  swap(a.bloom_filter_offset, b.bloom_filter_offset);
  swap(a.__isset, b.__isset);
}

ColumnMetaData::ColumnMetaData(const ColumnMetaData& other178) {
  type = other178.type;
  encodings = other178.encodings;
  path_in_schema = other178.path_in_schema;
  codec = other178.codec;
  num_values = other178.num_values;
  total_uncompressed_size = other178.total_uncompressed_size;
  total_compressed_size = other178.total_compressed_size;
  key_value_metadata = other178.key_value_metadata;
  data_page_offset = other178.data_page_offset;
  index_page_offset = other178.index_page_offset;
  dictionary_page_offset = other178.dictionary_page_offset;
  statistics = other178.statistics;
  encoding_stats = other178.encoding_stats;
  bloom_filter_offset = other178.bloom_filter_offset;
  __isset = other178.__isset;
}
ColumnMetaData::ColumnMetaData(ColumnMetaData&& other179) noexcept {
  type = other179.type;
  encodings = std::move(other179.encodings);
  path_in_schema = std::move(other179.path_in_schema);
  codec = other179.codec;
  num_values = other179.num_values;
  total_uncompressed_size = other179.total_uncompressed_size;
  total_compressed_size = other179.total_compressed_size;
  key_value_metadata = std::move(other179.key_value_metadata);
  data_page_offset = other179.data_page_offset;
  index_page_offset = other179.index_page_offset;
  dictionary_page_offset = other179.dictionary_page_offset;
  statistics = std::move(other179.statistics);
  encoding_stats = std::move(other179.encoding_stats);
  bloom_filter_offset = other179.bloom_filter_offset;
  __isset = other179.__isset;
}
ColumnMetaData& ColumnMetaData::operator=(const ColumnMetaData& other180) {
  type = other180.type;
  encodings = other180.encodings;
  path_in_schema = other180.path_in_schema;
  codec = other180.codec;
  num_values = other180.num_values;
  total_uncompressed_size = other180.total_uncompressed_size;
  total_compressed_size = other180.total_compressed_size;
  key_value_metadata = other180.key_value_metadata;
  data_page_offset = other180.data_page_offset;
  index_page_offset = other180.index_page_offset;
  dictionary_page_offset = other180.dictionary_page_offset;
  statistics = other180.statistics;
  encoding_stats = other180.encoding_stats;
  bloom_filter_offset = other180.bloom_filter_offset;
  __isset = other180.__isset;
  return *this;
}
ColumnMetaData& ColumnMetaData::operator=(ColumnMetaData&& other181) noexcept {
  type = other181.type;
  encodings = std::move(other181.encodings);
  path_in_schema = std::move(other181.path_in_schema);
  codec = other181.codec;
  num_values = other181.num_values;
  total_uncompressed_size = other181.total_uncompressed_size;
  total_compressed_size = other181.total_compressed_size;
  key_value_metadata = std::move(other181.key_value_metadata);
  data_page_offset = other181.data_page_offset;
  index_page_offset = other181.index_page_offset;
  dictionary_page_offset = other181.dictionary_page_offset;
  statistics = std::move(other181.statistics);
  encoding_stats = std::move(other181.encoding_stats);
  bloom_filter_offset = other181.bloom_filter_offset;
  __isset = other181.__isset;
  return *this;
}
void ColumnMetaData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnMetaData(";
  out << "type=" << to_string(type);
  out << ", "
      << "encodings=" << to_string(encodings);
  out << ", "
      << "path_in_schema=" << to_string(path_in_schema);
  out << ", "
      << "codec=" << to_string(codec);
  out << ", "
      << "num_values=" << to_string(num_values);
  out << ", "
      << "total_uncompressed_size=" << to_string(total_uncompressed_size);
  out << ", "
      << "total_compressed_size=" << to_string(total_compressed_size);
  out << ", "
      << "key_value_metadata=";
  (__isset.key_value_metadata ? (out << to_string(key_value_metadata))
                              : (out << "<null>"));
  out << ", "
      << "data_page_offset=" << to_string(data_page_offset);
  out << ", "
      << "index_page_offset=";
  (__isset.index_page_offset ? (out << to_string(index_page_offset))
                             : (out << "<null>"));
  out << ", "
      << "dictionary_page_offset=";
  (__isset.dictionary_page_offset ? (out << to_string(dictionary_page_offset))
                                  : (out << "<null>"));
  out << ", "
      << "statistics=";
  (__isset.statistics ? (out << to_string(statistics)) : (out << "<null>"));
  out << ", "
      << "encoding_stats=";
  (__isset.encoding_stats ? (out << to_string(encoding_stats))
                          : (out << "<null>"));
  out << ", "
      << "bloom_filter_offset=";
  (__isset.bloom_filter_offset ? (out << to_string(bloom_filter_offset))
                               : (out << "<null>"));
  out << ")";
}

EncryptionWithFooterKey::~EncryptionWithFooterKey() noexcept {}

std::ostream& operator<<(
    std::ostream& out,
    const EncryptionWithFooterKey& obj) {
  obj.printTo(out);
  return out;
}

uint32_t EncryptionWithFooterKey::read(
    ::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EncryptionWithFooterKey::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EncryptionWithFooterKey");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EncryptionWithFooterKey& a, EncryptionWithFooterKey& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

EncryptionWithFooterKey::EncryptionWithFooterKey(
    const EncryptionWithFooterKey& other182) noexcept {
  (void)other182;
}
EncryptionWithFooterKey::EncryptionWithFooterKey(
    EncryptionWithFooterKey&& other183) noexcept {
  (void)other183;
}
EncryptionWithFooterKey& EncryptionWithFooterKey::operator=(
    const EncryptionWithFooterKey& other184) noexcept {
  (void)other184;
  return *this;
}
EncryptionWithFooterKey& EncryptionWithFooterKey::operator=(
    EncryptionWithFooterKey&& other185) noexcept {
  (void)other185;
  return *this;
}
void EncryptionWithFooterKey::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EncryptionWithFooterKey(";
  out << ")";
}

EncryptionWithColumnKey::~EncryptionWithColumnKey() noexcept {}

void EncryptionWithColumnKey::__set_path_in_schema(
    const std::vector<std::string>& val) {
  this->path_in_schema = val;
}

void EncryptionWithColumnKey::__set_key_metadata(const std::string& val) {
  this->key_metadata = val;
  __isset.key_metadata = true;
}
std::ostream& operator<<(
    std::ostream& out,
    const EncryptionWithColumnKey& obj) {
  obj.printTo(out);
  return out;
}

uint32_t EncryptionWithColumnKey::read(
    ::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_path_in_schema = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->path_in_schema.clear();
            uint32_t _size186;
            ::apache::thrift::protocol::TType _etype189;
            xfer += iprot->readListBegin(_etype189, _size186);
            this->path_in_schema.resize(_size186);
            uint32_t _i190;
            for (_i190 = 0; _i190 < _size186; ++_i190) {
              xfer += iprot->readString(this->path_in_schema[_i190]);
            }
            xfer += iprot->readListEnd();
          }
          isset_path_in_schema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key_metadata);
          this->__isset.key_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_path_in_schema)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t EncryptionWithColumnKey::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EncryptionWithColumnKey");

  xfer += oprot->writeFieldBegin(
      "path_in_schema", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(
        ::apache::thrift::protocol::T_STRING,
        static_cast<uint32_t>(this->path_in_schema.size()));
    std::vector<std::string>::const_iterator _iter191;
    for (_iter191 = this->path_in_schema.begin();
         _iter191 != this->path_in_schema.end();
         ++_iter191) {
      xfer += oprot->writeString((*_iter191));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.key_metadata) {
    xfer += oprot->writeFieldBegin(
        "key_metadata", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->key_metadata);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EncryptionWithColumnKey& a, EncryptionWithColumnKey& b) {
  using ::std::swap;
  swap(a.path_in_schema, b.path_in_schema);
  swap(a.key_metadata, b.key_metadata);
  swap(a.__isset, b.__isset);
}

EncryptionWithColumnKey::EncryptionWithColumnKey(
    const EncryptionWithColumnKey& other192) {
  path_in_schema = other192.path_in_schema;
  key_metadata = other192.key_metadata;
  __isset = other192.__isset;
}
EncryptionWithColumnKey::EncryptionWithColumnKey(
    EncryptionWithColumnKey&& other193) noexcept {
  path_in_schema = std::move(other193.path_in_schema);
  key_metadata = std::move(other193.key_metadata);
  __isset = other193.__isset;
}
EncryptionWithColumnKey& EncryptionWithColumnKey::operator=(
    const EncryptionWithColumnKey& other194) {
  path_in_schema = other194.path_in_schema;
  key_metadata = other194.key_metadata;
  __isset = other194.__isset;
  return *this;
}
EncryptionWithColumnKey& EncryptionWithColumnKey::operator=(
    EncryptionWithColumnKey&& other195) noexcept {
  path_in_schema = std::move(other195.path_in_schema);
  key_metadata = std::move(other195.key_metadata);
  __isset = other195.__isset;
  return *this;
}
void EncryptionWithColumnKey::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EncryptionWithColumnKey(";
  out << "path_in_schema=" << to_string(path_in_schema);
  out << ", "
      << "key_metadata=";
  (__isset.key_metadata ? (out << to_string(key_metadata)) : (out << "<null>"));
  out << ")";
}

ColumnCryptoMetaData::~ColumnCryptoMetaData() noexcept {}

void ColumnCryptoMetaData::__set_ENCRYPTION_WITH_FOOTER_KEY(
    const EncryptionWithFooterKey& val) {
  this->ENCRYPTION_WITH_FOOTER_KEY = val;
  __isset.ENCRYPTION_WITH_FOOTER_KEY = true;
}

void ColumnCryptoMetaData::__set_ENCRYPTION_WITH_COLUMN_KEY(
    const EncryptionWithColumnKey& val) {
  this->ENCRYPTION_WITH_COLUMN_KEY = val;
  __isset.ENCRYPTION_WITH_COLUMN_KEY = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnCryptoMetaData& obj) {
  obj.printTo(out);
  return out;
}

uint32_t ColumnCryptoMetaData::read(
    ::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ENCRYPTION_WITH_FOOTER_KEY.read(iprot);
          this->__isset.ENCRYPTION_WITH_FOOTER_KEY = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ENCRYPTION_WITH_COLUMN_KEY.read(iprot);
          this->__isset.ENCRYPTION_WITH_COLUMN_KEY = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnCryptoMetaData::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnCryptoMetaData");

  if (this->__isset.ENCRYPTION_WITH_FOOTER_KEY) {
    xfer += oprot->writeFieldBegin(
        "ENCRYPTION_WITH_FOOTER_KEY", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ENCRYPTION_WITH_FOOTER_KEY.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ENCRYPTION_WITH_COLUMN_KEY) {
    xfer += oprot->writeFieldBegin(
        "ENCRYPTION_WITH_COLUMN_KEY", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->ENCRYPTION_WITH_COLUMN_KEY.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnCryptoMetaData& a, ColumnCryptoMetaData& b) {
  using ::std::swap;
  swap(a.ENCRYPTION_WITH_FOOTER_KEY, b.ENCRYPTION_WITH_FOOTER_KEY);
  swap(a.ENCRYPTION_WITH_COLUMN_KEY, b.ENCRYPTION_WITH_COLUMN_KEY);
  swap(a.__isset, b.__isset);
}

ColumnCryptoMetaData::ColumnCryptoMetaData(
    const ColumnCryptoMetaData& other196) {
  ENCRYPTION_WITH_FOOTER_KEY = other196.ENCRYPTION_WITH_FOOTER_KEY;
  ENCRYPTION_WITH_COLUMN_KEY = other196.ENCRYPTION_WITH_COLUMN_KEY;
  __isset = other196.__isset;
}
ColumnCryptoMetaData::ColumnCryptoMetaData(
    ColumnCryptoMetaData&& other197) noexcept {
  ENCRYPTION_WITH_FOOTER_KEY = std::move(other197.ENCRYPTION_WITH_FOOTER_KEY);
  ENCRYPTION_WITH_COLUMN_KEY = std::move(other197.ENCRYPTION_WITH_COLUMN_KEY);
  __isset = other197.__isset;
}
ColumnCryptoMetaData& ColumnCryptoMetaData::operator=(
    const ColumnCryptoMetaData& other198) {
  ENCRYPTION_WITH_FOOTER_KEY = other198.ENCRYPTION_WITH_FOOTER_KEY;
  ENCRYPTION_WITH_COLUMN_KEY = other198.ENCRYPTION_WITH_COLUMN_KEY;
  __isset = other198.__isset;
  return *this;
}
ColumnCryptoMetaData& ColumnCryptoMetaData::operator=(
    ColumnCryptoMetaData&& other199) noexcept {
  ENCRYPTION_WITH_FOOTER_KEY = std::move(other199.ENCRYPTION_WITH_FOOTER_KEY);
  ENCRYPTION_WITH_COLUMN_KEY = std::move(other199.ENCRYPTION_WITH_COLUMN_KEY);
  __isset = other199.__isset;
  return *this;
}
void ColumnCryptoMetaData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnCryptoMetaData(";
  out << "ENCRYPTION_WITH_FOOTER_KEY=";
  (__isset.ENCRYPTION_WITH_FOOTER_KEY
       ? (out << to_string(ENCRYPTION_WITH_FOOTER_KEY))
       : (out << "<null>"));
  out << ", "
      << "ENCRYPTION_WITH_COLUMN_KEY=";
  (__isset.ENCRYPTION_WITH_COLUMN_KEY
       ? (out << to_string(ENCRYPTION_WITH_COLUMN_KEY))
       : (out << "<null>"));
  out << ")";
}

ColumnChunk::~ColumnChunk() noexcept {}

void ColumnChunk::__set_file_path(const std::string& val) {
  this->file_path = val;
  __isset.file_path = true;
}

void ColumnChunk::__set_file_offset(const int64_t val) {
  this->file_offset = val;
}

void ColumnChunk::__set_meta_data(const ColumnMetaData& val) {
  this->meta_data = val;
  __isset.meta_data = true;
}

void ColumnChunk::__set_offset_index_offset(const int64_t val) {
  this->offset_index_offset = val;
  __isset.offset_index_offset = true;
}

void ColumnChunk::__set_offset_index_length(const int32_t val) {
  this->offset_index_length = val;
  __isset.offset_index_length = true;
}

void ColumnChunk::__set_column_index_offset(const int64_t val) {
  this->column_index_offset = val;
  __isset.column_index_offset = true;
}

void ColumnChunk::__set_column_index_length(const int32_t val) {
  this->column_index_length = val;
  __isset.column_index_length = true;
}

void ColumnChunk::__set_crypto_metadata(const ColumnCryptoMetaData& val) {
  this->crypto_metadata = val;
  __isset.crypto_metadata = true;
}

void ColumnChunk::__set_encrypted_column_metadata(const std::string& val) {
  this->encrypted_column_metadata = val;
  __isset.encrypted_column_metadata = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnChunk& obj) {
  obj.printTo(out);
  return out;
}

uint32_t ColumnChunk::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_file_offset = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_path);
          this->__isset.file_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->file_offset);
          isset_file_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->meta_data.read(iprot);
          this->__isset.meta_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset_index_offset);
          this->__isset.offset_index_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->offset_index_length);
          this->__isset.offset_index_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->column_index_offset);
          this->__isset.column_index_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->column_index_length);
          this->__isset.column_index_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->crypto_metadata.read(iprot);
          this->__isset.crypto_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->encrypted_column_metadata);
          this->__isset.encrypted_column_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_file_offset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnChunk::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnChunk");

  if (this->__isset.file_path) {
    xfer += oprot->writeFieldBegin(
        "file_path", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->file_path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin(
      "file_offset", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->file_offset);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.meta_data) {
    xfer += oprot->writeFieldBegin(
        "meta_data", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->meta_data.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset_index_offset) {
    xfer += oprot->writeFieldBegin(
        "offset_index_offset", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->offset_index_offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset_index_length) {
    xfer += oprot->writeFieldBegin(
        "offset_index_length", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->offset_index_length);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_index_offset) {
    xfer += oprot->writeFieldBegin(
        "column_index_offset", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->column_index_offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_index_length) {
    xfer += oprot->writeFieldBegin(
        "column_index_length", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->column_index_length);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.crypto_metadata) {
    xfer += oprot->writeFieldBegin(
        "crypto_metadata", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->crypto_metadata.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.encrypted_column_metadata) {
    xfer += oprot->writeFieldBegin(
        "encrypted_column_metadata", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeBinary(this->encrypted_column_metadata);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnChunk& a, ColumnChunk& b) {
  using ::std::swap;
  swap(a.file_path, b.file_path);
  swap(a.file_offset, b.file_offset);
  swap(a.meta_data, b.meta_data);
  swap(a.offset_index_offset, b.offset_index_offset);
  swap(a.offset_index_length, b.offset_index_length);
  swap(a.column_index_offset, b.column_index_offset);
  swap(a.column_index_length, b.column_index_length);
  swap(a.crypto_metadata, b.crypto_metadata);
  swap(a.encrypted_column_metadata, b.encrypted_column_metadata);
  swap(a.__isset, b.__isset);
}

ColumnChunk::ColumnChunk(const ColumnChunk& other200) {
  file_path = other200.file_path;
  file_offset = other200.file_offset;
  meta_data = other200.meta_data;
  offset_index_offset = other200.offset_index_offset;
  offset_index_length = other200.offset_index_length;
  column_index_offset = other200.column_index_offset;
  column_index_length = other200.column_index_length;
  crypto_metadata = other200.crypto_metadata;
  encrypted_column_metadata = other200.encrypted_column_metadata;
  __isset = other200.__isset;
}
ColumnChunk::ColumnChunk(ColumnChunk&& other201) noexcept {
  file_path = std::move(other201.file_path);
  file_offset = other201.file_offset;
  meta_data = std::move(other201.meta_data);
  offset_index_offset = other201.offset_index_offset;
  offset_index_length = other201.offset_index_length;
  column_index_offset = other201.column_index_offset;
  column_index_length = other201.column_index_length;
  crypto_metadata = std::move(other201.crypto_metadata);
  encrypted_column_metadata = std::move(other201.encrypted_column_metadata);
  __isset = other201.__isset;
}
ColumnChunk& ColumnChunk::operator=(const ColumnChunk& other202) {
  file_path = other202.file_path;
  file_offset = other202.file_offset;
  meta_data = other202.meta_data;
  offset_index_offset = other202.offset_index_offset;
  offset_index_length = other202.offset_index_length;
  column_index_offset = other202.column_index_offset;
  column_index_length = other202.column_index_length;
  crypto_metadata = other202.crypto_metadata;
  encrypted_column_metadata = other202.encrypted_column_metadata;
  __isset = other202.__isset;
  return *this;
}
ColumnChunk& ColumnChunk::operator=(ColumnChunk&& other203) noexcept {
  file_path = std::move(other203.file_path);
  file_offset = other203.file_offset;
  meta_data = std::move(other203.meta_data);
  offset_index_offset = other203.offset_index_offset;
  offset_index_length = other203.offset_index_length;
  column_index_offset = other203.column_index_offset;
  column_index_length = other203.column_index_length;
  crypto_metadata = std::move(other203.crypto_metadata);
  encrypted_column_metadata = std::move(other203.encrypted_column_metadata);
  __isset = other203.__isset;
  return *this;
}
void ColumnChunk::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnChunk(";
  out << "file_path=";
  (__isset.file_path ? (out << to_string(file_path)) : (out << "<null>"));
  out << ", "
      << "file_offset=" << to_string(file_offset);
  out << ", "
      << "meta_data=";
  (__isset.meta_data ? (out << to_string(meta_data)) : (out << "<null>"));
  out << ", "
      << "offset_index_offset=";
  (__isset.offset_index_offset ? (out << to_string(offset_index_offset))
                               : (out << "<null>"));
  out << ", "
      << "offset_index_length=";
  (__isset.offset_index_length ? (out << to_string(offset_index_length))
                               : (out << "<null>"));
  out << ", "
      << "column_index_offset=";
  (__isset.column_index_offset ? (out << to_string(column_index_offset))
                               : (out << "<null>"));
  out << ", "
      << "column_index_length=";
  (__isset.column_index_length ? (out << to_string(column_index_length))
                               : (out << "<null>"));
  out << ", "
      << "crypto_metadata=";
  (__isset.crypto_metadata ? (out << to_string(crypto_metadata))
                           : (out << "<null>"));
  out << ", "
      << "encrypted_column_metadata=";
  (__isset.encrypted_column_metadata
       ? (out << to_string(encrypted_column_metadata))
       : (out << "<null>"));
  out << ")";
}

RowGroup::~RowGroup() noexcept {}

void RowGroup::__set_columns(const std::vector<ColumnChunk>& val) {
  this->columns = val;
}

void RowGroup::__set_total_byte_size(const int64_t val) {
  this->total_byte_size = val;
}

void RowGroup::__set_num_rows(const int64_t val) {
  this->num_rows = val;
}

void RowGroup::__set_sorting_columns(const std::vector<SortingColumn>& val) {
  this->sorting_columns = val;
  __isset.sorting_columns = true;
}

void RowGroup::__set_file_offset(const int64_t val) {
  this->file_offset = val;
  __isset.file_offset = true;
}

void RowGroup::__set_total_compressed_size(const int64_t val) {
  this->total_compressed_size = val;
  __isset.total_compressed_size = true;
}

void RowGroup::__set_ordinal(const int16_t val) {
  this->ordinal = val;
  __isset.ordinal = true;
}
std::ostream& operator<<(std::ostream& out, const RowGroup& obj) {
  obj.printTo(out);
  return out;
}

uint32_t RowGroup::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;
  bool isset_total_byte_size = false;
  bool isset_num_rows = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size204;
            ::apache::thrift::protocol::TType _etype207;
            xfer += iprot->readListBegin(_etype207, _size204);
            this->columns.resize(_size204);
            uint32_t _i208;
            for (_i208 = 0; _i208 < _size204; ++_i208) {
              xfer += this->columns[_i208].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_byte_size);
          isset_total_byte_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_rows);
          isset_num_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sorting_columns.clear();
            uint32_t _size209;
            ::apache::thrift::protocol::TType _etype212;
            xfer += iprot->readListBegin(_etype212, _size209);
            this->sorting_columns.resize(_size209);
            uint32_t _i213;
            for (_i213 = 0; _i213 < _size209; ++_i213) {
              xfer += this->sorting_columns[_i213].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sorting_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->file_offset);
          this->__isset.file_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_compressed_size);
          this->__isset.total_compressed_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->ordinal);
          this->__isset.ordinal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_total_byte_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_rows)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RowGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RowGroup");

  xfer +=
      oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(
        ::apache::thrift::protocol::T_STRUCT,
        static_cast<uint32_t>(this->columns.size()));
    std::vector<ColumnChunk>::const_iterator _iter214;
    for (_iter214 = this->columns.begin(); _iter214 != this->columns.end();
         ++_iter214) {
      xfer += (*_iter214).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "total_byte_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->total_byte_size);
  xfer += oprot->writeFieldEnd();

  xfer +=
      oprot->writeFieldBegin("num_rows", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->num_rows);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sorting_columns) {
    xfer += oprot->writeFieldBegin(
        "sorting_columns", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(
          ::apache::thrift::protocol::T_STRUCT,
          static_cast<uint32_t>(this->sorting_columns.size()));
      std::vector<SortingColumn>::const_iterator _iter215;
      for (_iter215 = this->sorting_columns.begin();
           _iter215 != this->sorting_columns.end();
           ++_iter215) {
        xfer += (*_iter215).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_offset) {
    xfer += oprot->writeFieldBegin(
        "file_offset", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->file_offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.total_compressed_size) {
    xfer += oprot->writeFieldBegin(
        "total_compressed_size", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->total_compressed_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ordinal) {
    xfer +=
        oprot->writeFieldBegin("ordinal", ::apache::thrift::protocol::T_I16, 7);
    xfer += oprot->writeI16(this->ordinal);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RowGroup& a, RowGroup& b) {
  using ::std::swap;
  swap(a.columns, b.columns);
  swap(a.total_byte_size, b.total_byte_size);
  swap(a.num_rows, b.num_rows);
  swap(a.sorting_columns, b.sorting_columns);
  swap(a.file_offset, b.file_offset);
  swap(a.total_compressed_size, b.total_compressed_size);
  swap(a.ordinal, b.ordinal);
  swap(a.__isset, b.__isset);
}

RowGroup::RowGroup(const RowGroup& other216) {
  columns = other216.columns;
  total_byte_size = other216.total_byte_size;
  num_rows = other216.num_rows;
  sorting_columns = other216.sorting_columns;
  file_offset = other216.file_offset;
  total_compressed_size = other216.total_compressed_size;
  ordinal = other216.ordinal;
  __isset = other216.__isset;
}
RowGroup::RowGroup(RowGroup&& other217) noexcept {
  columns = std::move(other217.columns);
  total_byte_size = other217.total_byte_size;
  num_rows = other217.num_rows;
  sorting_columns = std::move(other217.sorting_columns);
  file_offset = other217.file_offset;
  total_compressed_size = other217.total_compressed_size;
  ordinal = other217.ordinal;
  __isset = other217.__isset;
}
RowGroup& RowGroup::operator=(const RowGroup& other218) {
  columns = other218.columns;
  total_byte_size = other218.total_byte_size;
  num_rows = other218.num_rows;
  sorting_columns = other218.sorting_columns;
  file_offset = other218.file_offset;
  total_compressed_size = other218.total_compressed_size;
  ordinal = other218.ordinal;
  __isset = other218.__isset;
  return *this;
}
RowGroup& RowGroup::operator=(RowGroup&& other219) noexcept {
  columns = std::move(other219.columns);
  total_byte_size = other219.total_byte_size;
  num_rows = other219.num_rows;
  sorting_columns = std::move(other219.sorting_columns);
  file_offset = other219.file_offset;
  total_compressed_size = other219.total_compressed_size;
  ordinal = other219.ordinal;
  __isset = other219.__isset;
  return *this;
}
void RowGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RowGroup(";
  out << "columns=" << to_string(columns);
  out << ", "
      << "total_byte_size=" << to_string(total_byte_size);
  out << ", "
      << "num_rows=" << to_string(num_rows);
  out << ", "
      << "sorting_columns=";
  (__isset.sorting_columns ? (out << to_string(sorting_columns))
                           : (out << "<null>"));
  out << ", "
      << "file_offset=";
  (__isset.file_offset ? (out << to_string(file_offset)) : (out << "<null>"));
  out << ", "
      << "total_compressed_size=";
  (__isset.total_compressed_size ? (out << to_string(total_compressed_size))
                                 : (out << "<null>"));
  out << ", "
      << "ordinal=";
  (__isset.ordinal ? (out << to_string(ordinal)) : (out << "<null>"));
  out << ")";
}

TypeDefinedOrder::~TypeDefinedOrder() noexcept {}

std::ostream& operator<<(std::ostream& out, const TypeDefinedOrder& obj) {
  obj.printTo(out);
  return out;
}

uint32_t TypeDefinedOrder::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TypeDefinedOrder::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TypeDefinedOrder");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TypeDefinedOrder& a, TypeDefinedOrder& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

TypeDefinedOrder::TypeDefinedOrder(const TypeDefinedOrder& other220) noexcept {
  (void)other220;
}
TypeDefinedOrder::TypeDefinedOrder(TypeDefinedOrder&& other221) noexcept {
  (void)other221;
}
TypeDefinedOrder& TypeDefinedOrder::operator=(
    const TypeDefinedOrder& other222) noexcept {
  (void)other222;
  return *this;
}
TypeDefinedOrder& TypeDefinedOrder::operator=(
    TypeDefinedOrder&& other223) noexcept {
  (void)other223;
  return *this;
}
void TypeDefinedOrder::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TypeDefinedOrder(";
  out << ")";
}

ColumnOrder::~ColumnOrder() noexcept {}

void ColumnOrder::__set_TYPE_ORDER(const TypeDefinedOrder& val) {
  this->TYPE_ORDER = val;
  __isset.TYPE_ORDER = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnOrder& obj) {
  obj.printTo(out);
  return out;
}

uint32_t ColumnOrder::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->TYPE_ORDER.read(iprot);
          this->__isset.TYPE_ORDER = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnOrder::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnOrder");

  if (this->__isset.TYPE_ORDER) {
    xfer += oprot->writeFieldBegin(
        "TYPE_ORDER", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->TYPE_ORDER.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnOrder& a, ColumnOrder& b) {
  using ::std::swap;
  swap(a.TYPE_ORDER, b.TYPE_ORDER);
  swap(a.__isset, b.__isset);
}

ColumnOrder::ColumnOrder(const ColumnOrder& other224) noexcept {
  TYPE_ORDER = other224.TYPE_ORDER;
  __isset = other224.__isset;
}
ColumnOrder::ColumnOrder(ColumnOrder&& other225) noexcept {
  TYPE_ORDER = std::move(other225.TYPE_ORDER);
  __isset = other225.__isset;
}
ColumnOrder& ColumnOrder::operator=(const ColumnOrder& other226) noexcept {
  TYPE_ORDER = other226.TYPE_ORDER;
  __isset = other226.__isset;
  return *this;
}
ColumnOrder& ColumnOrder::operator=(ColumnOrder&& other227) noexcept {
  TYPE_ORDER = std::move(other227.TYPE_ORDER);
  __isset = other227.__isset;
  return *this;
}
void ColumnOrder::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnOrder(";
  out << "TYPE_ORDER=";
  (__isset.TYPE_ORDER ? (out << to_string(TYPE_ORDER)) : (out << "<null>"));
  out << ")";
}

PageLocation::~PageLocation() noexcept {}

void PageLocation::__set_offset(const int64_t val) {
  this->offset = val;
}

void PageLocation::__set_compressed_page_size(const int32_t val) {
  this->compressed_page_size = val;
}

void PageLocation::__set_first_row_index(const int64_t val) {
  this->first_row_index = val;
}
std::ostream& operator<<(std::ostream& out, const PageLocation& obj) {
  obj.printTo(out);
  return out;
}

uint32_t PageLocation::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_offset = false;
  bool isset_compressed_page_size = false;
  bool isset_first_row_index = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          isset_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->compressed_page_size);
          isset_compressed_page_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->first_row_index);
          isset_first_row_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_offset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_compressed_page_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_first_row_index)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PageLocation::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PageLocation");

  xfer +=
      oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "compressed_page_size", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->compressed_page_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "first_row_index", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->first_row_index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PageLocation& a, PageLocation& b) {
  using ::std::swap;
  swap(a.offset, b.offset);
  swap(a.compressed_page_size, b.compressed_page_size);
  swap(a.first_row_index, b.first_row_index);
}

PageLocation::PageLocation(const PageLocation& other228) noexcept {
  offset = other228.offset;
  compressed_page_size = other228.compressed_page_size;
  first_row_index = other228.first_row_index;
}
PageLocation::PageLocation(PageLocation&& other229) noexcept {
  offset = other229.offset;
  compressed_page_size = other229.compressed_page_size;
  first_row_index = other229.first_row_index;
}
PageLocation& PageLocation::operator=(const PageLocation& other230) noexcept {
  offset = other230.offset;
  compressed_page_size = other230.compressed_page_size;
  first_row_index = other230.first_row_index;
  return *this;
}
PageLocation& PageLocation::operator=(PageLocation&& other231) noexcept {
  offset = other231.offset;
  compressed_page_size = other231.compressed_page_size;
  first_row_index = other231.first_row_index;
  return *this;
}
void PageLocation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PageLocation(";
  out << "offset=" << to_string(offset);
  out << ", "
      << "compressed_page_size=" << to_string(compressed_page_size);
  out << ", "
      << "first_row_index=" << to_string(first_row_index);
  out << ")";
}

OffsetIndex::~OffsetIndex() noexcept {}

void OffsetIndex::__set_page_locations(const std::vector<PageLocation>& val) {
  this->page_locations = val;
}
std::ostream& operator<<(std::ostream& out, const OffsetIndex& obj) {
  obj.printTo(out);
  return out;
}

uint32_t OffsetIndex::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_page_locations = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->page_locations.clear();
            uint32_t _size232;
            ::apache::thrift::protocol::TType _etype235;
            xfer += iprot->readListBegin(_etype235, _size232);
            this->page_locations.resize(_size232);
            uint32_t _i236;
            for (_i236 = 0; _i236 < _size232; ++_i236) {
              xfer += this->page_locations[_i236].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_page_locations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_page_locations)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OffsetIndex::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OffsetIndex");

  xfer += oprot->writeFieldBegin(
      "page_locations", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(
        ::apache::thrift::protocol::T_STRUCT,
        static_cast<uint32_t>(this->page_locations.size()));
    std::vector<PageLocation>::const_iterator _iter237;
    for (_iter237 = this->page_locations.begin();
         _iter237 != this->page_locations.end();
         ++_iter237) {
      xfer += (*_iter237).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OffsetIndex& a, OffsetIndex& b) {
  using ::std::swap;
  swap(a.page_locations, b.page_locations);
}

OffsetIndex::OffsetIndex(const OffsetIndex& other238) {
  page_locations = other238.page_locations;
}
OffsetIndex::OffsetIndex(OffsetIndex&& other239) noexcept {
  page_locations = std::move(other239.page_locations);
}
OffsetIndex& OffsetIndex::operator=(const OffsetIndex& other240) {
  page_locations = other240.page_locations;
  return *this;
}
OffsetIndex& OffsetIndex::operator=(OffsetIndex&& other241) noexcept {
  page_locations = std::move(other241.page_locations);
  return *this;
}
void OffsetIndex::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OffsetIndex(";
  out << "page_locations=" << to_string(page_locations);
  out << ")";
}

ColumnIndex::~ColumnIndex() noexcept {}

void ColumnIndex::__set_null_pages(const std::vector<bool>& val) {
  this->null_pages = val;
}

void ColumnIndex::__set_min_values(const std::vector<std::string>& val) {
  this->min_values = val;
}

void ColumnIndex::__set_max_values(const std::vector<std::string>& val) {
  this->max_values = val;
}

void ColumnIndex::__set_boundary_order(const BoundaryOrder::type val) {
  this->boundary_order = val;
}

void ColumnIndex::__set_null_counts(const std::vector<int64_t>& val) {
  this->null_counts = val;
  __isset.null_counts = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnIndex& obj) {
  obj.printTo(out);
  return out;
}

uint32_t ColumnIndex::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_null_pages = false;
  bool isset_min_values = false;
  bool isset_max_values = false;
  bool isset_boundary_order = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->null_pages.clear();
            uint32_t _size242;
            ::apache::thrift::protocol::TType _etype245;
            xfer += iprot->readListBegin(_etype245, _size242);
            this->null_pages.resize(_size242);
            uint32_t _i246;
            for (_i246 = 0; _i246 < _size242; ++_i246) {
              xfer += iprot->readBool(this->null_pages[_i246]);
            }
            xfer += iprot->readListEnd();
          }
          isset_null_pages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->min_values.clear();
            uint32_t _size247;
            ::apache::thrift::protocol::TType _etype250;
            xfer += iprot->readListBegin(_etype250, _size247);
            this->min_values.resize(_size247);
            uint32_t _i251;
            for (_i251 = 0; _i251 < _size247; ++_i251) {
              xfer += iprot->readBinary(this->min_values[_i251]);
            }
            xfer += iprot->readListEnd();
          }
          isset_min_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->max_values.clear();
            uint32_t _size252;
            ::apache::thrift::protocol::TType _etype255;
            xfer += iprot->readListBegin(_etype255, _size252);
            this->max_values.resize(_size252);
            uint32_t _i256;
            for (_i256 = 0; _i256 < _size252; ++_i256) {
              xfer += iprot->readBinary(this->max_values[_i256]);
            }
            xfer += iprot->readListEnd();
          }
          isset_max_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast257;
          xfer += iprot->readI32(ecast257);
          this->boundary_order = static_cast<BoundaryOrder::type>(ecast257);
          isset_boundary_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->null_counts.clear();
            uint32_t _size258;
            ::apache::thrift::protocol::TType _etype261;
            xfer += iprot->readListBegin(_etype261, _size258);
            this->null_counts.resize(_size258);
            uint32_t _i262;
            for (_i262 = 0; _i262 < _size258; ++_i262) {
              xfer += iprot->readI64(this->null_counts[_i262]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.null_counts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_null_pages)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_min_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_max_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_boundary_order)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnIndex::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnIndex");

  xfer += oprot->writeFieldBegin(
      "null_pages", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(
        ::apache::thrift::protocol::T_BOOL,
        static_cast<uint32_t>(this->null_pages.size()));
    std::vector<bool>::const_iterator _iter263;
    for (_iter263 = this->null_pages.begin();
         _iter263 != this->null_pages.end();
         ++_iter263) {
      xfer += oprot->writeBool((*_iter263));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "min_values", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(
        ::apache::thrift::protocol::T_STRING,
        static_cast<uint32_t>(this->min_values.size()));
    std::vector<std::string>::const_iterator _iter264;
    for (_iter264 = this->min_values.begin();
         _iter264 != this->min_values.end();
         ++_iter264) {
      xfer += oprot->writeBinary((*_iter264));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "max_values", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(
        ::apache::thrift::protocol::T_STRING,
        static_cast<uint32_t>(this->max_values.size()));
    std::vector<std::string>::const_iterator _iter265;
    for (_iter265 = this->max_values.begin();
         _iter265 != this->max_values.end();
         ++_iter265) {
      xfer += oprot->writeBinary((*_iter265));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "boundary_order", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(static_cast<int32_t>(this->boundary_order));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.null_counts) {
    xfer += oprot->writeFieldBegin(
        "null_counts", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(
          ::apache::thrift::protocol::T_I64,
          static_cast<uint32_t>(this->null_counts.size()));
      std::vector<int64_t>::const_iterator _iter266;
      for (_iter266 = this->null_counts.begin();
           _iter266 != this->null_counts.end();
           ++_iter266) {
        xfer += oprot->writeI64((*_iter266));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnIndex& a, ColumnIndex& b) {
  using ::std::swap;
  swap(a.null_pages, b.null_pages);
  swap(a.min_values, b.min_values);
  swap(a.max_values, b.max_values);
  swap(a.boundary_order, b.boundary_order);
  swap(a.null_counts, b.null_counts);
  swap(a.__isset, b.__isset);
}

ColumnIndex::ColumnIndex(const ColumnIndex& other267) {
  null_pages = other267.null_pages;
  min_values = other267.min_values;
  max_values = other267.max_values;
  boundary_order = other267.boundary_order;
  null_counts = other267.null_counts;
  __isset = other267.__isset;
}
ColumnIndex::ColumnIndex(ColumnIndex&& other268) noexcept {
  null_pages = std::move(other268.null_pages);
  min_values = std::move(other268.min_values);
  max_values = std::move(other268.max_values);
  boundary_order = other268.boundary_order;
  null_counts = std::move(other268.null_counts);
  __isset = other268.__isset;
}
ColumnIndex& ColumnIndex::operator=(const ColumnIndex& other269) {
  null_pages = other269.null_pages;
  min_values = other269.min_values;
  max_values = other269.max_values;
  boundary_order = other269.boundary_order;
  null_counts = other269.null_counts;
  __isset = other269.__isset;
  return *this;
}
ColumnIndex& ColumnIndex::operator=(ColumnIndex&& other270) noexcept {
  null_pages = std::move(other270.null_pages);
  min_values = std::move(other270.min_values);
  max_values = std::move(other270.max_values);
  boundary_order = other270.boundary_order;
  null_counts = std::move(other270.null_counts);
  __isset = other270.__isset;
  return *this;
}
void ColumnIndex::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnIndex(";
  out << "null_pages=" << to_string(null_pages);
  out << ", "
      << "min_values=" << to_string(min_values);
  out << ", "
      << "max_values=" << to_string(max_values);
  out << ", "
      << "boundary_order=" << to_string(boundary_order);
  out << ", "
      << "null_counts=";
  (__isset.null_counts ? (out << to_string(null_counts)) : (out << "<null>"));
  out << ")";
}

AesGcmV1::~AesGcmV1() noexcept {}

void AesGcmV1::__set_aad_prefix(const std::string& val) {
  this->aad_prefix = val;
  __isset.aad_prefix = true;
}

void AesGcmV1::__set_aad_file_unique(const std::string& val) {
  this->aad_file_unique = val;
  __isset.aad_file_unique = true;
}

void AesGcmV1::__set_supply_aad_prefix(const bool val) {
  this->supply_aad_prefix = val;
  __isset.supply_aad_prefix = true;
}
std::ostream& operator<<(std::ostream& out, const AesGcmV1& obj) {
  obj.printTo(out);
  return out;
}

uint32_t AesGcmV1::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aad_prefix);
          this->__isset.aad_prefix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aad_file_unique);
          this->__isset.aad_file_unique = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->supply_aad_prefix);
          this->__isset.supply_aad_prefix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AesGcmV1::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AesGcmV1");

  if (this->__isset.aad_prefix) {
    xfer += oprot->writeFieldBegin(
        "aad_prefix", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->aad_prefix);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.aad_file_unique) {
    xfer += oprot->writeFieldBegin(
        "aad_file_unique", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->aad_file_unique);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.supply_aad_prefix) {
    xfer += oprot->writeFieldBegin(
        "supply_aad_prefix", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->supply_aad_prefix);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AesGcmV1& a, AesGcmV1& b) {
  using ::std::swap;
  swap(a.aad_prefix, b.aad_prefix);
  swap(a.aad_file_unique, b.aad_file_unique);
  swap(a.supply_aad_prefix, b.supply_aad_prefix);
  swap(a.__isset, b.__isset);
}

AesGcmV1::AesGcmV1(const AesGcmV1& other271) {
  aad_prefix = other271.aad_prefix;
  aad_file_unique = other271.aad_file_unique;
  supply_aad_prefix = other271.supply_aad_prefix;
  __isset = other271.__isset;
}
AesGcmV1::AesGcmV1(AesGcmV1&& other272) noexcept {
  aad_prefix = std::move(other272.aad_prefix);
  aad_file_unique = std::move(other272.aad_file_unique);
  supply_aad_prefix = other272.supply_aad_prefix;
  __isset = other272.__isset;
}
AesGcmV1& AesGcmV1::operator=(const AesGcmV1& other273) {
  aad_prefix = other273.aad_prefix;
  aad_file_unique = other273.aad_file_unique;
  supply_aad_prefix = other273.supply_aad_prefix;
  __isset = other273.__isset;
  return *this;
}
AesGcmV1& AesGcmV1::operator=(AesGcmV1&& other274) noexcept {
  aad_prefix = std::move(other274.aad_prefix);
  aad_file_unique = std::move(other274.aad_file_unique);
  supply_aad_prefix = other274.supply_aad_prefix;
  __isset = other274.__isset;
  return *this;
}
void AesGcmV1::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AesGcmV1(";
  out << "aad_prefix=";
  (__isset.aad_prefix ? (out << to_string(aad_prefix)) : (out << "<null>"));
  out << ", "
      << "aad_file_unique=";
  (__isset.aad_file_unique ? (out << to_string(aad_file_unique))
                           : (out << "<null>"));
  out << ", "
      << "supply_aad_prefix=";
  (__isset.supply_aad_prefix ? (out << to_string(supply_aad_prefix))
                             : (out << "<null>"));
  out << ")";
}

AesGcmCtrV1::~AesGcmCtrV1() noexcept {}

void AesGcmCtrV1::__set_aad_prefix(const std::string& val) {
  this->aad_prefix = val;
  __isset.aad_prefix = true;
}

void AesGcmCtrV1::__set_aad_file_unique(const std::string& val) {
  this->aad_file_unique = val;
  __isset.aad_file_unique = true;
}

void AesGcmCtrV1::__set_supply_aad_prefix(const bool val) {
  this->supply_aad_prefix = val;
  __isset.supply_aad_prefix = true;
}
std::ostream& operator<<(std::ostream& out, const AesGcmCtrV1& obj) {
  obj.printTo(out);
  return out;
}

uint32_t AesGcmCtrV1::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aad_prefix);
          this->__isset.aad_prefix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aad_file_unique);
          this->__isset.aad_file_unique = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->supply_aad_prefix);
          this->__isset.supply_aad_prefix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AesGcmCtrV1::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AesGcmCtrV1");

  if (this->__isset.aad_prefix) {
    xfer += oprot->writeFieldBegin(
        "aad_prefix", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->aad_prefix);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.aad_file_unique) {
    xfer += oprot->writeFieldBegin(
        "aad_file_unique", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->aad_file_unique);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.supply_aad_prefix) {
    xfer += oprot->writeFieldBegin(
        "supply_aad_prefix", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->supply_aad_prefix);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AesGcmCtrV1& a, AesGcmCtrV1& b) {
  using ::std::swap;
  swap(a.aad_prefix, b.aad_prefix);
  swap(a.aad_file_unique, b.aad_file_unique);
  swap(a.supply_aad_prefix, b.supply_aad_prefix);
  swap(a.__isset, b.__isset);
}

AesGcmCtrV1::AesGcmCtrV1(const AesGcmCtrV1& other275) {
  aad_prefix = other275.aad_prefix;
  aad_file_unique = other275.aad_file_unique;
  supply_aad_prefix = other275.supply_aad_prefix;
  __isset = other275.__isset;
}
AesGcmCtrV1::AesGcmCtrV1(AesGcmCtrV1&& other276) noexcept {
  aad_prefix = std::move(other276.aad_prefix);
  aad_file_unique = std::move(other276.aad_file_unique);
  supply_aad_prefix = other276.supply_aad_prefix;
  __isset = other276.__isset;
}
AesGcmCtrV1& AesGcmCtrV1::operator=(const AesGcmCtrV1& other277) {
  aad_prefix = other277.aad_prefix;
  aad_file_unique = other277.aad_file_unique;
  supply_aad_prefix = other277.supply_aad_prefix;
  __isset = other277.__isset;
  return *this;
}
AesGcmCtrV1& AesGcmCtrV1::operator=(AesGcmCtrV1&& other278) noexcept {
  aad_prefix = std::move(other278.aad_prefix);
  aad_file_unique = std::move(other278.aad_file_unique);
  supply_aad_prefix = other278.supply_aad_prefix;
  __isset = other278.__isset;
  return *this;
}
void AesGcmCtrV1::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AesGcmCtrV1(";
  out << "aad_prefix=";
  (__isset.aad_prefix ? (out << to_string(aad_prefix)) : (out << "<null>"));
  out << ", "
      << "aad_file_unique=";
  (__isset.aad_file_unique ? (out << to_string(aad_file_unique))
                           : (out << "<null>"));
  out << ", "
      << "supply_aad_prefix=";
  (__isset.supply_aad_prefix ? (out << to_string(supply_aad_prefix))
                             : (out << "<null>"));
  out << ")";
}

EncryptionAlgorithm::~EncryptionAlgorithm() noexcept {}

void EncryptionAlgorithm::__set_AES_GCM_V1(const AesGcmV1& val) {
  this->AES_GCM_V1 = val;
  __isset.AES_GCM_V1 = true;
}

void EncryptionAlgorithm::__set_AES_GCM_CTR_V1(const AesGcmCtrV1& val) {
  this->AES_GCM_CTR_V1 = val;
  __isset.AES_GCM_CTR_V1 = true;
}
std::ostream& operator<<(std::ostream& out, const EncryptionAlgorithm& obj) {
  obj.printTo(out);
  return out;
}

uint32_t EncryptionAlgorithm::read(
    ::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->AES_GCM_V1.read(iprot);
          this->__isset.AES_GCM_V1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->AES_GCM_CTR_V1.read(iprot);
          this->__isset.AES_GCM_CTR_V1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EncryptionAlgorithm::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EncryptionAlgorithm");

  if (this->__isset.AES_GCM_V1) {
    xfer += oprot->writeFieldBegin(
        "AES_GCM_V1", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->AES_GCM_V1.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.AES_GCM_CTR_V1) {
    xfer += oprot->writeFieldBegin(
        "AES_GCM_CTR_V1", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->AES_GCM_CTR_V1.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EncryptionAlgorithm& a, EncryptionAlgorithm& b) {
  using ::std::swap;
  swap(a.AES_GCM_V1, b.AES_GCM_V1);
  swap(a.AES_GCM_CTR_V1, b.AES_GCM_CTR_V1);
  swap(a.__isset, b.__isset);
}

EncryptionAlgorithm::EncryptionAlgorithm(const EncryptionAlgorithm& other279) {
  AES_GCM_V1 = other279.AES_GCM_V1;
  AES_GCM_CTR_V1 = other279.AES_GCM_CTR_V1;
  __isset = other279.__isset;
}
EncryptionAlgorithm::EncryptionAlgorithm(
    EncryptionAlgorithm&& other280) noexcept {
  AES_GCM_V1 = std::move(other280.AES_GCM_V1);
  AES_GCM_CTR_V1 = std::move(other280.AES_GCM_CTR_V1);
  __isset = other280.__isset;
}
EncryptionAlgorithm& EncryptionAlgorithm::operator=(
    const EncryptionAlgorithm& other281) {
  AES_GCM_V1 = other281.AES_GCM_V1;
  AES_GCM_CTR_V1 = other281.AES_GCM_CTR_V1;
  __isset = other281.__isset;
  return *this;
}
EncryptionAlgorithm& EncryptionAlgorithm::operator=(
    EncryptionAlgorithm&& other282) noexcept {
  AES_GCM_V1 = std::move(other282.AES_GCM_V1);
  AES_GCM_CTR_V1 = std::move(other282.AES_GCM_CTR_V1);
  __isset = other282.__isset;
  return *this;
}
void EncryptionAlgorithm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EncryptionAlgorithm(";
  out << "AES_GCM_V1=";
  (__isset.AES_GCM_V1 ? (out << to_string(AES_GCM_V1)) : (out << "<null>"));
  out << ", "
      << "AES_GCM_CTR_V1=";
  (__isset.AES_GCM_CTR_V1 ? (out << to_string(AES_GCM_CTR_V1))
                          : (out << "<null>"));
  out << ")";
}

FileMetaData::~FileMetaData() noexcept {}

void FileMetaData::__set_version(const int32_t val) {
  this->version = val;
}

void FileMetaData::__set_schema(const std::vector<SchemaElement>& val) {
  this->schema = val;
}

void FileMetaData::__set_num_rows(const int64_t val) {
  this->num_rows = val;
}

void FileMetaData::__set_row_groups(const std::vector<RowGroup>& val) {
  this->row_groups = val;
}

void FileMetaData::__set_key_value_metadata(const std::vector<KeyValue>& val) {
  this->key_value_metadata = val;
  __isset.key_value_metadata = true;
}

void FileMetaData::__set_created_by(const std::string& val) {
  this->created_by = val;
  __isset.created_by = true;
}

void FileMetaData::__set_column_orders(const std::vector<ColumnOrder>& val) {
  this->column_orders = val;
  __isset.column_orders = true;
}

void FileMetaData::__set_encryption_algorithm(const EncryptionAlgorithm& val) {
  this->encryption_algorithm = val;
  __isset.encryption_algorithm = true;
}

void FileMetaData::__set_footer_signing_key_metadata(const std::string& val) {
  this->footer_signing_key_metadata = val;
  __isset.footer_signing_key_metadata = true;
}
std::ostream& operator<<(std::ostream& out, const FileMetaData& obj) {
  obj.printTo(out);
  return out;
}

uint32_t FileMetaData::read(::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_version = false;
  bool isset_schema = false;
  bool isset_num_rows = false;
  bool isset_row_groups = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->schema.clear();
            uint32_t _size283;
            ::apache::thrift::protocol::TType _etype286;
            xfer += iprot->readListBegin(_etype286, _size283);
            this->schema.resize(_size283);
            uint32_t _i287;
            for (_i287 = 0; _i287 < _size283; ++_i287) {
              xfer += this->schema[_i287].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_schema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_rows);
          isset_num_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_groups.clear();
            uint32_t _size288;
            ::apache::thrift::protocol::TType _etype291;
            xfer += iprot->readListBegin(_etype291, _size288);
            this->row_groups.resize(_size288);
            uint32_t _i292;
            for (_i292 = 0; _i292 < _size288; ++_i292) {
              xfer += this->row_groups[_i292].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_row_groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_value_metadata.clear();
            uint32_t _size293;
            ::apache::thrift::protocol::TType _etype296;
            xfer += iprot->readListBegin(_etype296, _size293);
            this->key_value_metadata.resize(_size293);
            uint32_t _i297;
            for (_i297 = 0; _i297 < _size293; ++_i297) {
              xfer += this->key_value_metadata[_i297].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.key_value_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->created_by);
          this->__isset.created_by = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_orders.clear();
            uint32_t _size298;
            ::apache::thrift::protocol::TType _etype301;
            xfer += iprot->readListBegin(_etype301, _size298);
            this->column_orders.resize(_size298);
            uint32_t _i302;
            for (_i302 = 0; _i302 < _size298; ++_i302) {
              xfer += this->column_orders[_i302].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_orders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->encryption_algorithm.read(iprot);
          this->__isset.encryption_algorithm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->footer_signing_key_metadata);
          this->__isset.footer_signing_key_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schema)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_rows)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_row_groups)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t FileMetaData::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FileMetaData");

  xfer +=
      oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer +=
      oprot->writeFieldBegin("schema", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(
        ::apache::thrift::protocol::T_STRUCT,
        static_cast<uint32_t>(this->schema.size()));
    std::vector<SchemaElement>::const_iterator _iter303;
    for (_iter303 = this->schema.begin(); _iter303 != this->schema.end();
         ++_iter303) {
      xfer += (*_iter303).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer +=
      oprot->writeFieldBegin("num_rows", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->num_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin(
      "row_groups", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(
        ::apache::thrift::protocol::T_STRUCT,
        static_cast<uint32_t>(this->row_groups.size()));
    std::vector<RowGroup>::const_iterator _iter304;
    for (_iter304 = this->row_groups.begin();
         _iter304 != this->row_groups.end();
         ++_iter304) {
      xfer += (*_iter304).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.key_value_metadata) {
    xfer += oprot->writeFieldBegin(
        "key_value_metadata", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(
          ::apache::thrift::protocol::T_STRUCT,
          static_cast<uint32_t>(this->key_value_metadata.size()));
      std::vector<KeyValue>::const_iterator _iter305;
      for (_iter305 = this->key_value_metadata.begin();
           _iter305 != this->key_value_metadata.end();
           ++_iter305) {
        xfer += (*_iter305).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.created_by) {
    xfer += oprot->writeFieldBegin(
        "created_by", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->created_by);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_orders) {
    xfer += oprot->writeFieldBegin(
        "column_orders", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(
          ::apache::thrift::protocol::T_STRUCT,
          static_cast<uint32_t>(this->column_orders.size()));
      std::vector<ColumnOrder>::const_iterator _iter306;
      for (_iter306 = this->column_orders.begin();
           _iter306 != this->column_orders.end();
           ++_iter306) {
        xfer += (*_iter306).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.encryption_algorithm) {
    xfer += oprot->writeFieldBegin(
        "encryption_algorithm", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->encryption_algorithm.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.footer_signing_key_metadata) {
    xfer += oprot->writeFieldBegin(
        "footer_signing_key_metadata", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeBinary(this->footer_signing_key_metadata);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FileMetaData& a, FileMetaData& b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.schema, b.schema);
  swap(a.num_rows, b.num_rows);
  swap(a.row_groups, b.row_groups);
  swap(a.key_value_metadata, b.key_value_metadata);
  swap(a.created_by, b.created_by);
  swap(a.column_orders, b.column_orders);
  swap(a.encryption_algorithm, b.encryption_algorithm);
  swap(a.footer_signing_key_metadata, b.footer_signing_key_metadata);
  swap(a.__isset, b.__isset);
}

FileMetaData::FileMetaData(const FileMetaData& other307) {
  version = other307.version;
  schema = other307.schema;
  num_rows = other307.num_rows;
  row_groups = other307.row_groups;
  key_value_metadata = other307.key_value_metadata;
  created_by = other307.created_by;
  column_orders = other307.column_orders;
  encryption_algorithm = other307.encryption_algorithm;
  footer_signing_key_metadata = other307.footer_signing_key_metadata;
  __isset = other307.__isset;
}
FileMetaData::FileMetaData(FileMetaData&& other308) noexcept {
  version = other308.version;
  schema = std::move(other308.schema);
  num_rows = other308.num_rows;
  row_groups = std::move(other308.row_groups);
  key_value_metadata = std::move(other308.key_value_metadata);
  created_by = std::move(other308.created_by);
  column_orders = std::move(other308.column_orders);
  encryption_algorithm = std::move(other308.encryption_algorithm);
  footer_signing_key_metadata = std::move(other308.footer_signing_key_metadata);
  __isset = other308.__isset;
}
FileMetaData& FileMetaData::operator=(const FileMetaData& other309) {
  version = other309.version;
  schema = other309.schema;
  num_rows = other309.num_rows;
  row_groups = other309.row_groups;
  key_value_metadata = other309.key_value_metadata;
  created_by = other309.created_by;
  column_orders = other309.column_orders;
  encryption_algorithm = other309.encryption_algorithm;
  footer_signing_key_metadata = other309.footer_signing_key_metadata;
  __isset = other309.__isset;
  return *this;
}
FileMetaData& FileMetaData::operator=(FileMetaData&& other310) noexcept {
  version = other310.version;
  schema = std::move(other310.schema);
  num_rows = other310.num_rows;
  row_groups = std::move(other310.row_groups);
  key_value_metadata = std::move(other310.key_value_metadata);
  created_by = std::move(other310.created_by);
  column_orders = std::move(other310.column_orders);
  encryption_algorithm = std::move(other310.encryption_algorithm);
  footer_signing_key_metadata = std::move(other310.footer_signing_key_metadata);
  __isset = other310.__isset;
  return *this;
}
void FileMetaData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FileMetaData(";
  out << "version=" << to_string(version);
  out << ", "
      << "schema=" << to_string(schema);
  out << ", "
      << "num_rows=" << to_string(num_rows);
  out << ", "
      << "row_groups=" << to_string(row_groups);
  out << ", "
      << "key_value_metadata=";
  (__isset.key_value_metadata ? (out << to_string(key_value_metadata))
                              : (out << "<null>"));
  out << ", "
      << "created_by=";
  (__isset.created_by ? (out << to_string(created_by)) : (out << "<null>"));
  out << ", "
      << "column_orders=";
  (__isset.column_orders ? (out << to_string(column_orders))
                         : (out << "<null>"));
  out << ", "
      << "encryption_algorithm=";
  (__isset.encryption_algorithm ? (out << to_string(encryption_algorithm))
                                : (out << "<null>"));
  out << ", "
      << "footer_signing_key_metadata=";
  (__isset.footer_signing_key_metadata
       ? (out << to_string(footer_signing_key_metadata))
       : (out << "<null>"));
  out << ")";
}

FileCryptoMetaData::~FileCryptoMetaData() noexcept {}

void FileCryptoMetaData::__set_encryption_algorithm(
    const EncryptionAlgorithm& val) {
  this->encryption_algorithm = val;
}

void FileCryptoMetaData::__set_key_metadata(const std::string& val) {
  this->key_metadata = val;
  __isset.key_metadata = true;
}
std::ostream& operator<<(std::ostream& out, const FileCryptoMetaData& obj) {
  obj.printTo(out);
  return out;
}

uint32_t FileCryptoMetaData::read(
    ::apache::thrift::protocol::TProtocol* iprot) {
  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_encryption_algorithm = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->encryption_algorithm.read(iprot);
          isset_encryption_algorithm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key_metadata);
          this->__isset.key_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_encryption_algorithm)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t FileCryptoMetaData::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FileCryptoMetaData");

  xfer += oprot->writeFieldBegin(
      "encryption_algorithm", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->encryption_algorithm.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.key_metadata) {
    xfer += oprot->writeFieldBegin(
        "key_metadata", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->key_metadata);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FileCryptoMetaData& a, FileCryptoMetaData& b) {
  using ::std::swap;
  swap(a.encryption_algorithm, b.encryption_algorithm);
  swap(a.key_metadata, b.key_metadata);
  swap(a.__isset, b.__isset);
}

FileCryptoMetaData::FileCryptoMetaData(const FileCryptoMetaData& other311) {
  encryption_algorithm = other311.encryption_algorithm;
  key_metadata = other311.key_metadata;
  __isset = other311.__isset;
}
FileCryptoMetaData::FileCryptoMetaData(FileCryptoMetaData&& other312) noexcept {
  encryption_algorithm = std::move(other312.encryption_algorithm);
  key_metadata = std::move(other312.key_metadata);
  __isset = other312.__isset;
}
FileCryptoMetaData& FileCryptoMetaData::operator=(
    const FileCryptoMetaData& other313) {
  encryption_algorithm = other313.encryption_algorithm;
  key_metadata = other313.key_metadata;
  __isset = other313.__isset;
  return *this;
}
FileCryptoMetaData& FileCryptoMetaData::operator=(
    FileCryptoMetaData&& other314) noexcept {
  encryption_algorithm = std::move(other314.encryption_algorithm);
  key_metadata = std::move(other314.key_metadata);
  __isset = other314.__isset;
  return *this;
}
void FileCryptoMetaData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FileCryptoMetaData(";
  out << "encryption_algorithm=" << to_string(encryption_algorithm);
  out << ", "
      << "key_metadata=";
  (__isset.key_metadata ? (out << to_string(key_metadata)) : (out << "<null>"));
  out << ")";
}

} // namespace facebook::velox::parquet::arrow::format
