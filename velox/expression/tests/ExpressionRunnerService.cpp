/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <folly/init/Init.h>
#include <folly/io/async/EventBase.h>
#include <folly/io/async/EventBaseManager.h>
#include <folly/json.h>
#include <folly/portability/GFlags.h>
#include <gflags/gflags.h>
#include <glog/logging.h>
#include <proxygen/httpserver/HTTPServer.h>
#include <proxygen/httpserver/RequestHandler.h>
#include <proxygen/httpserver/RequestHandlerFactory.h>
#include <proxygen/httpserver/ResponseBuilder.h>
#include <memory>
#include <string>
#include "velox/common/base/Fs.h"
#include "velox/common/file/FileSystems.h"
#include "velox/connectors/hive/HiveConnector.h"
#include "velox/dwio/dwrf/RegisterDwrfWriter.h"
#include "velox/exec/fuzzer/FuzzerUtil.h"
#include "velox/exec/fuzzer/PrestoQueryRunner.h"
#include "velox/exec/fuzzer/ReferenceQueryRunner.h"
#include "velox/expression/tests/ExpressionRunner.h"
#include "velox/expression/tests/ExpressionVerifier.h"
#include "velox/functions/prestosql/registration/RegistrationFunctions.h"
#include "velox/functions/sparksql/registration/Register.h"
#include "velox/vector/VectorSaver.h"

using namespace facebook::velox;
using namespace proxygen;
using facebook::velox::exec::test::PrestoQueryRunner;
using facebook::velox::test::ReferenceQueryRunner;

DEFINE_int32(port, 8080, "Port to listen on");
DEFINE_string(
    registry,
    "presto",
    "Function registry to use for expression evaluation. Currently supported values are "
    "presto and spark. Default is presto.");
DEFINE_string(
    mode,
    "common",
    "Mode for expression runner: \n"
    "verify: evaluate the expression and compare results between common and "
    "simplified paths.\n"
    "common: evaluate the expression using common path and print out results.\n"
    "simplified: evaluate the expression using simplified path and print out "
    "results.\n"
    "query: evaluate SQL query specified in --sql or --sql_path and print out "
    "results. If --input_paths is specified, the query may reference it as "
    "table 't'. Note: --input_selectivity_vector_paths is ignored in this mode");
DEFINE_bool(
    use_seperate_memory_pool_for_input_vector,
    true,
    "If true, expression evaluator and input vectors use different memory pools."
    " This helps trigger code-paths that can depend on vectors having different"
    " pools. For eg, when copying a flat string vector copies of the strings"
    " stored in the string buffers need to be created. If however, the pools"
    " were the same between the vectors then the buffers can simply be shared"
    " between them instead.");
DEFINE_string(
    fuzzer_repro_path,
    "",
    "Directory path where all input files generated by ExpressionVerifier are "
    "expected to reside. For more details on which files and their names are "
    "expected, please checkout the ExpressionVerifier class. Any file paths "
    "already specified via a startup flag will take precedence.");

static bool validateMode(const char* flagName, const std::string& value) {
  static const std::unordered_set<std::string> kModes = {
      "common", "simplified", "verify", "query"};
  if (kModes.count(value) != 1) {
    std::cerr << "Invalid value for --" << flagName << ": " << value << ". ";
    std::cerr << "Valid values are: " << folly::join(", ", kModes) << "."
              << std::endl;
    return false;
  }

  return true;
}

static bool validateRegistry(const char* flagName, const std::string& value) {
  static const std::unordered_set<std::string> kRegistries = {
      "presto", "spark"};
  if (kRegistries.count(value) != 1) {
    std::cerr << "Invalid value for --" << flagName << ": " << value << ". ";
    std::cerr << "Valid values are: " << folly::join(", ", kRegistries) << "."
              << std::endl;
    return false;
  }
  if (value == "spark") {
    functions::sparksql::registerFunctions("");
  } else if (value == "presto") {
    functions::prestosql::registerAllScalarFunctions();
  }

  return true;
}

DEFINE_validator(mode, &validateMode);
DEFINE_validator(registry, &validateRegistry);

static std::string checkAndReturnFilePath(
    const std::string_view& fileName,
    const std::string& flagName,
    const std::string& fuzzerReproPath) {
  auto path = fmt::format("{}/{}", fuzzerReproPath, fileName);
  if (fs::exists(path)) {
    LOG(INFO) << "Using " << flagName << " = " << path;
    return path;
  } else {
    LOG(INFO) << "File for " << flagName << " not found.";
  }
  return "";
}

static std::string getFilesWithPrefix(
    const char* dirPath,
    const std::string_view& prefix,
    const std::string& flagName) {
  std::vector<std::string> filesPaths;
  std::stringstream ss;
  int numFilesFound = 0;
  if (!std::filesystem::exists(dirPath)) {
    LOG(ERROR) << "Directory does not exist: " << dirPath << std::endl;
    return "";
  }
  for (const auto& entry : std::filesystem::directory_iterator(dirPath)) {
    if (entry.is_regular_file()) {
      std::string filename = entry.path().filename();
      if (filename.find(prefix) == 0) {
        if (++numFilesFound > 1) {
          ss << ",";
        }
        ss << entry.path().string();
      }
    }
  }
  LOG(INFO) << "Using " << flagName << " = " << ss.str();
  return ss.str();
}

static void checkDirForExpectedFiles(
    const std::string& fuzzerReproPath,
    std::string& inputPaths,
    std::string& inputSelectivityVectorPaths,
    std::string& resultPath,
    std::string& sqlPath,
    std::string& inputRowMetadataPath,
    std::string& complexConstantPath) {
  LOG(INFO) << "Searching input directory for expected files at "
            << fuzzerReproPath;

  inputPaths = inputPaths.empty()
      ? getFilesWithPrefix(
            fuzzerReproPath.c_str(),
            test::ExpressionVerifier::kInputVectorFileNamePrefix,
            "input_paths")
      : inputPaths;
  inputSelectivityVectorPaths = inputSelectivityVectorPaths.empty()
      ? getFilesWithPrefix(
            fuzzerReproPath.c_str(),
            test::ExpressionVerifier::kInputSelectivityVectorFileNamePrefix,
            "input_selectivity_vector_paths")
      : inputSelectivityVectorPaths;
  resultPath = resultPath.empty()
      ? checkAndReturnFilePath(
            test::ExpressionVerifier::kResultVectorFileName,
            "result_path",
            fuzzerReproPath)
      : resultPath;
  sqlPath = sqlPath.empty()
      ? checkAndReturnFilePath(
            test::ExpressionVerifier::kExpressionSqlFileName,
            "sql_path",
            fuzzerReproPath)
      : sqlPath;
  inputRowMetadataPath = inputRowMetadataPath.empty()
      ? checkAndReturnFilePath(
            test::ExpressionVerifier::kInputRowMetadataFileName,
            "input_row_metadata_path",
            fuzzerReproPath)
      : inputRowMetadataPath;
  complexConstantPath = complexConstantPath.empty()
      ? checkAndReturnFilePath(
            test::ExpressionVerifier::kComplexConstantsFileName,
            "complex_constant_path",
            fuzzerReproPath)
      : complexConstantPath;
}

// Capture stdout to a string
class StdoutCapture {
 public:
  StdoutCapture() {
    oldCoutBuf_ = std::cout.rdbuf();
    std::cout.rdbuf(buffer_.rdbuf());
  }

  ~StdoutCapture() {
    std::cout.rdbuf(oldCoutBuf_);
  }

  std::string str() const {
    return buffer_.str();
  }

 private:
  std::stringstream buffer_;
  std::streambuf* oldCoutBuf_;
};

// Handler for HTTP requests
class ExpressionRunnerHandler : public RequestHandler {
 public:
  void onRequest(std::unique_ptr<HTTPMessage> request) noexcept override {
    request_ = std::move(request);
  }

  void onBody(std::unique_ptr<folly::IOBuf> body) noexcept override {
    if (body_) {
      body_->prependChain(std::move(body));
    } else {
      body_ = std::move(body);
    }
  }

  void onEOM() noexcept override {
    try {
      // Parse the request body as JSON
      std::string bodyStr;
      if (body_) {
        bodyStr = body_->moveToFbString().toStdString();
      }

      folly::dynamic requestJson = folly::parseJson(bodyStr);

      // Extract fuzzer_repro_path from the JSON
      std::string fuzzerReproPath =
          requestJson.getDefault("fuzzer_repro_path", "").asString();
      int numRows = requestJson.getDefault("num_rows", 0).asInt();
      std::string storeResultPath =
          requestJson.getDefault("store_result_path", "").asString();

      // Validate required parameters
      if (fuzzerReproPath.empty()) {
        ResponseBuilder(downstream_)
            .status(400, "Bad Request")
            .body("fuzzer_repro_path is required")
            .sendWithEOM();
        return;
      }

      // Initialize parameters
      std::string inputPaths = "";
      std::string inputSelectivityVectorPaths = "";
      std::string resultPath = "";
      std::string sqlPath = "";
      std::string inputRowMetadataPath = "";
      std::string complexConstantPath = "";

      // Check directory for expected files
      checkDirForExpectedFiles(
          fuzzerReproPath,
          inputPaths,
          inputSelectivityVectorPaths,
          resultPath,
          sqlPath,
          inputRowMetadataPath,
          complexConstantPath);

      // Read SQL from file
      std::string sql = "";
      if (!sqlPath.empty()) {
        sql = restoreStringFromFile(sqlPath.c_str());
        if (sql.empty()) {
          ResponseBuilder(downstream_)
              .status(400, "Bad Request")
              .body("Failed to read SQL from file: " + sqlPath)
              .sendWithEOM();
          return;
        }
      } else {
        ResponseBuilder(downstream_)
            .status(400, "Bad Request")
            .body("SQL file not found in fuzzer_repro_path")
            .sendWithEOM();
        return;
      }

      // Capture stdout to return as part of the response
      StdoutCapture stdoutCapture;

      // Run the expression
      std::shared_ptr<facebook::velox::memory::MemoryPool> rootPool{
          facebook::velox::memory::memoryManager()->addRootPool()};
      std::shared_ptr<ReferenceQueryRunner> referenceQueryRunner{nullptr};

      test::ExpressionRunner::run(
          inputPaths,
          inputSelectivityVectorPaths,
          sql,
          complexConstantPath,
          resultPath,
          FLAGS_mode,
          numRows,
          storeResultPath,
          inputRowMetadataPath,
          referenceQueryRunner,
          false, // findMinimalSubExpression
          FLAGS_use_seperate_memory_pool_for_input_vector);

      // Create response JSON
      folly::dynamic responseJson = folly::dynamic::object;
      responseJson["status"] = "success";
      responseJson["output"] = stdoutCapture.str();

      // Send the response
      ResponseBuilder(downstream_)
          .status(200, "OK")
          .header("Content-Type", "application/json")
          .body(folly::toJson(responseJson))
          .sendWithEOM();

    } catch (const std::exception& e) {
      // Handle exceptions
      folly::dynamic errorJson = folly::dynamic::object;
      errorJson["status"] = "error";
      errorJson["message"] = e.what();

      ResponseBuilder(downstream_)
          .status(500, "Internal Server Error")
          .header("Content-Type", "application/json")
          .body(folly::toJson(errorJson))
          .sendWithEOM();
    }
  }

  void onUpgrade(UpgradeProtocol /*protocol*/) noexcept override {
    // Not implemented
  }

  void requestComplete() noexcept override {
    delete this;
  }

  void onError(ProxygenError /*err*/) noexcept override {
    delete this;
  }

 private:
  std::unique_ptr<HTTPMessage> request_;
  std::unique_ptr<folly::IOBuf> body_;
};

// Factory for creating request handlers
class ExpressionRunnerHandlerFactory : public RequestHandlerFactory {
 public:
  void onServerStart(folly::EventBase* /*evb*/) noexcept override {}

  void onServerStop() noexcept override {}

  RequestHandler* onRequest(RequestHandler*, HTTPMessage*) noexcept override {
    return new ExpressionRunnerHandler();
  }
};

int main(int argc, char** argv) {
  // Initialize gflags and glog
  folly::Init init(&argc, &argv);

  // Initialize memory manager
  memory::initializeMemoryManager(memory::MemoryManager::Options{});

  // Register file systems and connectors
  filesystems::registerLocalFileSystem();
  connector::registerConnectorFactory(
      std::make_shared<connector::hive::HiveConnectorFactory>());
  exec::test::registerHiveConnector({});
  dwrf::registerDwrfWriterFactory();

  // Set up the HTTP server
  std::vector<HTTPServer::IPConfig> IPs = {
      {folly::SocketAddress("127.0.0.1", FLAGS_port),
       HTTPServer::Protocol::HTTP}};

  HTTPServerOptions options;
  options.threads = 4;
  options.idleTimeout = std::chrono::milliseconds(60000);
  options.shutdownOn = {SIGINT, SIGTERM};
  options.enableContentCompression = false;
  options.handlerFactories =
      RequestHandlerChain().addThen<ExpressionRunnerHandlerFactory>().build();

  // Create and start the server
  HTTPServer server(std::move(options));
  server.bind(IPs);

  LOG(INFO) << "Starting ExpressionRunner service on port " << FLAGS_port;

  // Start the server
  std::thread t([&]() { server.start(); });

  // Wait for the server to exit
  t.join();

  return 0;
}
